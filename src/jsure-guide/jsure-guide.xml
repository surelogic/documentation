<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book id="jsure-examples" lang="en-US">
  <title>JSure User Guide</title>
  <subtitle>How to use and configure the JSure Eclipse client</subtitle>
  <bookinfo>
    <copyright>
      <year>2008</year>
      <holder>SureLogic, Inc.</holder>
    </copyright>
    <legalnotice>
      <para>The authors and publishers have taken care in the
      preparation of this documentation, but make no expressed or
      implied warranty of any kind and assume no responsibility for
      errors and omissions. No liability is assumed for incidental or
      consequential damages in connection with or arising out of the use
      of the information or programs herein.</para>
    </legalnotice>
    <pubdate>Version 1.0&mdash;January 2009</pubdate>
  </bookinfo>

  <chapter id="preface">
    <title>Preface</title>
    <sect1>
      <title>Audience</title>
      <para>This document is intended for Java developers who want to
      use the JSure tool within the Eclipse Java IDE. We assume
      that the reader understands both the Java programming language and
      the use of Eclipse for Java development.</para>
    </sect1>
    <sect1>
      <title>Contact information</title>
      <para>For technical support or other questions, please
      contact:</para>
      <para><email>support@surelogic.com</email></para>
      <para>5808 Forbes Avenue, Pittsburgh, PA 15217-1602</para>
    </sect1>
  </chapter>

  <chapter id="getting-started">
    <title>Getting started</title>
    <sect1>
      <title>Introduction</title>

      <para><emphasis>What is JSure?</emphasis> TODO</para>
    </sect1>

    <sect1>
      <title>Quick start: How to scan your code and start adding design
      intent</title>

      <para>This section assumes that you have installed JSure. If you
      see a <guimenu>JSure</guimenu> menu item on your Eclipse main menu
      then you can assume JSure has been properly installed.</para>
    </sect1>

    <sect1>
      <title>Tutorial: Verifying BoundedFIFO</title>
    
      <para>This example walks through the complete assurance of a
      simple class and its usage. That is, it demonstrates that is not
      always enough to assure the implementation of a class:
      <emphasis>sometimes the clients of a class must conform to a
      specific behavior as well</emphasis>. This example focuses on
      two classes (plus one auxillary class):</para>
    
      <variablelist>
        <varlistentry>
          <term><varname>BoundedFIFO</varname></term>
          <listitem><para>The "thread safe" class.  See <xref
          linkend="BoundedFIFO.java"/></para></listitem>
        </varlistentry>
      
        <varlistentry>
          <term><varname>BlockingFIFO</varname></term>
          <listitem><para>The client code.  See <xref
          linkend="BlockingFIFO.java"/></para></listitem>
        </varlistentry>
      
        <varlistentry>
          <term><varname>LoggingEvent</varname></term>
          <listitem><para>The class of objects stored in the queue.  See
          <xref
          linkend="LoggingEvent.java"/></para></listitem>
        </varlistentry>
      </variablelist>
    
      <para>The class <varname>BoundedFIFO</varname> is taken from the
      <application>Apache Log4J</application> project. The class
      <varname>BlockingFIFO</varname> we wrote based on actual client code
      in <application>Log4J</application>.</para>

      <para>This example shows off basic features of assuring Java
      lock models using Java intrinsic lock objects:</para>
    
      <itemizedlist>
        <listitem><para><varname>@RegionLock</varname></para></listitem>
        <listitem><para><varname>@RequiresLock</varname></para></listitem>
        <listitem><para><varname>@SingleThreaded</varname></para></listitem>
        <listitem><para><varname>@Borrowed</varname></para></listitem>
        <listitem><para><varname>@Unique</varname></para></listitem>
        <listitem><para><varname>@Aggregate</varname></para></listitem>
        <listitem><para><varname>@Promise</varname></para></listitem>
      </itemizedlist>
    
      <figure id="BoundedFIFO.java">
        <title>Initial Source Code for class <varname>BoundedFIFO</varname></title>
      
        <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  LoggingEvent[] buf;
  
  int numElts = 0;
  int first = 0;
  int next = 0;
  int size;

  /**
   * Instantiate a new BoundedFIFO with a maximum size passed as argument.
   *
   * @param size Maximum size of the BoundedFIFO created.
   */
  public BoundedFIFO(int size) {
    if (size &lt; 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
  }

  /**
   * Get the first element in the buffer. Returns &lt;code&gt;null&lt;/code&gt; if
   * there are no elements in the buffer.
   */
  public LoggingEvent get() {
    if (numElts == 0)
      return null;
    LoggingEvent r = buf[next];
    if (++first == size)
      first = 0;
    numElts--;
    return r;
  }

  /**
   * Place a {@link LoggingEvent} in the buffer. If the buffer is full  then
   * the event is &lt;b&gt;silently dropped&lt;/b&gt;. It is the caller's  responsibility
   * to make sure that the buffer has free space.
   * 
   * @param o The logging event added into the buffer.
   */
  public void put(LoggingEvent o) {
    if (numElts != size) {
      buf[next] = o;
      if (++next == size)
        next = 0;
      numElts++;
    }
  }

  /** 
   * Get the maximum size of the buffer.
   */
  public int getMaxSize() {
    return size;
  }

  /**
   * Get the number of elements in the buffer. This number is guaranteed to be
   * in the range 0 to &lt;code&gt;maxSize&lt;/code&gt; (inclusive).
   */
  public int length() {
    return numElts;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if there is just one element in the buffer. In
   * other words, if there were no elements before the last {@link #put}
   * operation completed.
   */
  public boolean wasEmpty() {
    return numElts == 1;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the number of elements in the buffer plus 1
   * equals the maximum buffer size, returns &lt;code&gt;false&lt;/code&gt; otherwise.
   */
  public boolean wasFull() {
    return numElts + 1 == size;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the number of elements in the buffer equals
   * the maximum buffer size, returns &lt;code&gt;false&lt;/code&gt; otherwise.
   */
  public boolean isFull() {
    return numElts == size;
  }
}
        </programlisting>
      </figure>

      <figure id="BlockingFIFO.java">
        <title>Initial Source Code for class
        <filename>BlockingFIFO</filename></title>
      
        <programlisting>
          <![CDATA[
public class BlockingFIFO {
  private final BoundedFIFO fifo;;

  public BlockingFIFO(int size) {
    fifo = new BoundedFIFO(size);
  }

  public void put(LoggingEvent e) {
    synchronized (this) {
      while (fifo.isFull()) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      fifo.put(e);
      if (fifo.wasEmpty()) {
        fifo.notify();
      }
      fifo.put(e);
      fifo.put(e);
    }
  }

  public LoggingEvent get() {
    synchronized (fifo) {
      LoggingEvent e;
      while (fifo.length() == 0) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      e = fifo.get();
      if (fifo.wasFull()) {
        fifo.notify();
      }
      return e;
    }
  }

  public int length() {
    synchronized (fifo) {
      return fifo.length();
    }
  }
}
          ]]>
        </programlisting>
      </figure>

      <figure id="LoggingEvent.java">
        <title>Initial Source Code for class <varname>BlockingFIFO</varname></title>
      
        <programlisting>
          <![CDATA[
public class LoggingEvent { 
  /* Empty: The contents of this class are not interesting 
   * for our example.
   */
}
          ]]>
        </programlisting>
      </figure>
    
      <sect2 id="declaring-protected-state">
        <title>Declaring Protected State</title>
      
        <para>The <varname>BoundedFIFO</varname> class is a buffer
        meant to be shared between two threads. It obviously must be
        made thread-safe. The usual assumption is that an object
        protects its own state.  In <xref
        linkend="BoundedFIFO.java"/> the class is already
        annotated with this assumption:</para>
      
        <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  &hellip;
}
        </programlisting>

        <para>With this single annotation, analysis by JSure produces
        two main concurrency results, mostly indicating that the
        annotation is not assured, and a few warnings.  There are 27
        unprotected field accesses for <varname>BufLock</varname>, and
        no protected field accesses:</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO1.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO1.png"/>
          </imageobject>
        </mediaobject>
      </sect2>

      <sect2 id="declaring-lock-preconditions">
        <title>Declaring Lock Preconditions</title>
    
        <para>Either this class is horribly broken or something else
        is going on.  By double clicking on any of the errors in the
        view, we can focus on the source line in
        <varname>BoundedFIFO</varname>. A quick inspectiion of the
        class reveals that it does not acquire the lock anywhere.  So
        we look at its clients by viewing the call chain, in this case
        by viewing the call hierarchy of method
        <varname>get()</varname> (Select the method
        <varname>get()</varname> in the "Outline" view and then choose
        <menuchoice><guimenuitem>Open Call
        Hierarchy</guimenuitem></menuchoice> in the context menu).  We
        see that the client, <varname>BlockingFIFO</varname> acquires
        the lock on the <varname>BoundedFIFO</varname> object before
        invoking any of the methods on the
        <varname>BoundedFIFO</varname> object, so we decide that the
        intent is that the caller should acquire the lock before
        calling any of the methods of
        <varname>BoundedFIFO</varname>.</para>

        <para>To add this intent to <varname>BoundedFIFO</varname>, we
        need to add the lock precondition
        <varname>@RequiresLock("BufLock")</varname> to all the methods
        of the class.  We can do this in a single annotation on the
        class itself by using a <emphasis>scoped promise</emphasis> to
        add the annotation to all the methods of the class:</para>
    
        <programlisting>
 @RegionLock("BufLock is this protects Instance")
 <emphasis>@Promise("'@RequiresLock BufLock' for *(**)")</emphasis>
 public class BoundedFIFO {
  &hellip;
 }
        </programlisting>  

        <para>After adding the annotation we save (and thus reanalyze
        the project).</para>
      </sect2>  
    
      <sect2 id="wrong-lock">
        <title>Wrong Lock</title>
      
        <para>There is now a "scoped promises" heading, and we can see
        all the places where our <varname>@Promise</varname>
        annotation added <varname>@RequiresLock</varname>
        annotations. Only 4 out of the 7 are currently
        satisfied:</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO2.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO2.png"/>
          </imageobject>
        </mediaobject>
      
        <para>Looking at the chain of evidence for the call to
        <varname>isFull()</varname>, we see that the caller is
        confused and is synchronized on <varname>this</varname> (as
        evidenced by the caller holding the lock "this.MUTEX"):</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO3.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO3.png"/>
          </imageobject>
        </mediaobject>

        <para>But in the context of the caller,
        <varname>BlockingFIFO</varname>, <varname>this</varname>
        refers to the <varname>BlockingFIFO</varname> object, not the
        <varname>BoundedFIFO</varname> object that is correctly
        refered to by <varname>fifo</varname>. The
        <varname>synchronized</varname> statement in method
        <varname>isFull()</varname> needs to be changed:</para>

        <programlisting>
 public void put(LoggingEvent e) {
   synchronized (<emphasis>fifo</emphasis>) {
     &hellip;
   }
 }
        </programlisting>
      </sect2>
    
      <sect2 id="single-threaded-constructor">
        <title>Single Threaded Constructor</title>

        <para>There are still five unprotected field accesses. These
        all point to either field initializers in field declarations
        or in the constructor: </para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO4.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4.png"/>
          </imageobject>
        </mediaobject>
      
        <para>Because the lock on the <varname>BoundedFIFO</varname>
        object is not held during construction, we need to make sure
        that during construction a reference to the object cannot be
        leaked to another thread. Note that we cannot require the
        caller of the constructor to hold the lock because the object
        doesn't exist yet!  In general, we cannot use
        <varname>synchronized</varname> blocks in the constructor to
        protect the state during construction because we cannot create
        a single atomic block: there would have to be multiple
        distinct <varname>synchronized</varname> blocks in the
        constructor and in the constructors of any subclasses. But if
        we can guarantee that the thread that invokes the constructor
        is the only thread that can access the newly created object
        during the life of the invoked constructor, we can also be
        assured there will be no race conditions involving the
        object's fields during construction. We use a pair of
        annotations on the constructor to declare this intent:</para>

        <programlisting>
 <emphasis>@SingleThreaded</emphasis>
 <emphasis>@Borrowed("this")</emphasis>
 public BoundedFIFO(int size) {
   &hellip;
 }
        </programlisting>
      
        <para>The first declares that no new threads are starting
        during the execution of the constructor.  The second that no
        aliases to the newly constructed object will be created during
        the execution of the constructor.  The assurance of the
        <varname>@SingleThreaded</varname> annotation actually depends
        in part on the assurance of the <varname>@Borrowed</varname>
        annotation.</para>

        <para>Save and reanalyze. The model now assures:</para>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO4-1.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-1.png"/>
          </imageobject>
        </mediaobject>
      
        <sect3 id="deep-analysis">
          <title>Deep Analysis</title>
        
          <para>As stated above, the assurance of
          <varname>@SingleThreaded</varname> depends on the assurance
          of <varname>@Borrowed("this")</varname> on the
          constructor. We can see this by</para>
        
          <itemizedlist>
            <listitem><para>Removing the <varname>@Borrowed</varname>
            annotation.</para></listitem>
            <listitem><para>Changing the code to be inconsistent with the
            annotation.</para></listitem>
          </itemizedlist>

          <para>If we remove the <varname>@Borrowed</varname>
          annotation, the assurance now fails:</para>
        
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/BoundedFIFO4-2.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-2.png"/>
            </imageobject>
          </mediaobject>

          <para>Here we see that the 27 protected field accesses
          heading has a red X because assurance of some of the
          accesses depends on the constructor being single-threaded,
          and the <varname>@SingleThreaded</varname> annotation is not
          assured.</para>

          <para>We can reinstate the <varname>@Borrowed</varname>
          annotation and instead make the code inconsistent by
          changing the constructor to alias the receiver:</para>
       
          <programlisting>
@RegionLock("BufLock is this protects Instance")
@Promise("'@RequiresLock BufLock' for *(**)")
public class BoundedFIFO {
  &hellip;
  <emphasis>static BoundedFIFO foo;</emphasis>

  @SingleThreaded
  @Borrowed("this")
  public BoundedFIFO(int size) {
    if (size &lt; 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
    
    <emphasis>foo = this;</emphasis>
  }
  &hellip;
}
          </programlisting>
        
          <para>Again, we see that assurance fails:</para>

          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/BoundedFIFO4-3.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-3.png"/>
            </imageobject>
          </mediaobject>
        
          <para>In this case, we can see that the assurance of
          <varname>@SingleThreaded</varname> fails because the
          <varname>@Borrowed</varname> annotation is violated by the
          code at line 59.</para>
        </sect3>
      
        <sect3 id="deeper-analysis">
          <title>Deeper Analysis</title>
        
          <para>The analysis used to assure
          <varname>@Borrowed</varname> is sophisticated, and it does
          allow temporary local aliases to the receiver.  If the
          constructor were instead</para>
        
          <programlisting>
@SingleThreaded
@Borrowed("this")
public BoundedFIFO(int size) {
  if (size &lt; 1)
    throw new IllegalArgumentException();
  this.size = size;
  buf = new LoggingEvent[size];
    
  <emphasis>BoundedFIFO local = this;</emphasis>
}
          </programlisting>
        
          <para>then the class would still assure because</para>
        
          <itemizedlist>
            <listitem><para>The alias to <varname>this</varname> in
            <varname>local</varname> is never itself aliased to a global
            location.</para></listitem>
            <listitem><para>The alias disappears when the constructor finishes
            executing.</para></listitem>
          </itemizedlist>
        
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/BoundedFIFO4-4.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-4.png"/>
            </imageobject>
          </mediaobject>
        </sect3>
      </sect2>
    
      <sect2 id="aggregated-state">
        <title>Aggregated State</title>
      
        <para>We now have no red X's, but we still have 2 warnings
        about references to possibly shared objects:</para>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO5.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO5.png"/>
          </imageobject>
        </mediaobject>

        <para>These 2 warnings refer to access to the contents of the
        array referenced by the field <varname>buf</varname>. This
        array is an object separate from the
        <varname>BoundedFIFO</varname> object and is not protected by
        the lock protecting the fields of the
        <varname>BoundedFIFO</varname> object. We can extend
        protection to the contents of the array by declaring the array
        reference to be <varname>@Unique</varname>&mdash;no object but
        the <varname>BoundedFIFO</varname> object can hold a reference
        to it&mdash;and then by declaring that the state of the array
        is part of the state of the <varname>BoundedFIFO</varname>
        object:</para>
      
        <programlisting>
       @RegionLock("BufLock is this protects Instance")
 @Promise("'@RequiresLock BufLock' for *(**)")
 public class BoundedFIFO {
   <emphasis>@Unique</emphasis>
   <emphasis>@Aggregate("Instance into Instance")</emphasis>
   LoggingEvent[] buf;
   &hellip;
 }
        </programlisting>
      
        <para>Now, as part of the state of the
        <varname>BoundedFIFO</varname> object, the array object
        referenced by <varname>buf</varname> is also protected by the
        lock that protects that state of the buffer.</para>

        <para>Aftering saving (and reanalyzing) we can see the effects
        of this annotation: there are now "29 protected field
        accesses", up from 27. This is because the two array
        dereferences are now counted as protected accesses (lines 71
        and 89):</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO5b.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO5b.png"/>
          </imageobject>
        </mediaobject>      
      </sect2>
    
      <sect2 id="assured">
        <title>Assurance Acheived</title>
      
        <para>The project is now fully assured:</para>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO6.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO6.png"/>
          </imageobject>
        </mediaobject>      
      </sect2>
    </sect1>
  </chapter>

  <chapter id="understanding-assurance-output">
    <title>Understanding JSure Assurance Output</title>
    
    <para>This chapter descibes using examples the wide variety of
    messages that appear in the JSure assurance output.</para>
    
    <sect1 id="effects-assurance">
      <title>Effects Assurance</title>
      
      <para>This discussion of effects assurance results is based
      on assuring the class <varname>EffectsExample</varname>. This class does absolutely
      nothing useful except to demonstrate the various effects assurance
      results.</para>
      
      <figure id="EffectsExample.java">
        <title>The class <varname>EffectsExample</varname>.</title>
      
        <programlisting>
/**
 * This is a simple class that exists only to show off the 
 * assurance results the Effects Assurance can produce.
 */
public class EffectsExample {
  private int f1;
  private int f2;
  private int f3;

  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }

  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }

  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }

  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }

  /**
   * Indirectly bad!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad();
  }

  /**
   * Missing effects!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad() {
    return getSum() + doesAnything();
  }
}
        </programlisting>
      </figure>
      
      <para>The results of effects assurance are displayed under the
      top-level heading <guilabel>Effects</guilabel> in the
      <guilabel>Verification Status</guilabel> view.  Under this heading
      is a subheading for each method and constructor that is annotated
      with <varname>@RegionEffects</varname>. Each entry is marked with
      either a green plus <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> or a red X
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>
      indicating whether the effects annotation has been positively or
      negatively assured, respectively.</para>
      
      <para>In our example, the the methods <varname>bad()</varname> and
      <varname>indirectlyBad()</varname> fail to assure, while the
      methods <varname>getSum()</varname>, <varname>update()</varname>,
      <varname>doesAnything()</varname>, and the constructor
      <varname>EffectsExample()</varname> assure.</para>
      
      <mediaobject>
        <imageobject role="html">
          <imagedata fileref="images/effects-assurance-01.png"/>
        </imageobject>
        <imageobject role="fo">
          <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-01.png"/>
        </imageobject>
      </mediaobject>
      
      <para>There are four kinds of results that can appear as 
      evidence for and children of the promise drops:</para>
      
      <variablelist>
        <varlistentry>
          <term><replaceable>effect</replaceable> not accounted for by
          declared effect(s)</term>
          <listitem><para>The given effect of the method/constructor
          implementation is not accounted for by any of the declared
          effects of the method/constructor. That is, the
          method/constructor implementation affects more state than it
          declares it does.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Empty effects trivially satisfy declared effects</term>
          <listitem><para>The method/constructor has no effects at all
          and thus trivially satisfies its declared effects.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><replaceable>effect<subscript>1</subscript></replaceable> checked by
          <replaceable>effect<subscript>2</subscript></replaceable></term>
          <listitem><para>The particular effect of the
          method/constructor implemenation, <replaceable>effect<subscript>1</subscript></replaceable>, is accounted for by
          the particular declared effect <replaceable>effect<subscript>2</subscript></replaceable>. Often, the
          implementation effect is more specific than the declared
          effect, i.e., it affects a region that is included in the
          region of the declared effect.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><replaceable>effect</replaceable> checked by constructor rule: writes to a newly
          created object are invisible</term>
          <listitem><para>The particular effect of the constructor
          implemenation is accounted for by a special rule. Constructors
          do not need to report any effects they have on the object
          being constructed because these effects are invisible to the
          caller of the constructor (the object doesn't exist before the
          constructor was called).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The meanings of these results are further elaborated in
      the discussion below.</para>

      <sect2 id="simple-positive-assurances">
        <title>Simple Positive Assurances</title>
        
        <para>Let us examine the assurance results for <varname>doesAnything</varname>,
        <varname>getSum()</varname>, and <varname>EffectsExample()</varname> in more detail.
        Their chains of evidence expand as follows</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/effects-assurance-02.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-02.png"/>
          </imageobject>
        </mediaobject>
        
        <sect3 id="doesAnything">
          <title>Method <varname>doesAnything()</varname></title>
          
          <para>This method declares that it could read or write anything
          (<varname>@RegionEffects("writes java.lang.Object:All")</varname>),
          but in fact its implementation has no effects at all:</para>
          
          <programlisting>
  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }
          </programlisting>
          
          <para>Thus, the method assures and the result <computeroutput>"Empty effects
          trivially satisfy declared effects"</computeroutput> appears as evidence for
          the assurance of the declared effects.</para>
        </sect3>

        <sect3 id="getSum">
          <title>Method <varname>getSum()</varname></title>
          
          <para>Method getSum has the following implementation:</para>
          
          <programlisting>
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }
          </programlisting>

          <para>This method declares that could read any of the instance
          fields of the reciever (<varname>"reads instance"</varname>,
          really a shorthand for <varname>"reads
          this:Instance"</varname>). The body of the method reads the
          three fields <varname>f1</varname>, <varname>f2</varname>, and
          <varname>f3</varname>. Thus, there are three effects that need
          to be accounted for in order for the declared effects to be
          assured. We see this in the three result drops that appear as
          evidence for the method's declared effects:</para>
          
          <itemizedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f2" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f3" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
          </itemizedlist>

          <para>In particular, there is one result for each
          implementation effect of the method, and the result is
          tagged to the line of code that corresponds to the expression
          that creates the effect.  In this case, all the effects eminate
          from line 30.</para>
        </sect3>
        
        <sect3 id="EffectsExample">
          <title>Constructor <varname>EffectsExample</varname></title>

          <para>The constructor declares that has no effects
          (<varname>@RegionEffects("none")</varname>) and has the
          following implementation:</para>
          
          <programlisting>
  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }
          </programlisting>
          
          <para>This case is similar to <varname>getSum()</varname>
          except that the evidence for the assurance is that the special
          constructor rule applies:</para>

          <itemizedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 23</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 24</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 25</computeroutput></para>
            </listitem>
          </itemizedlist>
        </sect3>
      </sect2>
      
      <sect2 id="complex-positive-assurance">
        <title>Complex Positive Assurance</title>
        
        <para>The assurance results for method <varname>update()</varname> are
        more complicated. This method calls another method, <varname>getSum()</varname>;
        thus some the effects of this method are due to the method that it calls:</para>
        
        <programlisting>
  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }
        </programlisting>
        
        <para>This dependency is reflected in the assurance results:</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/effects-assurance-03.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-03.png"/>
          </imageobject>
        </mediaobject>
        
        <para>In particular, we see that the effect "reads
        &lt;this&gt;:Instance" is due to the declared effects of method
        <varname>getSum()</varname>.  Because of this, the results
        become a graph: the results go on to show that the declared
        effects of <varname>getSum()</varname> are assured. These are exactly the same
        results as described above. The point here is that we can see
        the complete line of assurance; in particular, the effect within
        <varname>update()</varname> is accounted for and the source of that effect has been
        assured as well. This is why the icon for the result-drop (line
        35) is a double-plus <guiicon><inlinegraphic
      fileref="images/plus-plus.jpg"/></guiicon>: the large plus indicates effect is
        assured in the context of the method <varname>update()</varname>, while the small
        plus indicates that the <emphasis>source</emphasis> of that effect has also been
        assured.</para>
      </sect2>
      
      <sect2 id="effects-failures">
        <title>Assurance Failures</title>
        
        <para>Now we examine the assurance results of the negatively assured methods
        <varname>bad()</varname> and <varname>indirectlyBad()</varname>.</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/effects-assurance-04.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-04.png"/>
          </imageobject>
        </mediaobject>
        
        <sect3 id="method-bad">
          <title>Method <varname>bad()</varname></title>
          
          <para>Method <varname>bad()</varname> is incorrect because it
          invokes the method <varname>doesAnything()</varname> but only
          declares that it could read the state of the receiver
          (<varname>"reads Instance"</varname>).</para>

          <programlisting>
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad() {
    return getSum() + doesAnything();
  }
          </programlisting>

          <para>In particular, there are two results:</para>

          <orderedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:Instance" checked by
              "reads &lt;this&gt;:Instance" at EffectsExample.java line
              54</computeroutput> indicates that the effects of invoking
              <varname>getSum()</varname> on line 54 are accounted for by the declared
              effects.</para>
            </listitem>
            <listitem>
              <para><computeroutput>"writes java.lang.Object:All" not
              accounted for by declared effect(s) at EffectsExample.java
              line 54</computeroutput> indicates that the effects of
              invoking <varname>doesAnything()</varname> on line 54 are
              not accounted for.</para>
            </listitem>
          </orderedlist>
        </sect3>
        
        <sect3 id="method-indirectly-bad">
          <title>Method <varname>indirectlyBad()</varname></title>
          
          <para>This method is interesting because its declared effects
          do account for all the effects of its implementation, in the
          sense that the declared effects of called methods are considered
          to be part of the effects of this method. But the method still
          fails to assure because the declared effects of the called
          method&mdash;in this case <varname>bad()</varname>&mdash;cannot be assured.</para>

          <programlisting>
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad();
  }
          </programlisting>

          <para>The method has a single result <computeroutput>"reads
          &lt;this&gt;:Instance" checked by "reads
          &lt;this&gt;:Instance" at EffectsExample.java line
          46</computeroutput>. What is interesting, however, is that
          this drop is marked with a plus subscripted with a red X <guiicon><inlinegraphic
      fileref="images/plus-x.jpg"/></guiicon>.  This means that the effects assure, but that
          the basis for the implementation effects, namely the effects declaration of
          the method <varname>bad</varname>, fails to assure.</para>
        </sect3>
      </sect2>
    </sect1>
    
    <sect1 id="lock-assurance">
      <title>Lock Assurance</title>
      
      <para>Each <varname>@RegionLock</varname> annotion results in a
      new chain of evidence under <guilabel>Concurrency</guilabel>
      heading in the <guilabel>Verification Status</guilabel> view. Each
      of these chains is marked to indicate whether the model associated
      with it is assured or not, via <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>,
      respectively, and contains additional levels of detail describing
      the particulars of the assurance. This detail includes both
      assurance about the protected state, marked with
      <guiicon><inlinegraphic
      fileref="images/folder-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/folder-x.jpg"/></guiicon>,
      as well as with chains of evidence for other annotations used to
      support the lock model (e.g., <varname>@ReturnsLock</varname> and
      <varname>@SingleThreaded</varname>), again marked with
      <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>. 
      See, for example, <xref linkend="lock-assurance-figure"/>.</para>
      
      <figure id="lock-assurance-figure">
        <title>Example Chains of Evidence for Lock Assurance</title>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/lock-assurance-01.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-01.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <sect2 id="assuring-region-lock">
        <title>Assuring <varname>@RegionLock</varname></title>
        
        <para>The example class <varname>SimpleLockExample</varname>
        demonstrates the basics of lock assurance:</para>

        <programlisting>
<emphasis>@RegionLock("L1 is this protects Instance")</emphasis>
public class SimpleLockExample {
  private int f;
  private int g;
  
  public synchronized int getF() {
    // Good
    return f;
  }
  
  public void setF(final int v) {
    synchronized (this) {
      // Good
      f = v;
    }
  }
  
  <emphasis>@RequiresLock("L1")</emphasis>
  public void doStuff() {
    // Good
    f = 0;
  }
  
  public int getG() {
    // Bad
    return g;
  }
}
        </programlisting>

        <para>The receiver (<varname>this</varname>) is used as a lock
        to protect the <varname>Instance</varname> region of the object.
        The field <varname>f</varname> is always accessed correctly,
        while the field <varname>g</varname> is accessed
        incorrectly.</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/lock-assurance-02.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-02.png"/>
          </imageobject>
        </mediaobject>
        
        <para>The correct and incorrect field accesses are grouped under
        distinct subheadings, described below.  The heading <guilabel>lock
        precondition(s)</guilabel> is described below in <xref
        linkend="assuring-requires-lock"/>.</para>
        
        <sect3 id="protected-field-accesses">
          <title>protected field access(es)</title>
          
          <para>This heading groups together all the accesses to fields in the
          protected region that JSure can assure occur when the correct
          lock is held. For our example, this would be the fields in the
          region <varname>Instance</varname> and the lock referenced by
          <varname>this</varname>.  The individual assurance results
          under this subheading are of the form <computeroutput>Lock
          "<replaceable>lock</replaceable>" held when accessing
          <replaceable>field</replaceable></computeroutput>. In our
          example, there are three of these, one for each access to
          field <varname>f</varname> on lines 13, 19, and 26.</para>
          
          <para>Each assurance result is backed up by
          <guilabel>supporting information</guilabel> that shows the
          locks that can be assured to be held when the field is
          accessed: <computeroutput>Intrinsic lock
          "<replaceable>lock</replaceable>" is held</computeroutput>.
          This result links to the source line of code of the expression
          that acquires the lock. In our example, for the access on line
          11, the supporting information links to the declaration of the
          surrounding <varname>synchronized</varname> method
          <varname>getF()</varname> on line 11. For the access on line
          19, the supporting information links to the surrounding
          <varname>synchronized</varname> block on line 17.  Finally,
          for the access on line 26, the supporting information links to
          the the <varname>@RequiresLock</varname> annotation of the
          surrounding method <varname>doStuff()</varname>on line 23. In
          a more complete example, one in which we have calls to the
          method <varname>doStuff()</varname>, the use of
          <varname>@RequiresLock</varname> would be assured based on the
          correctness of its callsites. If there were unassured
          callsites, then this field access would be marked with a
          <guiicon><inlinegraphic
          fileref="images/plus-x.jpg"/></guiicon> to indicate that
          assurance of one its preconditions failed.</para>
        </sect3>
        
        <sect3 id="unprotected-field-accesses">
          <title>unprotected field access(es); possible race condition detected</title>
          
          <para>This heading groups together all the accesses to fields in the
          protected region that JSure cannot assure always occur when the lock is held.
          The individual assurance results under this subheading are of the 
          form <computeroutput>Lock "<replaceable>lock</replaceable>" not held when
          accessing <replaceable>field</replaceable></computeroutput>.  In our example,
          there is one of these results for the access to the field <varname>g</varname> 
          at line 31.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-requires-lock">
        <title>Assuring Method Preconditions: <varname>@RequiresLock</varname></title>
        
        <para>The result heading for each <varname>@RegionLock</varname>
        annotation collects all the <varname>@RequiresLock</varname> annotations that name
        its lock under the heading <guilabel>lock preconditions</guilabel>; see <xref linkend="RequiresLockExample-results"/>.
        Each <varname>@RequiresLock</varname> annotation is assured by checking
        each call site of the annotated method to see if the correct
        lock is held. As with field access, the good and bad call sites
        are grouped together; again, see <xref linkend="RequiresLockExample-results"/>.</para>
        
        <figure id="RequiresLockExample-results">
          <title>Chains of Evidence for <varname>RequiresLockExample</varname></title>.
          
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-03.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-03.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        
        <para>This section uses class
        <varname>RequiresLockExample</varname> to describe how
        <varname>@RequiresLock</varname> annotations are assured:</para>
        
        <programlisting>
<emphasis>@RegionLock("RL is this protects Instance")</emphasis>
public class RequiresLockExample {
  private int f;
  
  <emphasis>@RequiresLock("RL")</emphasis>
  public int get() { return f; }
  
  <emphasis>@RequiresLock("RL")</emphasis>
  public void set(final int v) { f = v; }
  
  public synchronized void doStuff() {
    //good
    set(
        // good
        get() + 10);
  }
  
  public void doMoreStuff(final int v) {
    synchronized (this) {
      // good
      set(v + 100);
    }
  }
  
  public int bad() {
    // bad
    return get();
  }
}
        </programlisting>
        
        <sect3 id="preconditions-satisfied">
          <title>lock precondition(s) satisfied</title>

          <para>Each call site for which JSure can determine that the
          required lock is held results in an entry under this heading.
          The individual results read <computeroutput>Lock
          "<replaceable>lock</replaceable>" held when invoking
          <replaceable>method</replaceable></computeroutput>.  As with
          the field assurances, these results have supporting
          information indicating which statements acquire the locks. In
          our example, both uses of <varname>set()</varname>, on lines
          18 and 26, are correct, and one use of
          <varname>get()</varname>, on line 20, is correct. For
          <varname>set()</varname>, the supporting information refers to
          the <varname>synchronized</varname> method on line 16 and the
          <varname>synchronized</varname> block on line 24,
          respectively. For <varname>get()</varname>, the supporting
          information refers to the <varname>synchronized</varname>
          method on line 16.</para>
        </sect3>

        <sect3 id="preconditions-unsatisfied">
          <title>lock precondition(s) not satisfied; possible race
          conditions enabled</title>

          <para>Each call site for which JSure is unable to asure the
          required lock is always held is grouped under this subheading.
           The individual results read <computeroutput>Lock
          "<replaceable>lock</replaceable>" not held when invoking
          <replaceable>method</replaceable></computeroutput>.  The call
          to <varname>get()</varname> on line 32 is not assured in our
          example.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-singled-threaded">
        <title>Assuring Constructors: <varname>@SingleThreaded</varname></title>
        
        <para>The class <varname>ConstructorExample</varname> below
        demonstrates assurance issues with object constructors.
        Specifically, each <varname>@SingleThreaded</varname> annotation
        appears directly under the <guilabel>Concurrency</guilabel>
        top-level heading, and field initializers and their
        initialization expressions are assured once <emphasis>for
        each</emphasis> constructor in the class. This section discusses
        the single-threaded constructors; the next, <xref linkend="assuring-field-init"/> discusses field
        initialization issues.</para>
        
        <programlisting>
<emphasis>@RegionLock("L2 is this protects Instance")</emphasis>
public class ConstructorExample {
  private int f = 100;
  private int g = f + 10;
  private int h;
  
  private final Aux aux = new Aux();
  private final int bad = aux.doStuff();
  
  public ConstructorExample(final int a) {
    // bad
    h = a;
  }

  <emphasis>@SingleThreaded</emphasis>
  <emphasis>@Borrowed("this")</emphasis>
  // good constructor
  public ConstructorExample(final int a, final int b) {
    // good
    h = a;
    // good
    f += b;
  }
  
  <emphasis>@SingleThreaded</emphasis>
  // bad constructor
  public ConstructorExample() {
    h = 10;
  }
  
  <emphasis>@RegionLock("AuxLock is this protects Instance")</emphasis>
  static class Aux {
    private int x;
    
    <emphasis>@RequiresLock("AuxLock")</emphasis>
    public int doStuff() {
      return x; 
    }
  }
}
        </programlisting>
        
        <para>Class <varname>ConstructorExample</varname> has two
        constructors annotated with <varname>@SingleThreaded</varname>:
        <varname>ConstructorExample(int, int)</varname> at line 28, and
        <varname>ConstructorExample()</varname> at line 37. The
        annotation assures for the first, but not for the second:</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/lock-assurance-04.png"/>
          </imageobject>
          <imageobject role="fo">
            <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-04.png"/>
          </imageobject>
        </mediaobject>

        <sect3 id="singledThreaded-supported">
          <title>singleThreaded constructor supported</title>

          <para>This result indicates that JSure is able to assure that
          the constructor has exclusive access to the object being
          constructed. This assurance is acheived in one of two ways:</para>

          <orderedlist>
            <listitem>
              <para>The constructor has a borrowed receiver.  That is,
              the constructor is also annotated with
              <varname>@Borrowed("this")</varname>.</para>
            </listitem>
            <listitem>
              <para>The constructor does not start any threads and only writes to the newly created object under construction.
              Specifically, the constructor is annotated with <varname>@Starts("nothing")</varname> and its declared effects
              are contained in the effect <varname>"writes this:Instance"</varname>.</para>
            </listitem>
          </orderedlist>

          <para>JSure attempts to assure the annotation using both
          techniques, and the results of this are shown under the
          <guilabel>precondition choice(s)</guilabel> subheading. For constructor
          <varname>ConstructorExample(int, int)</varname> only the first case applies, an we see
          the <guilabel>by borrowed receiver</guilabel> subheading. Under that heading are the
          results elaborating the assurance that the receiver is unaliased. Any
          evidence about using the second option would appear under the
          subheading <guilabel>by effects</guilabel>.</para>
        </sect3>
       
        <sect3 id="singleThreaded-escaping">
          <title>singleThreaded constructor has possibly escaping receiver</title>
         
          <para>This result indicates that JSure is unable to assure that
          the object being constructed is accessed by the thread that is
          constructing it only. That is, the receiver may escape the
          constructing thread and not be accessed by a single thread. In
          our example, the constructor ConstructorExample() fails to assure
          because we do not provide any design intent that can be used to
          back up the claims of single-threadedness.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-field-init">
        <title>Assuring Constructors: Field Initialization</title>
        
        <para>Assurance of constructors is also complicated by field
        initializers. Non-static fields with initializers need to be
        assured separately for each constructor in the class because the
        single-threadedness (or not) of the constructor can affect their
        assurance.</para>

        <para>In the case of the example class
        <varname>ConstructorExample</varname> above, the fields
        <varname>f</varname> and <varname>g</varname> have initializers
        and thus the use of the fields and their initialization
        expressions need to be incorporated into the assurance of the
        constructors. Because there are three constructors, these uses
        are analyzed three times.</para>

        <sect3 id="constructor-1">
          <title>Constructor <varname>ConstructorExample(int)</varname></title>
          
          <para>The first constructor is not annotated with
          <varname>@SingleThread</varname> and thus all the field accesses it makes
          are unprotected. The JSure results reflect this:</para>
          
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-05.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-05.png"/>
            </imageobject>
          </mediaobject>

          <para>The uses of field <varname>f</varname> on line 10, the
          fields <varname>f</varname> and <varname>g</varname> on line
          12, and the use of field <varname>h</varname> on line 22 are
          all marked as unprotected. The uses on lines 10 and 12 occur
          due to field declarations and thus are marked with
          <guilabel>supporting information</guilabel> indicating which
          constructor the access is considered to be a part of:
          <computeroutput>Analyzed on behalf of constructor
          "test.ConstructorExample.ConstructorExample(int)"</computeroutput>.</para>
        </sect3>
        
        <sect3 id="constructor-2">
          <title>Constructor <varname>ConstructorExample(int, int)</varname></title>
          
          <para>This constructor is declared to be <varname>@SingleThreaded</varname>, and JSure is 
          able to assure that its implementation is in fact so.  Thus all its field accesses
          are protected:</para>
          
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-06.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-06.png"/>
            </imageobject>
          </mediaobject>
          
          <para>Observe in particular that the uses of the field
          <varname>f</varname> on line 10, and the fields
          <varname>f</varname> and <varname>g</varname> on line 12 are
          assured, and the supporting information indicates that they
          are <computeroutput>Analyzed on behalf of constructor
          "test.ConstructorExample.ConstructorExample(int, int)"</computeroutput>.
          Also note that all the field access assuranced depend on the <varname>@SingleThreaded</varname>
          annotation on the constructor itself, which we previously observed is assured.</para>
        </sect3>
        
        <sect3 id="constructor-03">
          <title>Constructor <varname>ConstructorExample()</varname></title>
          
          <para>This constructor is annotated with
          <varname>@SingleThreaded</varname>, but JSure is not able to
          assure that this is the case.  Thus all its field accesses are
          found to be protected, but with unsatisfied preconditions and are
          marked with <guiicon><inlinegraphic
          fileref="images/plus-x.jpg"/></guiicon>:</para>
      
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-07.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-07.png"/>
            </imageobject>
          </mediaobject>
          
          <para>Again, observe that the uses of the field <varname>f</varname> on line 10,
          and the fields <varname>f</varname> and <varname>g</varname> on line 12 are assured.
          In this case, the supporting information marks that they are
          <computeroutput>Analyzed on behalf of constructor
          "test.ConstructorExample.ConstructorExample()"</computeroutput>.</para>
        </sect3>
        
        <sect3 id="aux.doStuff">
          <title>Assuring Calls to <varname>Aux.doStuff()</varname></title>
          
          <para>Finally, there is the case of the call to <varname>Aux.doStuff()</varname> in
          the initializer for field <varname>bad</varname>. This method has a lock
          precondition that must be satisfied each time the method is
          called. This is interesting in the context of assuring
          constructors because this method has three call sites: one for
          each constructor. Indeed, this is reflected in the assurance
          results:</para>
          
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-08.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-08.png"/>
            </imageobject>
          </mediaobject>
          
          <para>This call cannot be assured for any of the constructors
          because <emphasis>it is not possible for the necessary lock to be
          acquired in the field declaration</emphasis>. This can be remedied by
          initializing <varname>bad</varname> in each constructor, or by moving the
          initialization to a single instance initializer block:</para>

          <programlisting>
@RegionLock("L2 is this protects Instance")
public class ConstructorExample {
  &hellip;
  private final Aux aux = new Aux();
  private final int bad;
  
  {
    synchronized (aux) {
      bad = aux.doStuff();
    }
  }
  &hellip;
}
          </programlisting>
          
          <para>This changes the assurance results for
          <varname>AuxLock</varname> to be</para>
          
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-09.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-09.png"/>
            </imageobject>
          </mediaobject>
          
          <para>Again, observe how the initializer block is analyzed
          once for each constructor.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-returns-lock">
        <title>Assuring <varname>@ReturnsLock</varname></title>
        
        <para>Each <varname>@ReturnsLock("<replaceable>lock</replaceable>")</varname>
        annotation creatse a result subheading under the heading for the named 
        lock <replaceable>lock</replaceable>.  The
        implementation of the annotated method&mdash;actually each <varname>return</varname>
        expression in the method&mdash;is checked to assure that it actually
        returns the named lock.</para>

        <para>The class <varname>ReturnsLockExample</varname>, below,
        demonstrates the two kinds of results (see <xref
        linkend="returns-lock-results"/>):</para>

        <programlisting>
<emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class ReturnsLockExample {
  protected int v;
  
  <emphasis>@ReturnsLock("L")</emphasis>
  private Object goodGetLock() {
    return this;
  }
  
  <emphasis>@ReturnsLock("L")</emphasis>
  private Object badGetLock() {
    return new Object();
  }
  
  public void doStuff() {
    synchronized (goodGetLock()) {
      v = 1; 
    }
    synchronized (badGetLock()) {
      v = 2;
    }
  }
}
        </programlisting>
        
        <figure id="returns-lock-results">
          <title>Assurance results for <varname>ReturnsLockExample</varname>.</title>
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-10.png"/>
            </imageobject>
            <imageobject role="fo">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-10.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <sect3 id="good-return">
          <title>return statement(s) returning the correct lock</title>
          
          <para>All the positive assurance results for a single
          <varname>@ReturnsLock</varname> annotation are grouped under
          this subheading.  Each result is of the form
          <computeroutput>Return statement correctly returns lock
          "<replaceable>lock</replaceable>"</computeroutput>.</para>

          <para>In our example, method <varname>goodGetLock()</varname>
          always returns <varname>this</varname>, and thus is assured to
          be correct.</para>
        </sect3>
        
        <sect3 id="returns-lock-bad">
          <title>return statement(s) possibly returning the wrong lock</title>

          <para>All the negative assurance results for a single
          <varname>@ReturnsLock</varname> annotation are grouped under
          this subheading.  Each result is of the form
          <computeroutput>Return statement expected to returned lock
          "<replaceable>lock</replaceable>"</computeroutput>.</para>

          <para>In our example, method <varname>badGetLock()</varname>
          cannot be assured to always return the correct lock (the
          object referenced by <varname>this</varname>)&mdash;in fact,
          it never does&mdash;so it is marked as unassured.</para>
        </sect3>
      </sect2>
      
      <sect2 id="lock-warnings">
        <title>Suggestions and Warnings</title>
        
        <para>Lock assurance can also yield several classes of reults under the
        top-level <guilabel>Suggestions and Warnings</guilabel> heading.</para>
        
        <sect3 id="redudant-locks">
          <title>redundant lock acquisition(s)</title>
          
          <para>This subheading groups together warnings about lock
          acquisitions that may be redundant, that is, that acquire a
          lock that <emphasis>must</emphasis> already be held. The
          speficic warnings under this heading read
          <computeroutput>Acquisition of lock
          "<replaceable>lock</replaceable>" may be
          redundant</computeroutput>.  Each results links to the expression or annotation
          that is a potentially redundant lock acquisition.
          Class <varname>RedundantLockExample</varname> demonstrates these results, 
          shown in <xref linkend="redundant-lock-results"/>:</para>
          
          <programlisting>
<emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class RedundantLockExample {
  private int f;
  
  // not redundant
  public synchronized void m() {
    f = 1;
    // redundant
    synchronized (this) {
      f = 2;
    }
  }
  
  public void n() {
    // not redundant
    synchronized (this) {
      f = 3;
      
      // redundant
      synchronized (this) {
        f = 4;
      }
    }
  }
  
  // Not redundant 
  <emphasis>@RequiresLock("L")</emphasis>
  public void o() {
    f = 5;
    
    // redundant for L, but not for MUTEX
    synchronized (this) {
      f = 6;
    }
  }
}
          </programlisting>
          
          <figure id="redundant-lock-results">
            <title>Assurance results for <varname>RedundantLockExample</varname>.</title>
            <mediaobject>
              <imageobject role="html">
                <imagedata fileref="images/lock-assurance-11.png"/>
              </imageobject>
              <imageobject role="fo">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-11.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
          <para>The lock acquisitions on lines 15 and 26 are seen as
          redundant acquisitions of two locks, <varname>MUTEX</varname>
          and <varname>L</varname>, because the expression
          <varname>this</varname> could refer to either one of those
          locks. The acquision on line 38 is only redundant for lock
          <varname>L</varname> because the
          <varname>@RequiresLock</varname> precondition on the method
          only requires that specific lock.  Thus, although, the
          expression on line 38 acquires both locks, the acquisition of
          <varname>MUTEX</varname> is not redundant.</para>

          <para>JSure warns about redundant lock acquisitions because
          they make it more difficult to understand the program's design
          intent. Ideally, redudant lock acquisitions should be removed
          from the program.  We are careful to say that these
          acquisitions <emphasis>may be</emphasis> redundant because a
          program's design intent can be more complicated than is
          expressable using JSure's annotations, and thus the lock
          acquision may satisfy an intent that has not been
          expressed.</para>
        </sect3>
        
        <sect3 id="inidentifiable-locks">
          <title>unidentifiable lock(s); what is the name of the lock? what state is being protected?</title>
          
          <para>This class of warnings identifies those lock
          acquisitions where JSure is unable to determine that a named
          lock is being acquired. That is, there is no lock declared
          with a <varname>@RegionLock</varname> or
          <varname>@PolicyLock</varname> annotation that can be
          determined to be acquired at the identified locations. There are
          three messages that can appear under this heading:</para>
          
          <variablelist>
            <varlistentry>
              <term>Synchronized block: Lock expression
              "<replaceable>expr</replaceable>" is not identifiable as a
              programmer-declared lock</term>
              
              <listitem><para>The given expression in the identified
              <varname>synchronized</varname> statement is not
              identifiable as a lock declared in a
              <varname>@RegionLock</varname> or
              <varname>@PolicyLock</varname> annotation.
              </para></listitem>
            </varlistentry>

            <varlistentry>
              <term>Synchronized method <replaceable>method</replaceable>: "this" is not
              identifiable as a programmer-declared lock</term>
              
              <listitem><para>This identifies a
              non-<varname>static</varname>
              <varname>synchronized</varname> method for which the
              receiver (<varname>this</varname>) is not identifiable as
              a lock.</para></listitem>
            </varlistentry>

            <varlistentry>
              <term>Synchronized method
              <replaceable>method</replaceable>:
              "<replaceable>Class</replaceable>.class" is not
              identifiable as a programmer-declared lock</term>

              <listitem><para>This identifies a
              <varname>static</varname>
              <varname>synchronized</varname> method for which the
              class reference is not identifiable as
              a lock.</para></listitem>
            </varlistentry>
          </variablelist>
          
          <para>Class <varname>UnidentifiableLockExample</varname> demonstrates these
          results, shown in <xref linkend="unidentifiable-lock-results"/>:</para>
          
          <programlisting>
public class UnidentifiableLockExample {
  private final Object lock = new Object();
  
  private static int s;
  
  private int x;
  private int y;
  
  static {
    // Unidentifiable lock expression
    synchronized (UnidentifiableLockExample.class) {
      s = 100;
    }
  }
  
  // Unidentifiable lock expression
  public static synchronized int getS() {
    return UnidentifiableLockExample.s;
  }
  
  // Unidentifiable lock expression
  public synchronized int getX() {
    return x;
  }
  
  public void setX(final int v) {
    // Unidentifiable lock expression
    synchronized (this) {
      x = v;
    }
  }
  
  public int getY() {
    // Unidentifiable lock expression
    synchronized (lock) {
      return y;
    }
  }
  
  public void setY(final int v) {
    // Unidentifiable lock expression
    synchronized (lock) {
      y = v;
    }
  }
}
          </programlisting>
          
          <figure id="unidentifiable-lock-results">
            <title>Assurance results for <varname>UnidentifiableLockExample</varname>.</title>
            <mediaobject>
              <imageobject role="html">
                <imagedata fileref="images/lock-assurance-12.png"/>
              </imageobject>
              <imageobject role="fo">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-12.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
          <para>This class does not have any lock annotations, but
          there are numerous lock acquisitions contained within it.  All
          the points where a lock might be acquired have have a warning
          about the undentifiable nature of the lock.</para>
          
          <para>JSure warns about this situation as way to identify
          potentially missing lock models. For example, the warnings in
          the example can be removed by adding the following annotation to the 
          class:</para>
          
          <programlisting>
@RegionLocks({
  @RegionLock("xLock is this protects x"),
  @RegionLock("yLock is lock protects y"),
  @RegionLock("sLock is class protects s")})
          </programlisting>

        </sect3>
        
        <sect3 id="non-final-locks">
          <title>non-final lock expression(s); analysis cannot determine
          which lock is being acquired</title>

          <para>JSure groups together all warnings about non-final
          expressions in <varname>synchronized</varname> statements under this heading.
          Each warning has the form <computeroutput>Lock expression "<replaceable>lock</replaceable>" is not final</computeroutput>.
          A <emphasis>final expression</emphasis> is a reference-valued expression that JSure
          can determine refers to the same object no matter where it is
          evaluated within the context of the <varname>synchronized</varname> statement.
          JSure requires that the lock expression in a <varname>synchronized</varname>
          statement be final to guarantee that the lock that is acquired
          is the same lock that is needed inside of the statement. The
          <varname>test</varname> method of the class
          <varname>NonFinalLockExample</varname> contains two examples
          of non-final lock expressions, see <xref linkend="non-final-lock-results"/>:</para>
          
          <programlisting>
<emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class NonFinalLockExample {
  private int val;
  
  <emphasis>@RequiresLock("L")</emphasis>
  public int get() {
    return val;
  }

  <emphasis>@RequiresLock("L")</emphasis>
  public void set(final int v) {
    val = v;
  }
  
  public static NonFinalLockExample getNF() {
    return new NonFinalLockExample();
  }
  
  public static void test() {
    NonFinalLockExample nf = new NonFinalLockExample();
    
    // Non-final lock acquisition
    synchronized (nf) {
      int x = nf.get();
      nf = new NonFinalLockExample();
      nf.set(x+1);
    }
    
    // Non-final lock acquisition
    synchronized (getNF()) {
      getNF().set(getNF().get()+1);
    }
  }
}
          </programlisting>

          <figure id="non-final-lock-results">
            <title>Assurance results for <varname>NonFinalLockExample</varname>.</title>
            <mediaobject>
              <imageobject role="html">
                <imagedata fileref="images/lock-assurance-13.png"/>
              </imageobject>
              <imageobject role="fo">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-13.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
          <para>The expression <varname>nf</varname> on line 28 is
          considered non-final because the variable
          <varname>nf</varname> is assigned to inside of the
          <varname>synchronized</varname> statement. This means that the
          object locked by the <varname>synchronized</varname> statement
          is not the object that needs to be locked to call the method
          <varname>set</varname> in the expression
          <varname>nf.set(&hellip;)</varname> on the following line. The
          situation is worse on line 35: each call to <varname>getNF()</varname>
          returns a <emphasis>new</emphasis> object.</para>

          <note>
            <para>This example demonstrates why pattern matching is
            insufficient: the above cases would check using a lexical
            scanner because all the object references are made using the
            same expression. But the <emphasis>value</emphasis> of that
            expression also needs to be considered to reach correct
            understanding of the program.</para>
          </note>
        </sect3>
        
        <sect3 id="not-protecting">
          <title>synchronized blocks not protecting any state; what state is being protected?</title>
          
          <para>JSure collects warnings about possibly superfluous
          locking under this heading.  Individual warnings read
          <computeroutput>Locks <replaceable>set of locks</replaceable>
          not needed by body of synchronized block</computeroutput>.
          This warning is an attempt to suggest areas where the lock
          model might be too narrow; that is a lock may protect more
          state than it has been declared to protect.  Class
          <varname>UnusedLockExample</varname>, whose results are shown
          in <xref linkend="not-protecting-results"/>, only declares
          that lock <varname>L</varname> protects region
          <varname>R</varname>:</para>

          <programlisting>
<emphasis>@Regions({</emphasis>
  <emphasis>@Region("R"),</emphasis>
  <emphasis>@Region("Q")})</emphasis>
<emphasis>@RegionLock("L is this protects R")</emphasis>
public class UnusedLockExample {
  <emphasis>@InRegion("R")</emphasis>
  private int f;
  
  <emphasis>@InRegion("Q")</emphasis>
  private int g;
  
  public synchronized int getF() {
    return f;
  }
  
  public synchronized int getG() {
    return g;
  }
  
  public void setBoth(final int a, final int b) {
    synchronized (this) {
      f = a;
      g = b;
    }
  }
}
          </programlisting>

          <figure id="not-protecting-results">
            <title>Assurance results for <varname>UnusedLockExample</varname>.</title>
            <mediaobject>
              <imageobject role="html">
                <imagedata fileref="images/lock-assurance-14.png"/>
              </imageobject>
              <imageobject role="fo">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-14.png"/>
              </imageobject>
            </mediaobject>
          </figure>

          <para>The JSure results call our attention to method
          <varname>getG()</varname> because it is
          <varname>synchronized</varname> but based on the current
          annotations its body does not require any locks.  In this
          case, it is clear that the intent is that <varname>this</varname> is to be used
          to protect both fields of the class, so we should modify the
          lock annotation to be <varname>@RegionLock("L is this protects Instance")</varname>.</para>

          <para>This situation often arrises when the class is being annotated
          incrementally: It is first discovered that a particular field
          is being protected by some lock, so the annotation is narrowly
          tailored to that case. Then, it can be discovered that the
          lock protects more state, and so on.</para>

        </sect3>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="reference">
    <title>Reference</title>
    <sect1>
      <title>The JSure menu</title>
      <para>The JSure menu appears as an item on the Eclipse workspace
      main menu.</para>
    </sect1>
    <sect1>
      <title>The Code Verification perspective</title>
      <para>The Code Verification perspective organizes the Eclipse
      workbench to show views which will help you to interact with
      tool findings.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Release notes</title>
    <para>For each release of JSure there are new and noteworthy
    features to try out, and known limitations to avoid or
    workaround. These are presented in the sections below for each
    released version of JSure.</para>
    <sect1>
      <title>JSure version 1.0</title>
      <para>This section describes the 1.0 release of JSure.</para>
      <sect2>
	<title>New and Noteworthy</title>
	<para>This section describes new and noteworthy features in this
	version of JSure.</para>
      </sect2>
      <sect2>
	<title>Known Problems</title>
	<para>This section describes known bugs and limitations in this
	version of JSure.</para>
      </sect2>
    </sect1>
  </chapter>
</book>
