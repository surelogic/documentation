<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book id="jsure-examples" lang="en-US">
  <title>JSure User Guide</title>
  <subtitle>How to use and configure the JSure Eclipse client</subtitle>
  <bookinfo>
    <copyright>
      <year>2008</year>
      <holder>SureLogic, Inc.</holder>
    </copyright>
    <legalnotice>
      <para>The authors and publishers have taken care in the
      preparation of this documentation, but make no expressed or
      implied warranty of any kind and assume no responsibility for
      errors and omissions. No liability is assumed for incidental or
      consequential damages in connection with or arising out of the use
      of the information or programs herein.</para>
    </legalnotice>
    <pubdate>Version 1.0&mdash;January 2009</pubdate>
  </bookinfo>

  <preface id="preface">
    <title>Preface</title>
    <sect1>
      <title>Audience</title>
      <para>This document is intended for Java developers who want to
      use the JSure tool within the Eclipse Java IDE. We assume
      that the reader understands both the Java programming language and
      the use of Eclipse for Java development.</para>
    </sect1>
    <sect1>
      <title>Contact information</title>
      <para>For technical support or other questions, please
      contact:</para>
      <para><email>support@surelogic.com</email></para>
      <para>5808 Forbes Avenue, Pittsburgh, PA 15217-1602</para>
    </sect1>
  </preface>

  <chapter id="getting-started">
    <title>Getting started</title>
    <sect1>
      <title>Introduction</title>

      <para><emphasis>What is JSure?</emphasis> TODO</para>
    </sect1>

    <sect1>
      <title>Quick start: How to scan your code and start adding design
      intent</title>

      <para>This section assumes that you have installed JSure. If you
      see a <guimenu>JSure</guimenu> menu item on your Eclipse main menu
      then you can assume JSure has been properly installed.</para>
    </sect1>

    <sect1>
      <title>Tutorial: Verifying BoundedFIFO</title>
    
      <para>This example walks through the complete assurance of a
      simple class and its usage. That is, it demonstrates that is not
      always enough to assure the implementation of a class:
      <emphasis>sometimes the clients of a class must conform to a
      specific behavior as well</emphasis>. This example focuses on
      two classes (plus one auxillary class):</para>
    
      <variablelist>
        <varlistentry>
          <term><classname>BoundedFIFO</classname></term>
          <listitem><para>The "thread safe" class.  See <xref
          linkend="BoundedFIFO.java"/></para></listitem>
        </varlistentry>
      
        <varlistentry>
          <term><classname>BlockingFIFO</classname></term>
          <listitem><para>The client code.  See <xref
          linkend="BlockingFIFO.java"/></para></listitem>
        </varlistentry>
      
        <varlistentry>
          <term><classname>LoggingEvent</classname></term>
          <listitem><para>The class of objects stored in the queue.  See
          <xref
          linkend="LoggingEvent.java"/></para></listitem>
        </varlistentry>
      </variablelist>
    
      <para>The class <classname>BoundedFIFO</classname> is taken from the
      <application>Apache Log4J</application> project. The class
      <classname>BlockingFIFO</classname> we wrote based on actual client code
      in <application>Log4J</application>.</para>

      <para>This example shows off basic features of assuring Java
      lock models using Java intrinsic lock objects:</para>
    
      <itemizedlist>
        <listitem><para><classname>@RegionLock</classname></para></listitem>
        <listitem><para><classname>@RequiresLock</classname></para></listitem>
        <listitem><para><classname>@SingleThreaded</classname></para></listitem>
        <listitem><para><classname>@Borrowed</classname></para></listitem>
        <listitem><para><classname>@Unique</classname></para></listitem>
        <listitem><para><classname>@Aggregate</classname></para></listitem>
        <listitem><para><classname>@Promise</classname></para></listitem>
      </itemizedlist>
    
      <figure id="BoundedFIFO.java">
        <title>Initial Source Code for class <classname>BoundedFIFO</classname></title>
      
        <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  LoggingEvent[] buf;
  
  int numElts = 0;
  int first = 0;
  int next = 0;
  int size;

  /**
   * Instantiate a new BoundedFIFO with a maximum size passed as argument.
   *
   * @param size Maximum size of the BoundedFIFO created.
   */
  public BoundedFIFO(int size) {
    if (size &lt; 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
  }

  /**
   * Get the first element in the buffer. Returns &lt;code&gt;null&lt;/code&gt; if
   * there are no elements in the buffer.
   */
  public LoggingEvent get() {
    if (numElts == 0)
      return null;
    LoggingEvent r = buf[next];
    if (++first == size)
      first = 0;
    numElts--;
    return r;
  }

  /**
   * Place a {@link LoggingEvent} in the buffer. If the buffer is full  then
   * the event is &lt;b&gt;silently dropped&lt;/b&gt;. It is the caller's  responsibility
   * to make sure that the buffer has free space.
   * 
   * @param o The logging event added into the buffer.
   */
  public void put(LoggingEvent o) {
    if (numElts != size) {
      buf[next] = o;
      if (++next == size)
        next = 0;
      numElts++;
    }
  }

  /** 
   * Get the maximum size of the buffer.
   */
  public int getMaxSize() {
    return size;
  }

  /**
   * Get the number of elements in the buffer. This number is guaranteed to be
   * in the range 0 to &lt;code&gt;maxSize&lt;/code&gt; (inclusive).
   */
  public int length() {
    return numElts;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if there is just one element in the buffer. In
   * other words, if there were no elements before the last {@link #put}
   * operation completed.
   */
  public boolean wasEmpty() {
    return numElts == 1;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the number of elements in the buffer plus 1
   * equals the maximum buffer size, returns &lt;code&gt;false&lt;/code&gt; otherwise.
   */
  public boolean wasFull() {
    return numElts + 1 == size;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the number of elements in the buffer equals
   * the maximum buffer size, returns &lt;code&gt;false&lt;/code&gt; otherwise.
   */
  public boolean isFull() {
    return numElts == size;
  }
}
        </programlisting>
      </figure>

      <figure id="BlockingFIFO.java">
        <title>Initial Source Code for class
        <filename>BlockingFIFO</filename></title>
      
        <programlisting>
          <![CDATA[
public class BlockingFIFO {
  private final BoundedFIFO fifo;;

  public BlockingFIFO(int size) {
    fifo = new BoundedFIFO(size);
  }

  public void put(LoggingEvent e) {
    synchronized (this) {
      while (fifo.isFull()) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      fifo.put(e);
      if (fifo.wasEmpty()) {
        fifo.notify();
      }
      fifo.put(e);
      fifo.put(e);
    }
  }

  public LoggingEvent get() {
    synchronized (fifo) {
      LoggingEvent e;
      while (fifo.length() == 0) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      e = fifo.get();
      if (fifo.wasFull()) {
        fifo.notify();
      }
      return e;
    }
  }

  public int length() {
    synchronized (fifo) {
      return fifo.length();
    }
  }
}
          ]]>
        </programlisting>
      </figure>

      <figure id="LoggingEvent.java">
        <title>Initial Source Code for class <classname>BlockingFIFO</classname></title>
      
        <programlisting>
          <![CDATA[
public class LoggingEvent { 
  /* Empty: The contents of this class are not interesting 
   * for our example.
   */
}
          ]]>
        </programlisting>
      </figure>
    
      <sect2 id="declaring-protected-state">
        <title>Declaring Protected State</title>
      
        <para>The <classname>BoundedFIFO</classname> class is a buffer
        meant to be shared between two threads. It obviously must be
        made thread-safe. The usual assumption is that an object
        protects its own state.  In <xref
        linkend="BoundedFIFO.java"/> the class is already
        annotated with this assumption:</para>
      
        <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  &hellip;
}
        </programlisting>

        <para>With this single annotation, analysis by JSure produces
        two main concurrency results, mostly indicating that the
        annotation is not assured, and a few warnings.  There are 27
        unprotected field accesses for <structfield>BufLock</structfield>, and
        no protected field accesses:</para>
      
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO1.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO1.png"/>
          </imageobject>
        </mediaobject>
      </sect2>

      <sect2 id="declaring-lock-preconditions">
        <title>Declaring Lock Preconditions</title>
    
        <para>Either this class is horribly broken or something else
        is going on.  By double clicking on any of the errors in the
        view, we can focus on the source line in
        <classname>BoundedFIFO</classname>. A quick inspectiion of the
        class reveals that it does not acquire the lock anywhere.  So
        we look at its clients by viewing the call chain, in this case
        by viewing the call hierarchy of method
        <function>get()</function> (Select the method
        <function>get()</function> in the "Outline" view and then choose
        <menuchoice><guimenuitem>Open Call
        Hierarchy</guimenuitem></menuchoice> in the context menu).  We
        see that the client, <classname>BlockingFIFO</classname> acquires
        the lock on the <classname>BoundedFIFO</classname> object before
        invoking any of the methods on the
        <classname>BoundedFIFO</classname> object, so we decide that the
        intent is that the caller should acquire the lock before
        calling any of the methods of
        <classname>BoundedFIFO</classname>.</para>

        <para>To add this intent to <classname>BoundedFIFO</classname>, we
        need to add the lock precondition
        <classname>@RequiresLock("BufLock")</classname> to all the methods
        of the class.  We can do this in a single annotation on the
        class itself by using a <emphasis>scoped promise</emphasis> to
        add the annotation to all the methods of the class:</para>
    
        <programlisting>
 @RegionLock("BufLock is this protects Instance")
 <emphasis>@Promise("'@RequiresLock BufLock' for *(**)")</emphasis>
 public class BoundedFIFO {
  &hellip;
 }
        </programlisting>  

        <para>After adding the annotation we save (and thus reanalyze
        the project).</para>
      </sect2>  
    
      <sect2 id="wrong-lock">
        <title>Wrong Lock</title>
      
        <para>There is now a "scoped promises" heading, and we can see
        all the places where our <classname>@Promise</classname>
        annotation added <classname>@RequiresLock</classname>
        annotations. Only 4 out of the 7 are currently
        satisfied:</para>
      
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO2.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO2.png"/>
          </imageobject>
        </mediaobject>
      
        <para>Looking at the chain of evidence for the call to
        <function>isFull()</function>, we see that the caller is
        confused and is synchronized on <parameter>this</parameter> (as
        evidenced by the caller holding the lock "this.MUTEX"):</para>
      
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO3.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO3.png"/>
          </imageobject>
        </mediaobject>

        <para>But in the context of the caller,
        <classname>BlockingFIFO</classname>, <parameter>this</parameter>
        refers to the <classname>BlockingFIFO</classname> object, not the
        <classname>BoundedFIFO</classname> object that is correctly
        refered to by <structfield>fifo</structfield>. The
        <code>synchronized</code> statement in method
        <function>isFull()</function> needs to be changed:</para>

        <programlisting>
 public void put(LoggingEvent e) {
   synchronized (<emphasis>fifo</emphasis>) {
     &hellip;
   }
 }
        </programlisting>
      </sect2>
    
      <sect2 id="single-threaded-constructor">
        <title>Single Threaded Constructor</title>

        <para>There are still five unprotected field accesses. These
        all point to either field initializers in field declarations
        or in the constructor: </para>
      
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO4.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4.png"/>
          </imageobject>
        </mediaobject>
      
        <para>Because the lock on the <classname>BoundedFIFO</classname>
        object is not held during construction, we need to make sure
        that during construction a reference to the object cannot be
        leaked to another thread. Note that we cannot require the
        caller of the constructor to hold the lock because the object
        doesn't exist yet!  In general, we cannot use
        <code>synchronized</code> blocks in the constructor to
        protect the state during construction because we cannot create
        a single atomic block: there would have to be multiple
        distinct <code>synchronized</code> blocks in the
        constructor and in the constructors of any subclasses. But if
        we can guarantee that the thread that invokes the constructor
        is the only thread that can access the newly created object
        during the life of the invoked constructor, we can also be
        assured there will be no race conditions involving the
        object's fields during construction. We use a pair of
        annotations on the constructor to declare this intent:</para>

        <programlisting>
 <emphasis>@SingleThreaded</emphasis>
 <emphasis>@Borrowed("this")</emphasis>
 public BoundedFIFO(int size) {
   &hellip;
 }
        </programlisting>
      
        <para>The first declares that no new threads are starting
        during the execution of the constructor.  The second that no
        aliases to the newly constructed object will be created during
        the execution of the constructor.  The assurance of the
        <classname>@SingleThreaded</classname> annotation actually depends
        in part on the assurance of the <classname>@Borrowed</classname>
        annotation.</para>

        <para>Save and reanalyze. The model now assures:</para>

        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO4-1.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-1.png"/>
          </imageobject>
        </mediaobject>
      
        <sect3 id="deep-analysis">
          <title>Deep Analysis</title>
        
          <para>As stated above, the assurance of
          <classname>@SingleThreaded</classname> depends on the assurance
          of <classname>@Borrowed("this")</classname> on the
          constructor. We can see this by</para>
        
          <itemizedlist>
            <listitem><para>Removing the <classname>@Borrowed</classname>
            annotation.</para></listitem>
            <listitem><para>Changing the code to be inconsistent with the
            annotation.</para></listitem>
          </itemizedlist>

          <para>If we remove the <classname>@Borrowed</classname>
          annotation, the assurance now fails:</para>
        
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/BoundedFIFO4-2.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-2.png"/>
            </imageobject>
          </mediaobject>

          <para>Here we see that the 27 protected field accesses
          heading has a red X because assurance of some of the
          accesses depends on the constructor being single threaded,
          and the <classname>@SingleThreaded</classname> annotation is not
          assured.</para>

          <para>We can reinstate the <classname>@Borrowed</classname>
          annotation and instead make the code inconsistent by
          changing the constructor to alias the receiver (in this case by storing
          a reference to it in a <code>static</code> field):</para>
       
          <programlisting>
@RegionLock("BufLock is this protects Instance")
@Promise("'@RequiresLock BufLock' for *(**)")
public class BoundedFIFO {
  &hellip;
  static BoundedFIFO foo;

  @SingleThreaded
  @Borrowed("this")
  public BoundedFIFO(int size) {
    if (size &lt; 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
    
    foo = this; <lineannotation>(Line 59)</lineannotation>
  }
  &hellip;
}
          </programlisting>
        
          <para>Again, we see that assurance fails:</para>

          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/BoundedFIFO4-3.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-3.png"/>
            </imageobject>
          </mediaobject>
        
          <para>In this case, we can see that the assurance of
          <classname>@SingleThreaded</classname> fails because the
          <classname>@Borrowed</classname> annotation is violated by the
          code at line 59.</para>
        </sect3>
      
        <sect3 id="deeper-analysis">
          <title>Deeper Analysis</title>
        
          <para>The analysis used to assure
          <classname>@Borrowed</classname> is sophisticated, and it does
          allow temporary local aliases to the receiver.  If the
          constructor were instead</para>
        
          <programlisting>
@SingleThreaded
@Borrowed("this")
public BoundedFIFO(int size) {
  if (size &lt; 1)
    throw new IllegalArgumentException();
  this.size = size;
  buf = new LoggingEvent[size];
    
  <emphasis>BoundedFIFO local = this;</emphasis>
}
          </programlisting>
        
          <para>then the class would still assure because</para>
        
          <itemizedlist>
            <listitem><para>The alias to <parameter>this</parameter> in
            <varname>local</varname> is never itself aliased to a global
            location.</para></listitem>
            <listitem><para>The alias disappears when the constructor finishes
            executing.</para></listitem>
          </itemizedlist>
        
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/BoundedFIFO4-4.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-4.png"/>
            </imageobject>
          </mediaobject>
        </sect3>
      </sect2>
    
      <sect2 id="aggregated-state">
        <title>Aggregated State</title>
      
        <para>We now have no red X's, but we still have 2 warnings
        about references to possibly shared objects:</para>

        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO5.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO5.png"/>
          </imageobject>
        </mediaobject>

        <para>These 2 warnings refer to access to the contents of the
        array referenced by the field <structfield>buf</structfield>. This
        array is an object separate from the
        <classname>BoundedFIFO</classname> object and is not protected by
        the lock protecting the fields of the
        <classname>BoundedFIFO</classname> object. We can extend
        protection to the contents of the array by declaring the array
        reference to be <classname>@Unique</classname>&mdash;no object but
        the <classname>BoundedFIFO</classname> object can hold a reference
        to it&mdash;and then by declaring that the state of the array
        is part of the state of the <classname>BoundedFIFO</classname>
        object:</para>
      
        <programlisting>
 @RegionLock("BufLock is this protects Instance")
 @Promise("'@RequiresLock BufLock' for *(**)")
 public class BoundedFIFO {
   <emphasis>@Unique</emphasis>
   <emphasis>@Aggregate("Instance into Instance")</emphasis>
   LoggingEvent[] buf;
   &hellip;
 }
        </programlisting>
      
        <para>Now, as part of the state of the
        <classname>BoundedFIFO</classname> object, the array object
        referenced by <structfield>buf</structfield> is also protected by the
        lock that protects that state of the buffer.</para>

        <para>Aftering saving (and reanalyzing) we can see the effects
        of this annotation: there are now "29 protected field
        accesses", up from 27. This is because the two array
        dereferences are now counted as protected accesses (lines 71
        and 89):</para>
      
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO5b.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO5b.png"/>
          </imageobject>
        </mediaobject>      
      </sect2>
    
      <sect2 id="assured">
        <title>Assurance Acheived</title>
      
        <para>The project is now fully assured:</para>

        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/BoundedFIFO6.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO6.png"/>
          </imageobject>
        </mediaobject>      
      </sect2>
    </sect1>
  </chapter>

  <chapter id="understanding-assurance-output">
    <title>Understanding JSure Assurance Output</title>
    
    <para>This chapter descibes using examples the wide variety of
    messages that appear in the JSure assurance output.</para>
    
    <sect1 id="effects-assurance">
      <title>Effects Assurance</title>
      
      <para>This discussion of effects assurance results is based
      on assuring the class <classname>EffectsExample</classname>. This class does absolutely
      nothing useful except to demonstrate the various effects assurance
      results.</para>
      
      <figure id="EffectsExample.java">
        <title>The class <classname>EffectsExample</classname></title>
      
        <programlisting linenumbering="numbered" startinglinenumber="5">/**
 * This is a simple class that exists only to show off the 
 * assurance results the Effects Assurance can produce.
 */
public class EffectsExample {
  private int f1;
  
  private int f2;
  
  private int f3;

  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }

  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }

  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }

  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }

  /**
   * Indirectly bad!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad(new EffectsExample(1, 2, 3));
  }

  /**
   * Missing effects!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad(final EffectsExample other) {
    return getSum() + other.doesAnything();
  }
</programlisting>
      </figure>
      
      <para>The results of effects assurance are displayed under the
      top-level heading <guilabel>Effects</guilabel> in the
      <guilabel>Verification Status</guilabel> view.  Under this heading
      is a subheading for each method and constructor that is annotated
      with <classname>@RegionEffects</classname>. Each entry is marked with
      either a green plus <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> or a red X
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>
      indicating whether the effects annotation has been positively or
      negatively assured, respectively.</para>
      
      <para>In our example, the the methods <function>bad()</function> and
      <function>indirectlyBad()</function> fail to assure, while the
      methods <function>getSum()</function>, <function>update()</function>,
      <function>doesAnything()</function>, and the constructor
      <function>EffectsExample()</function> assure.</para>
      
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/effects-assurance-01.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-01.png"/>
        </imageobject>
      </mediaobject>
      
      <para>There are four kinds of results that can appear as 
      evidence for and children of the promise results:</para>
      
      <variablelist>
        <varlistentry id="not-accounted-for">
          <term><replaceable>effect</replaceable> not accounted for by
          declared effect(s)</term>
          <listitem><para>The given effect of the method/constructor
          implementation is not accounted for by any of the declared
          effects of the method/constructor. That is, the
          method/constructor implementation affects more state than it
          declares it does.</para>
          </listitem>
        </varlistentry>
        <varlistentry id="trivially-satisfy">
          <term>Empty effects trivially satisfy declared effects</term>
          <listitem><para>The method/constructor has no effects at all
          and thus trivially satisfies its declared effects.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term id="checked-by"><replaceable>effect<subscript>1</subscript></replaceable> checked by
          <replaceable>effect<subscript>2</subscript></replaceable></term>
          <listitem><para>The particular effect of the
          method/constructor implemenation, <replaceable>effect<subscript>1</subscript></replaceable>, is accounted for by
          the particular declared effect <replaceable>effect<subscript>2</subscript></replaceable>. Often, the
          implementation effect is more specific than the declared
          effect, i.e., it affects a region that is included in the
          region of the declared effect.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term id="constructor-rule"><replaceable>effect</replaceable> checked by constructor rule: writes to a newly
          created object are invisible</term>
          <listitem><para>The particular effect of the constructor
          implemenation is accounted for by a special rule. Constructors
          do not need to report any effects they have on the object
          being constructed because these effects are invisible to the
          caller of the constructor (the object doesn't exist before the
          constructor was called).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The meanings of these results are further elaborated in
      the discussion below.</para>

      <sect2 id="simple-positive-assurances">
        <title>Simple Positive Assurances</title>
        
        <para>Let us examine the assurance results for <function>doesAnything()</function>,
        <function>getSum()</function>, and <function>EffectsExample()</function> in more detail.
        Their chains of evidence expand as follows</para>
        
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/effects-assurance-02.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-02.png"/>
          </imageobject>
        </mediaobject>
        
        <sect3 id="doesAnything">
          <title>Method <function>doesAnything()</function></title>
          
          <para>This method declares that it could read or write anything
          (<classname>@RegionEffects("writes java.lang.Object:All")</classname>),
          but in fact its implementation has no effects at all:</para>
          
          <programlisting linenumbering="numbered" startinglinenumber="16">  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }</programlisting>
          
          <para>Thus, the method assures and the result <computeroutput>"Empty effects
          trivially satisfy declared effects"</computeroutput> appears as evidence for
          the assurance of the declared effects.</para>
        </sect3>

        <sect3 id="getSum">
          <title>Method <function>getSum()</function></title>
          
          <para>Method getSum has the following implementation:</para>
          
          <programlisting linenumbering="numbered" startinglinenumber="28">  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }</programlisting>

          <para>This method declares that could read any of the instance
          fields of the reciever (<code>"reads instance"</code>,
          really a shorthand for <code>"reads
          this:Instance"</code>). The body of the method reads the
          three fields <structfield>f1</structfield>, <structfield>f2</structfield>, and
          <structfield>f3</structfield>. Thus, there are three effects that need
          to be accounted for in order for the declared effects to be
          assured. We see this in the three result drops that appear as
          evidence for the method's declared effects:</para>
          
          <itemizedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f2" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f3" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
          </itemizedlist>

          <para>In particular, there is one result for each
          implementation effect of the method, and the result is
          tagged to the line of code that corresponds to the expression
          that creates the effect.  In this case, all the effects eminate
          from line 30.</para>
        </sect3>
        
        <sect3 id="EffectsExample">
          <title>Constructor <function>EffectsExample</function></title>

          <para>The constructor declares that has no effects
          (<classname>@RegionEffects("none")</classname>) and has the
          following implementation:</para>
          
          <programlisting linenumbering="numbered" startinglinenumber="21">  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }</programlisting>
          
          <para>This case is similar to <function>getSum()</function>
          except that the evidence for the assurance is that the special
          constructor rule applies:</para>

          <itemizedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 23</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 24</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 25</computeroutput></para>
            </listitem>
          </itemizedlist>
        </sect3>
      </sect2>
      
      <sect2 id="complex-positive-assurance">
        <title>Complex Positive Assurance</title>
        
        <para>The assurance results for method <function>update()</function> are
        more complicated. This method calls another method, <function>getSum()</function>;
        thus some the effects of this method are due to the method that it calls:</para>
        
        <programlisting linenumbering="numbered" startinglinenumber="33">  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }</programlisting>
        
        <para>This dependency is reflected in the assurance results:</para>
        
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/effects-assurance-03.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-03.png"/>
          </imageobject>
        </mediaobject>
        
        <para>In particular, we see that the effect "reads
        &lt;this&gt;:Instance" is due to the declared effects of method
        <function>getSum()</function>.  Because of this, the results
        become a graph: the results go on to show that the declared
        effects of <function>getSum()</function> are assured. These are exactly the same
        results as described above. The point here is that we can see
        the complete line of assurance; in particular, the effect within
        <function>update()</function> is accounted for and the source of that effect has been
        assured as well. This is why the icon for the result (line
        35) is a double-plus <guiicon><inlinegraphic
      fileref="images/plus-plus.jpg"/></guiicon>: the large plus indicates effect is
        assured in the context of the method <function>update()</function>, while the small
        plus indicates that the <emphasis>source</emphasis> of that effect has also been
        assured.</para>
        
        <para>The results for method <function>update</function> also
        show the supporting information <computeroutput>Parameter "this"
        bound to "this"</computeroutput>, detailing that the parameter
        <parameter>this</parameter> of the called method
        <function>getSum()</function> is bound to the receiver
        <parameter>this</parameter> of the calling method
        <function>update</function>.  The general form of this message
        is <computeroutput id="parameter">Paremeter
        "<replaceable>formal</replaceable> is bound to
        "<replaceable>actual</replaceable>"</computeroutput>.  This
        information can be useful in understanding how the effects of
        the method call are derived from the declared effects of the
        called method.</para>        
      </sect2>
      
      <sect2 id="effects-failures">
        <title>Assurance Failures</title>
        
        <para>Now we examine the assurance results of the negatively assured methods
        <function>bad()</function> and <function>indirectlyBad()</function>.</para>
        
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/effects-assurance-04.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-04.png"/>
          </imageobject>
        </mediaobject>
        
        <sect3 id="method-bad">
          <title>Method <function>bad()</function></title>
          
          <para>Method <function>bad()</function> is incorrect because it
          invokes the method <function>doesAnything()</function> but only
          declares that it could read the state of the receiver
          (<code>"reads Instance"</code>).</para>

          <programlisting linenumbering="numbered" startinglinenumber="52">  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad(final EffectsExample other) {
    return getSum() + other.doesAnything();
  }</programlisting>

          <para>In particular, there are two results:</para>

          <orderedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:Instance" checked by
              "reads &lt;this&gt;:Instance" at EffectsExample.java line
              54</computeroutput> indicates that the effects of invoking
              <function>getSum()</function> on line 54 are accounted for by the declared
              effects.</para>
            </listitem>
            <listitem>
              <para><computeroutput>"writes java.lang.Object:All" not
              accounted for by declared effect(s) at EffectsExample.java
              line 54</computeroutput> indicates that the effects of
              invoking <function>doesAnything()</function> on line 54 are
              not accounted for.</para>
            </listitem>
          </orderedlist>
        </sect3>
        
        <sect3 id="method-indirectly-bad">
          <title>Method <function>indirectlyBad()</function></title>
          
          <para>This method is interesting because its declared effects
          do account for all the effects of its implementation, in the
          sense that the declared effects of called methods are considered
          to be part of the effects of this method. But the method still
          fails to assure because the declared effects of the called
          method&mdash;in this case <function>bad()</function>&mdash;cannot be assured.</para>

          <programlisting linenumbering="numbered" startinglinenumber="44">  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad(new EffectsExample(1, 2, 3));
  }</programlisting>

          <para>The method has a single result <computeroutput>"reads
          &lt;this&gt;:Instance" checked by "reads
          &lt;this&gt;:Instance" at EffectsExample.java line
          46</computeroutput>. What is interesting, however, is that
          this result is marked with a plus subscripted with a red X <guiicon><inlinegraphic
      fileref="images/plus-x.jpg"/></guiicon>.  This means that the effects assure, but that
          the basis for the implementation effects, namely the effects declaration of
          the method <function>bad</function>, fails to assure.</para>
          
          <para>We also see a more interesting example of the parameter binding
          supporting evidence in the chain of evidence for <function>indirectlyBad</function>.
          The effect on line 46 has the supporting evidence
            <itemizedlist>
              <listitem>
                <para><computeroutput>Parameter "other" bound to "new EffectsExample(1, 2, 3)" at EffectsExample.java line 46</computeroutput></para>
              </listitem>
              <listitem>
                <para><computeroutput>Parameter "this" bound to "this" at EffectsExample.java line 46</computeroutput></para>
              </listitem>
            </itemizedlist>
          </para>
        </sect3>
      </sect2>
    </sect1>
    
    <sect1 id="lock-assurance">
      <title>Lock Assurance</title>
      
      <para>Each <classname>@RegionLock</classname> annotion results in a
      new chain of evidence under <guilabel>Concurrency</guilabel>
      heading in the <guilabel>Verification Status</guilabel> view. Each
      of these chains is marked to indicate whether the model associated
      with it is assured or not, via <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>,
      respectively, and contains additional levels of detail describing
      the particulars of the assurance. This detail includes both
      assurance about the protected state, marked with
      <guiicon><inlinegraphic
      fileref="images/folder-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/folder-x.jpg"/></guiicon>,
      as well as with chains of evidence for other annotations used to
      support the lock model (e.g., <classname>@ReturnsLock</classname> and
      <classname>@SingleThreaded</classname>), again marked with
      <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>. 
      See, for example, <xref linkend="lock-assurance-figure"/>.</para>
      
      <figure id="lock-assurance-figure">
        <title>Example Chains of Evidence for Lock Assurance</title>

        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/lock-assurance-01.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-01.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <sect2 id="assuring-region-lock">
        <title>Assuring <classname>@RegionLock</classname></title>
        
        <para>The example class <classname>SimpleLockExample</classname>
        demonstrates the basics of lock assurance:</para>

        <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("L1 is this protects Instance")</emphasis>
public class SimpleLockExample {
  private int f;
  private int g;
  
  public synchronized int getF() {
    // Good
    return f;
  }
  
  public void setF(final int v) {
    synchronized (this) {
      // Good
      f = v;
    }
  }
  
  <emphasis>@RequiresLock("L1")</emphasis>
  public void doStuff() {
    // Good
    f = 0;
  }
  
  public int getG() {
    // Bad
    return g;
  }
}</programlisting>

        <para>The receiver (<parameter>this</parameter>) is used as a lock
        to protect the <structfield>Instance</structfield> region of the object.
        The field <structfield>f</structfield> is always accessed correctly,
        while the field <structfield>g</structfield> is accessed
        incorrectly.</para>
        
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/lock-assurance-02.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-02.png"/>
          </imageobject>
        </mediaobject>
        
        <para>The correct and incorrect field accesses are grouped under
        distinct subheadings, described below.  The heading <guilabel>lock
        precondition(s)</guilabel> is described below in <xref
        linkend="assuring-requires-lock"/>.</para>
        
        <sect3 id="protected-field-accesses">
          <title>protected field access(es)</title>
          
          <para>This heading groups together all the accesses to fields in the
          protected region that JSure can assure occur when the correct
          lock is held. For our example, this would be the fields in the
          region <structfield>Instance</structfield> and the lock referenced by
          <parameter>this</parameter>.  The individual assurance results
          under this subheading are of the form <computeroutput>Lock
          "<replaceable>lock</replaceable>" held when accessing
          <replaceable>field</replaceable></computeroutput>. In our
          example, there are three of these, one for each access to
          field <structfield>f</structfield> on lines 13, 19, and 26.</para>
          
          <para>Each assurance result is backed up by
          <guilabel>supporting information</guilabel> that shows the
          locks that can be assured to be held when the field is
          accessed: <computeroutput id="intrinsic-lock-held">Intrinsic lock
          "<replaceable>lock</replaceable>" is held</computeroutput>.
          This result links to the source line of code of the expression
          that acquires the lock. In our example, for the access on line
          11, the supporting information links to the declaration of the
          surrounding <code>synchronized</code> method
          <function>getF()</function> on line 11. For the access on line
          19, the supporting information links to the surrounding
          <code>synchronized</code> block on line 17.  Finally,
          for the access on line 26, the supporting information links to
          the the <classname>@RequiresLock</classname> annotation of the
          surrounding method <function>doStuff()</function>on line 23. In
          a more complete example, one in which we have calls to the
          method <function>doStuff()</function>, the use of
          <classname>@RequiresLock</classname> would be assured based on the
          correctness of its callsites. If there were unassured
          callsites, then this field access would be marked with a
          <guiicon><inlinegraphic
          fileref="images/plus-x.jpg"/></guiicon> to indicate that
          assurance of one its preconditions failed.</para>
        </sect3>
        
        <sect3 id="unprotected-field-accesses">
          <title>unprotected field access(es); possible race condition detected</title>
          
          <para>This heading groups together all the accesses to fields in the
          protected region that JSure cannot assure always occur when the lock is held.
          The individual assurance results under this subheading are of the 
          form <computeroutput>Lock "<replaceable>lock</replaceable>" not held when
          accessing <replaceable>field</replaceable></computeroutput>.  In our example,
          there is one of these results for the access to the field <structfield>g</structfield> 
          at line 31.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-requires-lock">
        <title>Assuring Method Preconditions: <classname>@RequiresLock</classname></title>
        
        <para>The result heading for each <classname>@RegionLock</classname>
        annotation collects all the <classname>@RequiresLock</classname> annotations that name
        its lock under the heading <guilabel>lock preconditions</guilabel>; see <xref linkend="RequiresLockExample-results"/>.
        Each <classname>@RequiresLock</classname> annotation is assured by checking
        each call site of the annotated method to see if the correct
        lock is held. As with field access, the good and bad call sites
        are grouped together; again, see <xref linkend="RequiresLockExample-results"/>.</para>
        
        <para>This section uses class
        <classname>RequiresLockExample</classname> to describe how
        <classname>@RequiresLock</classname> annotations are assured:</para>
        
        <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("RL is this protects Instance")</emphasis>
public class RequiresLockExample {
  private int f;
  
  <emphasis>@RequiresLock("RL")</emphasis>
  public int get() { return f; }
  
  <emphasis>@RequiresLock("RL")</emphasis>
  public void set(final int v) { f = v; }
  
  public synchronized void doStuff() {
    //good
    set(
        // good
        get() + 10);
  }
  
  public void doMoreStuff(final int v) {
    synchronized (this) {
      // good
      set(v + 100);
    }
  }
  
  public int bad() {
    // bad
    return get();
  }
}</programlisting>
        
        <figure id="RequiresLockExample-results">
          <title>Chains of Evidence for <classname>RequiresLockExample</classname></title>.
          
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/lock-assurance-03.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-03.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <sect3 id="preconditions-satisfied">
          <title>lock precondition(s) satisfied</title>

          <para>Each call site for which JSure can determine that the
          required lock is held results in an entry under this heading.
          The individual results read <computeroutput>Lock
          "<replaceable>lock</replaceable>" held when invoking
          <replaceable>method</replaceable>; precondition satisfied</computeroutput>.  As with
          the field assurances, these results have supporting
          information indicating which statements acquire the locks. In
          our example, both uses of <function>set()</function>, on lines
          18 and 26, are correct, and one use of
          <function>get()</function>, on line 20, is correct. For
          <function>set()</function>, the supporting information refers to
          the <code>synchronized</code> method on line 16 and the
          <code>synchronized</code> block on line 24,
          respectively. For <function>get()</function>, the supporting
          information refers to the <code>synchronized</code>
          method on line 16.</para>
        </sect3>

        <sect3 id="preconditions-unsatisfied">
          <title>lock precondition(s) not satisfied; possible race
          conditions enabled</title>

          <para>Each call site for which JSure is unable to asure the
          required lock is always held is grouped under this subheading.
           The individual results read <computeroutput>Lock
          "<replaceable>lock</replaceable>" not held when invoking
          <replaceable>method</replaceable>; precondition unsatisfied</computeroutput>.  The call
          to <function>get()</function> on line 32 is not assured in our
          example.</para>
        </sect3>
        
        <sect3>
          <title>Supporting Evidence</title>
          
          <para>Locks that are assumed to be held due to a
          <classname>@RequiresLock</classname> annotation are reported
          using the message <computeroutput>Assuming lock
          "<replaceable>lock</replaceable>" is held</computeroutput>.
          See, for example, the supporting information on lines 10 and
          13 for the field accesses one lines 11 and 14,
          respectively.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-singled-threaded">
        <title>Assuring Constructors: <classname>@SingleThreaded</classname></title>
        
        <para>The class <classname>ConstructorExample</classname> below
        demonstrates assurance issues with object constructors.
        Specifically, each <classname>@SingleThreaded</classname> annotation
        appears directly under the <guilabel>Concurrency</guilabel>
        top-level heading, and field initializers and their
        initialization expressions are assured once <emphasis>for
        each</emphasis> constructor in the class. This section discusses
        the single-threaded constructors; the next, <xref linkend="assuring-field-init"/> discusses field
        initialization issues.</para>
        
        <programlisting linenumbering="numbered" startinglinenumber="8"><emphasis>@RegionLock("L2 is this protects Instance")</emphasis>
public class ConstructorExample {
  private int f = 100;
  
  private int g = f + 10;
  
  private int h;
  
  private final Aux aux = new Aux();
  
  private final int bad = aux.doStuff();
  
  public ConstructorExample(final int a) {
    // bad
    h = a;
  }

  <emphasis>@SingleThreaded</emphasis>
  <emphasis>@Borrowed("this")</emphasis>
  // good constructor
  public ConstructorExample(final int a, final int b) {
    // good
    h = a;
    // good
    f += b;
  }
  
  <emphasis>@SingleThreaded</emphasis>
  // bad constructor
  public ConstructorExample() {
    h = 10;
  }
  
  <emphasis>@RegionLock("AuxLock is this protects Instance")</emphasis>
  static class Aux {
    private int x;
    
    <emphasis>@RequiresLock("AuxLock")</emphasis>
    public int doStuff() {
      return x; 
    }
  }
}</programlisting>
        
        <para>Class <classname>ConstructorExample</classname> has two
        constructors annotated with <classname>@SingleThreaded</classname>:
        <function>ConstructorExample(int, int)</function> at line 28, and
        <function>ConstructorExample()</function> at line 37. The
        annotation assures for the first, but not for the second:</para>
        
        <mediaobject>
          <imageobject condition="isHTML">
            <imagedata fileref="images/lock-assurance-04.png"/>
          </imageobject>
          <imageobject condition="isFO">
            <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-04.png"/>
          </imageobject>
        </mediaobject>

        <sect3 id="singledThreaded-supported">
          <title>single-threaded constructor supported</title>

          <para>This result indicates that JSure is able to assure that
          the constructor has exclusive access to the object being
          constructed. This assurance is acheived in one of two ways:</para>

          <orderedlist>
            <listitem>
              <para>The constructor has a borrowed receiver.  That is,
              the constructor is also annotated with
              <classname>@Borrowed("this")</classname>.</para>
            </listitem>
            <listitem>
              <para>The constructor does not start any threads and only writes to the newly created object under construction.
              Specifically, the constructor is annotated with <classname>@Starts("nothing")</classname> and its declared effects
              are contained in the effect <code>"writes this:Instance"</code>.</para>
            </listitem>
          </orderedlist>

          <para>JSure attempts to assure the annotation using both
          techniques, and the results of this are shown under the
          <guilabel>precondition choice(s)</guilabel> subheading. For constructor
          <function>ConstructorExample(int, int)</function> only the first case applies, an we see
          the <guilabel>by borrowed receiver</guilabel> subheading. Under that heading are the
          results elaborating the assurance that the receiver is unaliased. Any
          evidence about using the second option would appear under the
          subheading <guilabel>by effects</guilabel>.</para>
        </sect3>
       
        <sect3 id="singleThreaded-escaping">
          <title>single-threaded constructor has possibly escaping receiver</title>
         
          <para>This result indicates that JSure is unable to assure that
          the object being constructed is accessed by the thread that is
          constructing it only. That is, the receiver may escape the
          constructing thread and not be accessed by a single thread. In
          our example, the constructor <function>ConstructorExample()</function> fails to assure
          because we do not provide any design intent that can be used to
          back up the claims of single-threadedness.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-field-init">
        <title>Assuring Constructors: Field Initialization</title>
        
        <para>Assurance of constructors is also complicated by field
        initializers. Non-static fields with initializers need to be
        assured separately for each constructor in the class because the
        single-threadedness (or not) of the constructor can affect their
        assurance.</para>

        <para>In the case of the example class
        <classname>ConstructorExample</classname> above, the fields
        <structfield>f</structfield> and <structfield>g</structfield> have initializers
        and thus the use of the fields and their initialization
        expressions need to be incorporated into the assurance of the
        constructors. Because there are three constructors, these uses
        are analyzed three times.</para>

        <sect3 id="constructor-1">
          <title>Constructor <function>ConstructorExample(int)</function></title>
          
          <para>The first constructor is not annotated with
          <classname>@SingleThread</classname> and thus all the field accesses it makes
          are unprotected. The JSure results reflect this:</para>
          
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/lock-assurance-05.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-05.png"/>
            </imageobject>
          </mediaobject>

          <para id="on-behalf-of">The uses of field <structfield>f</structfield> on line 10, the
          fields <structfield>f</structfield> and <structfield>g</structfield> on line
          12, and the use of field <structfield>h</structfield> on line 22 are
          all marked as unprotected. The uses on lines 10 and 12 occur
          due to field declarations and thus are marked with
          <guilabel>supporting information</guilabel> indicating which
          constructor the access is considered to be a part of:
          <computeroutput>Analyzed on behalf of constructor
          "test.ConstructorExample.ConstructorExample(int)"</computeroutput>.</para>
        </sect3>
        
        <sect3 id="constructor-2">
          <title>Constructor <function>ConstructorExample(int, int)</function></title>
          
          <para>This constructor is declared to be <classname>@SingleThreaded</classname>, and JSure is 
          able to assure that its implementation is in fact so.  Thus all its field accesses
          are protected:</para>
          
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/lock-assurance-06.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-06.png"/>
            </imageobject>
          </mediaobject>
          
          <para>Observe in particular that the uses of the field
          <structfield>f</structfield> on line 10, and the fields
          <structfield>f</structfield> and <structfield>g</structfield> on line 12 are
          assured, and the supporting information indicates that they
          are <computeroutput>Analyzed on behalf of constructor
          "test.ConstructorExample.ConstructorExample(int, int)"</computeroutput>.
          Also note that all the field access assuranced depend on the <classname>@SingleThreaded</classname>
          annotation on the constructor itself, which we previously observed is assured.</para>
        </sect3>
        
        <sect3 id="constructor-03">
          <title>Constructor <function>ConstructorExample()</function></title>
          
          <para>This constructor is annotated with
          <classname>@SingleThreaded</classname>, but JSure is not able to
          assure that this is the case.  Thus all its field accesses are
          found to be protected, but with unsatisfied preconditions and are
          marked with <guiicon><inlinegraphic
          fileref="images/plus-x.jpg"/></guiicon>:</para>
      
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/lock-assurance-07.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-07.png"/>
            </imageobject>
          </mediaobject>
          
          <para>Again, observe that the uses of the field <structfield>f</structfield> on line 10,
          and the fields <structfield>f</structfield> and <structfield>g</structfield> on line 12 are assured.
          In this case, the supporting information marks that they are
          <computeroutput>Analyzed on behalf of constructor
          "test.ConstructorExample.ConstructorExample()"</computeroutput>.</para>
        </sect3>
        
        <sect3 id="aux.doStuff">
          <title>Assuring Calls to <function>Aux.doStuff()</function></title>
          
          <para>Finally, there is the case of the call to <function>Aux.doStuff()</function> in
          the initializer for field <structfield>bad</structfield>. This method has a lock
          precondition that must be satisfied each time the method is
          called. This is interesting in the context of assuring
          constructors because this method has three call sites: one for
          each constructor. Indeed, this is reflected in the assurance
          results:</para>
          
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/lock-assurance-08.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-08.png"/>
            </imageobject>
          </mediaobject>
          
          <para>This call cannot be assured for any of the constructors
          because <emphasis>it is not possible for the necessary lock to be
          acquired in the field declaration</emphasis>. This can be remedied by
          initializing <structfield>bad</structfield> in each constructor, or by moving the
          initialization to a single instance initializer block:</para>

          <programlisting>@RegionLock("L2 is this protects Instance")
public class ConstructorExample {
  &hellip;
  private final Aux aux = new Aux();
  private final int bad;
  
  {
    synchronized (aux) { <lineannotation>(Line 21)</lineannotation>
      bad = aux.doStuff();
    }
  }
  &hellip;
} </programlisting>
          
          <para>This changes the assurance results for
          <classname>AuxLock</classname> to be</para>
          
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/lock-assurance-09.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-09.png"/>
            </imageobject>
          </mediaobject>
          
          <para>Again, observe how the initializer block is analyzed
          once for each constructor.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-returns-lock">
        <title>Assuring <classname>@ReturnsLock</classname></title>
        
        <para>Each <classname>@ReturnsLock("<replaceable>lock</replaceable>")</classname>
        annotation creatse a result subheading under the heading for the named 
        lock <replaceable>lock</replaceable>.  The
        implementation of the annotated method&mdash;actually each <code>return</code>
        expression in the method&mdash;is checked to assure that it actually
        returns the named lock.</para>

        <para>The class <classname>ReturnsLockExample</classname>, below,
        demonstrates the two kinds of results (see <xref
        linkend="returns-lock-results"/>):</para>

        <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class ReturnsLockExample {
  protected int v;
  
  <emphasis>@ReturnsLock("L")</emphasis>
  private Object goodGetLock() {
    return this;
  }
  
  <emphasis>@ReturnsLock("L")</emphasis>
  private Object badGetLock() {
    return new Object();
  }
  
  public void doStuff() {
    synchronized (goodGetLock()) {
      v = 1; 
    }
    synchronized (badGetLock()) {
      v = 2;
    }
  }
}</programlisting>
        
        <figure id="returns-lock-results">
          <title>Assurance results for <classname>ReturnsLockExample</classname></title>
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/lock-assurance-10.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-10.png"/>
            </imageobject>
          </mediaobject>
        </figure>

        <sect3 id="good-return">
          <title>return statement(s) returning the correct lock</title>
          
          <para>All the positive assurance results for a single
          <classname>@ReturnsLock</classname> annotation are grouped under
          this subheading.  Each result is of the form
          <computeroutput>Return statement correctly returns lock
          "<replaceable>lock</replaceable>"</computeroutput>.</para>

          <para>In our example, method <function>goodGetLock()</function>
          always returns <parameter>this</parameter>, and thus is assured to
          be correct.</para>
        </sect3>
        
        <sect3 id="returns-lock-bad">
          <title>return statement(s) possibly returning the wrong lock</title>

          <para>All the negative assurance results for a single
          <classname>@ReturnsLock</classname> annotation are grouped under
          this subheading.  Each result is of the form
          <computeroutput>Return statement expected to returned lock
          "<replaceable>lock</replaceable>"</computeroutput>.</para>

          <para>In our example, method <function>badGetLock()</function>
          cannot be assured to always return the correct lock (the
          object referenced by <parameter>this</parameter>)&mdash;in fact,
          it never does&mdash;so it is marked as unassured.</para>
        </sect3>
      </sect2>
      
      <sect2 id="advanced-locks">
        <title>Region Locks and Aggregated State</title>
          
        <para>Normally lock analysis assumes that a called method takes
        responsibility for acquiring all the locks it needs, either by
        acquiring the locks it needs in its implementation, or by
        declaring needed locks via <classname>@RequiresLock</classname>
        annotations.  This assumption fails when references to objects
        whose state has been aggregated into another object are passed
        as method paramters.  This is because only the caller knows how
        the state is aggregated.  In these cases, lock analysis must
        determine for each method call, based on the declared effects of
        the called method and the region/aggregation model, what locks
        must be held.  There are two messages, one positive and one
        negative, that can be reported in this situation:
          
          <variablelist>
            <varlistentry>
              <term id="held-when-invoking">Lock "<replaceable>lock</replaceable>" held when invoking <replaceable>method</replaceable></term>
              <listitem>
                <para>Analysis has determine that the lock
                <replaceable>lock</replaceable> must be held and can
                determine that it is always held when the method is
                called.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term id="not-held-when-invoking">Lock "<replaceable>lock</replaceable>" not held when invoking <replaceable>method</replaceable></term>
              <listitem>
                <para>Analysis has determine that the lock
                <replaceable>lock</replaceable> must be held but that it
                is not always held when the method is called.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>
          
        <para>Both the positive and negative assurance results have at
        least one additonal message as <guilabel>supporting
        information</guilabel>.  This message has the form
        <computeroutput id="indirect-evidence">Method effect
        <replaceable>effect</replaceable> affects region
        <replaceable>region</replaceable> of <replaceable>field
        ref</replaceable> which is aggregated into region
        <replaceable>region&prime;</replaceable></computeroutput>. 
        Essentially, this message indicates the method effect and
        aggregation information used to conclude that the given lock is
        necessary.</para>
          
        <para>Consider the class <classname>HeldWhenInvoking</classname>
        below, and its results, shown in <xref
        linkend="held-when-invoking-results"/>:</para>
          
        <programlisting linenumbering="numbered" startinglinenumber="13">@Regions({
  @Region("private Array1"),
  @Region("private Array2")
})
@RegionLocks({
  @RegionLock("L1 is this protects Array1"),
  @RegionLock("L2 is lock protects Array2")
})
public class HeldWhenInvoking {
  private final Object lock = new Object();
  
  <emphasis>@InRegion("Array1")</emphasis>
  <emphasis>@Unique</emphasis>
  <emphasis>@Aggregate("Instance into Array1")</emphasis>
  private int[] data1;
    
  <emphasis>@Unique</emphasis>
  <emphasis>@Aggregate("Instance into Array2")</emphasis>
  private final int[] data2 = new int[] { 10, 9, 8, 7, 6 };
  
  
  
  <emphasis>@RegionEffects("reads a:Instance")</emphasis>
  private static int sum(final @Borrowed int[] a) {
    int sum = 0;
    for (int v : a) {
      sum += v;
    }
    return sum;
  }
  
  
  
  public int purelyLocal() {
    int[] localArray = new int[] { 1, 2, 3, 4, 5 };
    return sum(localArray);
  }
  
  public int touchesIndirectState_bad() {
    synchronized (this) {
      data1 = new int[] { 1, 2, 3, 4, 5 };
    }
    return sum(data1) +
      sum(data2);
  }
  
  public synchronized int touchesIndirectState_good() {
    data1 = new int[] { 1, 2, 3, 4, 5 };
    synchronized (lock) {
      return sum(data1) +
        sum(data2);
    }
  }
}</programlisting>

        <figure id="held-when-invoking-results">
          <title>Assurance results for <classname>HeldWhenInvoking</classname></title>
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/held-when-invoking-01.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/held-when-invoking-01.png"/>
            </imageobject>
          </mediaobject>
        </figure>
          
        <para>The class <classname>HeldWhenInvoking</classname> has two
        unique fields <structfield>data1</structfield> and
        <structfield>data2</structfield> that reference integer arrays. 
        The elements of each array are aggregated into the regions
        <structfield>Array1</structfield> and
        <structfield>Array2</structfield>, respectively, that are
        protected by the locks <structfield>L1</structfield> and
        <structfield>L2</structfield>, respectively.  The
        <code>static</code> method <function>sum()</function> takes an
        integer array as a parameter and returns the sum of its
        elements.  This method is not written to operate on any specific
        array, and is thus ignorant of any synchronization requirements
        that might be necessary to operate on any particular
        array.</para>
          
        <para>The method <function>purelyLocal()</function> allocations
        a new array referenced by a local variable, and passes it to
        <function>sum()</function>. This call to
        <function>sum()</function> at line 48 does not require any locks
        because the array is referenced by a local variable.</para>
          
        <para>The method <function>touchesIndirectState_bad()</function>
        is a different situation: it passes the arrays referenced by
        <structfield>data1</structfield> and
        <structfield>data2</structfield> to <function>sum()</function>. 
        There are three negative results originating form this method:
          <orderedlist>
            <listitem>
              <para><computeroutput>Lock "&lt;this&gt;:L1" not held when accessing this.data1 at HeldWhenInvoking.java line 55</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>Lock "&lt;this&gt;:L1" not held when invoking test.HeldWhenInvoking.sum(this.data1) at HeldWhenInvoking.java line 55</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>Lock "&lt;this&gt;:L2" not held when invoking test.HeldWhenInvoking.sum(this.data2) at HeldWhenInvoking.java line 56</computeroutput></para>
            </listitem>
          </orderedlist>
            
          The first is from the unprotected access to
          <structfield>data1</structfield> on line 55.  The second is
          because analysis determines that the call to
          <function>sum()</function> on line 55 may read the state of
          the array referenced by <structfield>data1</structfield>, and
          thus, by aggregation, the state of the region
          <structfield>Array1</structfield>.  Thus the lock
          <structfield>L1</structfield> must be held.  The supporting
          information indicates this: <computeroutput>Method effect
          reads &lt;this.data1&gt;Instance affects region
          java.lang.Object.Instance  of this.data1 which is aggregated
          into region test.HeldWhenInvoking.Array1</computeroutput>. The
          reader may wonder, is it not enough that the field
          <structfield>data1</structfield> needs a lock anyway? Clearly
          we cannot pass its value to parameter without holding the
          correct lock to being with.  But consider the use of field
          <structfield>data2</structfield> on line 56. It is
          <code>final</code>, and thus no lock is requried to access its
          value.  But because of aggregation, a lock <emphasis>is
          required</emphasis> to access the elements of the array it
          references.</para>

        <para>The method
        <function>touchesIndirectState_good()</function> is the same as
        <function>touchesIndirectState_bad()</function> except that it
        is correctly synchronized.  It has three positive assurance
        results:
          <orderedlist>
            <listitem>
              <para><computeroutput>Lock "&lt;this&gt;:L1" held when accessing this.data1 at HeldWhenInvoking.java line 62</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>Lock "&lt;this&gt;:L1" held when invoking test.HeldWhenInvoking.sum(this.data1) at HeldWhenInvoking.java line 62</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>Lock "&lt;this&gt;:L2" held when invoking test.HeldWhenInvoking.sum(this.data2) at HeldWhenInvoking.java line 63</computeroutput></para>
            </listitem>
          </orderedlist>
        </para>            
      </sect2>

      <sect2>
        <title>Assuring <package>java.util.concurrent</package> Locks</title>
          
        <para>JSure also supports the assurance of the correct use of
        <package>java.util.concurrent</package> locks. These locks are
        explicitly acquired and released via the methods
        <function>Lock.lock()</function> and
        <function>Lock.unlock()</function>.  Because of this, there is a
        wider variety of warning and other information messages that
        JSure can produce about their use.  We begin with a simple
        example that demonstrates that the primary
        <emphasis>assurance</emphasis> messages are unchanged.  Consider
        the class <classname>SimpleJUCLockExample</classname> below, and
        its results shown in <xref linkend="juc-results"/>.</para>
          
        <programlisting linenumbering="numbered" startinglinenumber="9"><emphasis>@RegionLock("L1 is lock protects Instance")</emphasis>
public class SimpleJUCLockExample {
  public final Lock lock = new ReentrantLock(); 
  private int f;
  private int g;
  
  public int getF() {
    lock.lock();
    try {
      // Good
      return f;
    } finally {
      lock.unlock();
    }
  }
  
  public boolean setF(final int v) {
    if (lock.tryLock()) {
      try {
        f = v;
      } finally {
        lock.unlock();
      }
      return true;
    } else {
      return false;
    }
  }
  
  <emphasis>@RequiresLock("L1")</emphasis>
  public void doStuff() {
    // Good
    f = 0;
  }
  
  public int getG() {
    // Bad
    return g;
  }
}</programlisting>
          
        <figure id="juc-results">
          <title>Assurance results for <classname>SimpleJUCLockExample</classname></title>
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/juc-assurance-01.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/juc-assurance-01.png"/>
            </imageobject>
          </mediaobject>
        </figure>
          
        <para>Assurance recognizes that the lock object named in the
        <classname>@RequiresLock</classname> annotation, the field
        <structfield>lock</structfield>, is declared to be a
        <classname>java.util.concurrent.locks.Lock</classname>, and
        adjusts the analysis accordingly.  Observe that
          <itemizedlist>
            <listitem>
              <para>The positive assurance results on lines 19, 28,
              and 41, and the negative assurance result on line 46 use
              the same message templates as when <link
              linkend="assuring-region-lock">instrinsic locks</link>
              are used.</para>
            </listitem>
            <listitem>
              <para id="juc-lock-held">The supporting information
              indicating which lock is held reads
              <computeroutput>java.util.concurrent lock
              "<replaceable>lock</replaceable>" is
              held</computeroutput>, instead of
              <computeroutput>Instrinsic lock
              "<replaceable>lock</replaceable>" is
              held</computeroutput>.</para>
            </listitem>
            <listitem>
              <para>There is a new category of informative results
              titled <guilabel>lock()&ndash;unlock()
              matches</guilabel>.  The results under this heading are
              described in their <link
              linkend="lock-unlock-matches">own section</link>
              below.</para>
            </listitem>
          </itemizedlist>
        </para>
          
        <para>Similarly, JSure understands the difference between a
        <classname>java.util.concurrent.locks.Lock</classname> and a
        <classname>java.util.concurrent.locks.ReadWriteLock</classname>.
        Consider the class <classname>SimpleRWLockExample</classname>
        below and it its results in <xref linkend="rw-results"/>.</para>
          
        <programlisting linenumbering="numbered" startinglinenumber="9"><emphasis>@RegionLock("L1 is lock protects Instance")</emphasis>
public class SimpleRWLockExample {
  public final ReadWriteLock lock = new ReentrantReadWriteLock(); 
  private int f;
  private int g;
  
  public int getF() {
    lock.readLock().lock();
    try {
      // Good
      return f;
    } finally {
      lock.readLock().unlock();
    }
  }
  
  public boolean setF(final int v) {
    if (lock.writeLock().tryLock()) {
      try {
        f = v;
      } finally {
        lock.writeLock().unlock();
      }
      return true;
    } else {
      return false;
    }
  }
  
  <emphasis>@RequiresLock("L1.writeLock()")</emphasis>
  public void doStuff() {
    // Good
    f = 0;
  }
  
  public void setG(final int v) {
    lock.readLock().lock();
    try {
      // Bad
      g = v;
    } finally {
      lock.readLock().unlock();
    }
  }
}</programlisting>
          
        <figure id="rw-results">
          <title>Assurance results for <classname>SimpleRWLockExample</classname></title>
          <mediaobject>
            <imageobject condition="isHTML">
              <imagedata fileref="images/juc-assurance-02.png"/>
            </imageobject>
            <imageobject condition="isFO">
              <imagedata width="100%" scalefit="1" fileref="images/juc-assurance-02.png"/>
            </imageobject>
          </mediaobject>
        </figure>

       <para>Again, we see 
          <itemizedlist>
            <listitem>
              <para>The positive assurance results on lines 19, 28,
              and 41, and the negative assurance result on line 48 use
              the same message templates as when <link
              linkend="assuring-region-lock">instrinsic locks</link>
              are used.</para>
            </listitem>
            <listitem>
              <para>The supporting information
              indicating which lock is held reads
              <computeroutput>java.util.concurrent lock
              "<replaceable>lock</replaceable>" is
              held</computeroutput>.</para>
            </listitem>
            <listitem>
              <para>There is a new category of informative results
              titled <guilabel>lock()&ndash;unlock()
              matches</guilabel>.</para>
            </listitem>
          </itemizedlist>
            
        We also see that JSure understands the difference between a read
        lock and a write lock.  The assignment to field
        <structfield>g</structfield> on line 48 fails to assure because
        assignment requires the write lock, but the method only acquires
        the read lock on line 45.</para>
          
        <sect3 id="lock-unlock-matches">
          <title>Lock&ndash;unlock matches</title>
            
          <para>JSure tracks calls to the lock acquisition methods
          <function>lock()</function>, <function>lockInterruptibly()</function>, and <function>tryLock()</function>
          and to the lock release method <function>unlock()</function>.
          It matches the calls in both directions: forwards to match
          acquisitions to releases, and backwards to match releases to
          acquistions. This may seem redundant, but forwards matching
          catches missing releases, and backwards matching catches
          missing acquisitions.  We have already seen the most commong
          matching messages in <xref linkend="juc-results"/> and <xref
          linkend="rw-results"/>:
            
            <orderedlist>
              <listitem>
                <para id="acquires-match"><computeroutput><replaceable>acquires</replaceable>
                call has matching unlock() call at line
                <replaceable>line</replaceable></computeroutput>, where 
                <replaceable>acquires</replaceable> is either <computeroutput>lock()</computeroutput>,
                <computeroutput>lockInterruptibly()</computeroutput>,
                or <computeroutput>tryLock()</computeroutput>.</para>
              </listitem>
              <listitem>
                <para id="release-match"><computeroutput>unlock() call has matching <replaceable>acquires</replaceable> call at line
                <replaceable>line</replaceable></computeroutput>, where 
                <replaceable>acquires</replaceable> is either <computeroutput>lock()</computeroutput>,
                <computeroutput>lockInterruptibly()</computeroutput>,
                or <computeroutput>tryLock()</computeroutput>.</para>
              </listitem>
            </orderedlist>
            
          The first message indicates that a matching
          <function>unlock()</function> call has been found for the
          given <function>lock()</function>, <function>lockInterruptibly()</function>,
          <function>tryLock()</function> call.  The second message, that
          a matching <function>lock()</function>, <function>lockInterruptibly</function>,
          <function>tryLock()</function> call has been found for the
          given <function>unlock()</function> call.  In most
          circumstances these messages will appear in pairs, as they do
          in our examples above.</para>
          
          <para>It's possible that a matching call cannot be found at all:
          
            <itemizedlist>
              <listitem>
                <para id="acquires-no-match"><computeroutput><replaceable>acquires</replaceable>
                call has no matching unlock() calls</computeroutput>, where 
                <replaceable>acquires</replaceable> is either <computeroutput>lock()</computeroutput>,
                <computeroutput>lockInterruptibly()</computeroutput>,
                or <computeroutput>tryLock()</computeroutput>.</para>
              </listitem>
              <listitem>
                <para id="release-no-match"><computeroutput>unlock() call
                has no matching lock() calls</computeroutput>.</para>
              </listitem>
            </itemizedlist>

          Or that a matching call can only be found on some, but not all, control flow paths:
          
            <itemizedlist>
              <listitem>
                <para id="acquires-different"><computeroutput><replaceable>acquires</replaceable>
                call has a different number of matching unlock() calls along different control paths</computeroutput>, where 
                <replaceable>acquires</replaceable> is either <computeroutput>lock()</computeroutput>,
                <computeroutput>lockInterruptibly()</computeroutput>,
                or <computeroutput>tryLock()</computeroutput>.</para>
              </listitem>
              <listitem>
                <para id="release-different"><computeroutput>unlock()
                call has a different number of matching lock() calls
                along different control paths</computeroutput>.</para>
              </listitem>
            </itemizedlist>
            
          This usually occurs when there
          <code>try</code>&ndash;<code>finally</code> code pattern is
          not followed correctly.  See <ulink
          url="http://java.sun.com/javase/6/docs/api/java/util/concurrent/locks/Lock.html">the
          documentation for <classname>java.util.concurrent.locks.Lock</classname></ulink>.</para>          
        </sect3>
      </sect2>
      
      <sect2 id="lock-warnings">
        <title>Suggestions and Warnings</title>
        
        <para>Lock assurance can also yield several classes of reults under the
        top-level <guilabel>Suggestions and Warnings</guilabel> heading.</para>
        
        <sect3 id="shared-unprotected">
          <title>protected reference(s) to a possibly shared unprotected object; possible race condition detected</title>
          
          <para>A lock on a region only protects the fields in that
          region.  It does not protect <emphasis>the objects referenced
          by those fields</emphasis>.  To remind the programmer of this
          situation, JSure generates warnings when the state of objects
          referenced by protected fields is accessed.  Two such warnings
          are possible:
          
            <variablelist>
              <varlistentry>
                <term id="possibly-shared-field">Field reference
                "<replaceable>field ref</replaceable>" may be to a
                shared unprotected object</term>
                <listitem>
                  <para>The field expression accesses a field of
                  an object referenced by a field that is protected by a
                  named lock.  Specifically,
                  
                    <itemizedlist>
                      <listitem>
                        <para><replaceable>field ref</replaceable> is of
                        the form
                        <code><replaceable>expr</replaceable>.<replaceable>f</replaceable>.<replaceable>f&prime;</replaceable></code>
                        or <code><replaceable>expr</replaceable>.<replaceable>f</replaceable>[&hellip;]</code>
                        </para>
                      </listitem>
                      <listitem>
                        <para>The field
                        <structfield><replaceable>f&prime;</replaceable></structfield>
                        is not <code>final</code> or
                        <code>volatile</code>.</para>
                      </listitem>                    
                      <listitem>
                        <para>The region
                        <structfield><replaceable>f&prime;</replaceable></structfield> or
                        <structfield>[]</structfield>, respectively, <emphasis>is
                        not</emphasis> associated with a lock, either
                        directly or by aggregation.</para>
                      </listitem>
                      <listitem>
                        <para>Either,
                          <itemizedlist>
                            <listitem>
                              <para>The region
                              <structfield><replaceable>f</replaceable></structfield>
                              <emphasis>is</emphasis> protected
                              by a lock, either directly or via
                              aggregation.</para>
                            </listitem>
                          </itemizedlist>
                        or
                          <itemizedlist>
                            <listitem>
                              <para>The field <structfield><replaceable>f</replaceable></structfield>
                              is <code>final</code> or <code>volatile</code> and the class that
                              it is declared in contains at least one <classname>@PolicyLock</classname>
                              or <classname>@RegionLock</classname> annotation.</para>
                            </listitem>
                          </itemizedlist>
                        </para>
                      </listitem>
                    </itemizedlist>
                  </para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term id="possibly-shared-receiver">Receiver
                "<replaceable>field ref</replaceable>" may be a shared
                unprotected object</term>
                <listitem>
                  <para>The field expression references a field that is
                  protected by a lock and is used as the receiver of a
                  method call.  Specfically,
                    <itemizedlist>
                      <listitem>
                        <para><replaceable>field ref</replaceable> is of the form 
                        <code><replaceable>expr</replaceable>.<replaceable>f</replaceable></code>.</para>
                      </listitem>
                      <listitem>
                        <para>The class/interface of the object referenced by
                        <code><replaceable>expr</replaceable>.<replaceable>f</replaceable></code>
                        <emphasis>is not</emphasis> annotated with <classname>@SelfProtected</classname>.</para>
                      </listitem>
                      <listitem>
                        <para>The field <structfield><replaceable>f</replaceable></structfield>
                        <emphasis>is not</emphasis>
                        annotated with <classname>@Unique</classname>.</para>
                      </listitem>
                      <listitem>
                        <para>Either,
                          <itemizedlist>
                            <listitem>
                              <para>The region
                              <structfield><replaceable>f</replaceable></structfield>
                              <emphasis>is</emphasis> protected
                              by a lock, either directly or via
                              aggregation.</para>
                            </listitem>
                          </itemizedlist>
                        or
                          <itemizedlist>
                            <listitem>
                              <para>The field <structfield><replaceable>f</replaceable></structfield>
                              is <code>final</code> or <code>volatile</code> and the class that
                              it is declared in contains at least one <classname>@PolicyLock</classname>
                              or <classname>@RegionLock</classname> annotation.</para>
                            </listitem>
                          </itemizedlist>
                        </para>
                      </listitem>
                    </itemizedlist>
                  </para>
                </listitem>
              </varlistentry>
            </variablelist>
          </para>
          
          <para>Class <classname>SharedUnprotectedStateExample</classname> demonstrates these
          results, shown in <xref linkend="shared-unprotected-results"/>:</para>

          <programlisting linenumbering="numbered" startinglinenumber="7"><emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class SharedUnprotectedStateExample {
  private int[] array = new int[10];
  private Object object = new Object();

  @SingleThreaded
  @Borrowed("this")
  public SharedUnprotectedStateExample() {
    // do nothing
  }
  
  public <emphasis>synchronized</emphasis> String doStuff() {
    int sum = 0;
    for (int i = 0; i &lt; array.length; i++) {
      sum += array[i];
    }
    
    return object.toString() + " " + sum;
  }
}</programlisting>
          
          <figure id="shared-unprotected-results">
            <title>Assurance results for <classname>SharedUnprotectedStateExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/shared-unprotected-01.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/shared-unprotected-01.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
          <para>The warning for line 21, <computeroutput>Field reference "this.array[i]" may be 
          to a shared unprotected object</computeroutput> reminds us that although the field
          <structfield>array</structfield> is protected by the lock (correctly acquired by
          the <code>synchronized</code> method <function>doStuff()</function>), the elements of
          the array object it points to are not.  It is entirely possible that a field of
          another object holds a reference to the same array.  The synchronization on 
          <function>doStuff()</function> prevents concurrent access to that array through 
          the <structfield>array</structfield> field, but not through any other fields of other
          objects that may reference the array.  Thus this situation is potentially unsafe.</para>
          
          <para>Similarly, the warning for line 24, <computeroutput>Receiver "this.object" may be a
          shared unprotected object</computeroutput> remnds us that the object referenced by 
          <structfield>object</structfield> may be accessible through the fields of other objects
          as well.  Therefore, it is potentially unsafe to access the state of that object
          by invoking a method on it.</para>          
        </sect3>
        
        <sect3 id="redundant-locks">
          <title>redundant lock acquisition(s)</title>
          
          <para>This subheading groups together warnings about lock
          acquisitions that may be redundant, that is, that acquire a
          lock that <emphasis>must</emphasis> already be held. The
          speficic warnings under this heading read
          <computeroutput>Acquisition of lock
          "<replaceable>lock</replaceable>" may be
          redundant</computeroutput>.  Each results links to the expression or annotation
          that is a potentially redundant lock acquisition.
          Class <classname>RedundantLockExample</classname> demonstrates these results, 
          shown in <xref linkend="redundant-lock-results"/>:</para>
          
          <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class RedundantLockExample {

  private int f;
  
  // not redundant
  public synchronized void m() {
    f = 1;
    // redundant
    synchronized (this) {
      f = 2;
    }
  }
  
  public void n() {
    // not redundant
    synchronized (this) {
      f = 3;
      
      // redundant
      synchronized (this) {
        f = 4;
      }
    }
  }
  
  // Not redundant 
  <emphasis>@RequiresLock("L")</emphasis>
  public void o() {
    f = 5;
    
    // redundant for L, but not for MUTEX
    synchronized (this) {
      f = 6;
    }
  }
}</programlisting>
          
          <figure id="redundant-lock-results">
            <title>Assurance results for <classname>RedundantLockExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/lock-assurance-11.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-11.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
          <para>The lock acquisitions on lines 15 and 26 are seen as
          redundant acquisitions of two locks, <structfield>MUTEX</structfield>
          and <structfield>L</structfield>, because the expression
          <parameter>this</parameter> could refer to either one of those
          locks. The acquision on line 38 is only redundant for lock
          <structfield>L</structfield> because the
          <classname>@RequiresLock</classname> precondition on the method
          only requires that specific lock.  Thus, although, the
          expression on line 38 acquires both locks, the acquisition of
          <structfield>MUTEX</structfield> is not redundant.</para>

          <para>JSure warns about redundant lock acquisitions because
          they make it more difficult to understand the program's design
          intent. Ideally, redundant lock acquisitions should be removed
          from the program.  We are careful to say that these
          acquisitions <emphasis>may be</emphasis> redundant because a
          program's design intent can be more complicated than is
          expressable using JSure's annotations, and thus the lock
          acquision may satisfy an intent that has not been
          expressed.</para>
        </sect3>
        
        <sect3 id="unidentifiable-locks">
          <title>unidentifiable lock(s); what is the name of the lock? what state is being protected?</title>
          
          <para>This class of warnings identifies those lock
          acquisitions where JSure is unable to determine that a named
          lock is being acquired. That is, there is no lock declared
          with a <classname>@RegionLock</classname> or
          <classname>@PolicyLock</classname> annotation that can be
          determined to be acquired at the identified locations. There are
          three messages that can appear under this heading:</para>
          
          <variablelist>
            <varlistentry>
              <term id="does-not-name">Lock expression
              "<replaceable>expr</replaceable>" does not name a
              programmer-declared lock; consider declaring the state
              protected by the referenced lock</term>
              
              <listitem><para>The given expression in the identified
              <code>synchronized</code> statement is not
              identifiable as a lock declared in a
              <classname>@RegionLock</classname> or
              <classname>@PolicyLock</classname> annotation.
              </para></listitem>
            </varlistentry>

            <varlistentry>
              <term id="does-not-name-instance">Synchronized method <replaceable>method</replaceable>: "this" is not
              identifiable as a programmer-declared lock</term>
              
              <listitem><para>This identifies a
              non-<code>static</code>
              <code>synchronized</code> method for which the
              receiver (<parameter>this</parameter>) is not identifiable as
              a lock.</para></listitem>
            </varlistentry>

            <varlistentry>
              <term id="does-not-name-static">Synchronized method
              <replaceable>method</replaceable>:
              "<replaceable>Class</replaceable>.class" is not
              identifiable as a programmer-declared lock</term>

              <listitem><para>This identifies a
              <code>static</code>
              <code>synchronized</code> method for which the
              class reference is not identifiable as
              a lock.</para></listitem>
            </varlistentry>
          </variablelist>
          
          <para>Class <classname>UnidentifiableLockExample</classname> demonstrates these
          results, shown in <xref linkend="unidentifiable-lock-results"/>:</para>
          
          <programlisting linenumbering="numbered" startinglinenumber="3">public class UnidentifiableLockExample {
  private final Object lock = new Object();
  
  private static int s;
  
  private int x;
  private int y;
  
  static {
    // Unidentifiable lock expression
    synchronized (UnidentifiableLockExample.class) {
      s = 100;
    }
  }
  
  // Unidentifiable lock expression
  public static synchronized int getS() {
    return UnidentifiableLockExample.s;
  }
  
  // Unidentifiable lock expression
  public synchronized int getX() {
    return x;
  }
  
  public void setX(final int v) {
    // Unidentifiable lock expression
    synchronized (this) {
      x = v;
    }
  }
  
  public int getY() {
    // Unidentifiable lock expression
    synchronized (lock) {
      return y;
    }
  }
  
  public void setY(final int v) {
    // Unidentifiable lock expression
    synchronized (lock) {
      y = v;
    }
  }
}</programlisting>
          
          <figure id="unidentifiable-lock-results">
            <title>Assurance results for <classname>UnidentifiableLockExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/lock-assurance-12.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-12.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
          <para>This class does not have any lock annotations, but
          there are numerous lock acquisitions contained within it.  All
          the points where a lock might be acquired have have a warning
          about the undentifiable nature of the lock.</para>
          
          <para>JSure warns about this situation as way to identify
          potentially missing lock models. For example, the warnings in
          the example can be removed by adding the following annotation to the 
          class:</para>
          
          <programlisting>
@RegionLocks({
  @RegionLock("xLock is this protects x"),
  @RegionLock("yLock is lock protects y"),
  @RegionLock("sLock is class protects s")})
          </programlisting>

        </sect3>
        
        <sect3 id="non-final-locks">
          <title>non-final lock expression(s); analysis cannot determine
          which lock is being acquired</title>

          <para>JSure groups together all warnings about non-final
          expressions in <code>synchronized</code> statements under this heading.
          Each warning has the form <computeroutput>Lock expression "<replaceable>lock</replaceable>" is not final</computeroutput>.
          A <emphasis>final expression</emphasis> is a reference-valued expression that JSure
          can determine refers to the same object no matter where it is
          evaluated within the context of the <code>synchronized</code> statement.
          JSure requires that the lock expression in a <code>synchronized</code>
          statement be final to guarantee that the lock that is acquired
          is the same lock that is needed inside of the statement. The
          <function>test()</function> method of the class
          <classname>NonFinalLockExample</classname> contains two examples
          of non-final lock expressions, see <xref linkend="non-final-lock-results"/>:</para>
          
          <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class NonFinalLockExample {
  private int val;
  
  <emphasis>@RequiresLock("L")</emphasis>
  public int get() {
    return val;
  }

  <emphasis>@RequiresLock("L")</emphasis>
  public void set(final int v) {
    val = v;
  }
  
  public static NonFinalLockExample getNF() {
    return new NonFinalLockExample();
  }
  
  public static void test() {
    NonFinalLockExample nf = new NonFinalLockExample();
    
    // Non-final lock acquisition
    synchronized (nf) {
      int x = nf.get();
      nf = new NonFinalLockExample();
      nf.set(x+1);
    }
    
    // Non-final lock acquisition
    synchronized (getNF()) {
      getNF().set(getNF().get()+1);
    }
  }
}</programlisting>

          <figure id="non-final-lock-results">
            <title>Assurance results for <classname>NonFinalLockExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/lock-assurance-13.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-13.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          
          <para>The expression <code>nf</code> on line 28 is
          considered non-final because the variable
          <varname>nf</varname> is assigned to inside of the
          <code>synchronized</code> statement. This means that the
          object locked by the <code>synchronized</code> statement
          is not the object that needs to be locked to call the method
          <function>set()</function> in the expression
          <code>nf.set(&hellip;)</code> on the following line. The
          situation is worse on line 35: each call to <function>getNF()</function>
          returns a <emphasis>new</emphasis> object.</para>

          <note>
            <para>This example demonstrates why pattern matching is
            insufficient: the above cases would check using a lexical
            scanner because all the object references are made using the
            same expression. But the <emphasis>value</emphasis> of that
            expression also needs to be considered to reach correct
            understanding of the program.</para>
          </note>
        </sect3>
        
        <sect3 id="not-protecting">
          <title>synchronized blocks not protecting any state; what state is being protected?</title>
          
          <para>JSure collects warnings about possibly superfluous
          locking under this heading.  Individual warnings read
          <computeroutput>Locks <replaceable>set of locks</replaceable>
          not needed by body of synchronized block</computeroutput>.
          This warning is an attempt to suggest areas where the lock
          model might be too narrow; that is a lock may protect more
          state than it has been declared to protect.  Class
          <classname>UnusedLockExample</classname>, whose results are shown
          in <xref linkend="not-protecting-results"/>, only declares
          that lock <structfield>L</structfield> protects region
          <structfield>R</structfield>:</para>

          <programlisting linenumbering="numbered" startinglinenumber="8"><emphasis>@Regions({</emphasis>
  <emphasis>@Region("R"),</emphasis>
  <emphasis>@Region("Q")})</emphasis>
<emphasis>@RegionLock("L is this protects R")</emphasis>
public class UnusedLockExample {
  <emphasis>@InRegion("R")</emphasis>
  private int f;
  
  <emphasis>@InRegion("Q")</emphasis>
  private int g;
  
  public synchronized int getF() {
    return f;
  }
  
  public synchronized int getG() {
    return g;
  }
  
  public void setBoth(final int a, final int b) {
    synchronized (this) {
      f = a;
      g = b;
    }
  }
}</programlisting>

          <figure id="not-protecting-results">
            <title>Assurance results for <classname>UnusedLockExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/lock-assurance-14.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-14.png"/>
              </imageobject>
            </mediaobject>
          </figure>

          <para>The JSure results call our attention to method
          <function>getG()</function> because it is
          <code>synchronized</code> but based on the current
          annotations its body does not require any locks.  In this
          case, it is clear that the intent is that <parameter>this</parameter> is to be used
          to protect both fields of the class, so we should modify the
          lock annotation to be <classname>@RegionLock("L is this protects Instance")</classname>.</para>

          <para>This situation often arrises when the class is being annotated
          incrementally: It is first discovered that a particular field
          is being protected by some lock, so the annotation is narrowly
          tailored to that case. Then, it can be discovered that the
          lock protects more state, and so on.</para>

        </sect3>
        
        <sect3>
          <title>calls to methods masquerading as java.util.concurrent.Lock methods</title>
          
          <para>JSure issues warnings when classes similar to the the
          <classname>Lock</classname> and
          <classname>ReadWriteLock</classname> classes are used:</para>
          
          <variablelist>
            <varlistentry>
              <term id="not-juc"><computeroutput>"<replaceable>method</replaceable>" does not call a method from java.util.concurrent.locks.Lock</computeroutput></term>
              <listitem>
                <para>A method named <function>lock</function>,
                <function>tryLock</function>,
                <function>lockInterruptibly</function>, or
                <function>unlock</function> from a class named
                <classname>Lock</classname> that <emphasis>is
                not</emphasis> from the package
                <package>java.util.concurrent.locks</package> is
                called.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term id="not-rw"><computeroutput>"<replaceable>method</replaceable>" does not call a method from java.util.concurrent.locks.ReadWriteLock</computeroutput></term>
              <listitem>
                <para>A method named <function>readLock</function> or
                <function>writeLock</function> from a class named
                <classname>ReadWriteLock</classname> that <emphasis>is
                not</emphasis> from the package
                <package>java.util.concurrent.locks</package> is
                called.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          
          <para>Consider the class <classname>NotJustAnyLockExample</classname> below and its
          results in <xref linkend="not-just-any-locks-results"/>.</para>

          <programlisting linenumbering="numbered" startinglinenumber="3">public class NotJustAnyLockExample {
  public class Lock {
    public void lock() {}
    public void unlock() {}
  }

  public class ReaderWriterLock {
    public java.util.concurrent.locks.Lock readLock() { return null; }
    public java.util.concurrent.locks.Lock writeLock() { return null; }
  }

  
  
  private final ReaderWriterLock rwLock = new ReaderWriterLock();
  private final Lock lock = new Lock();

  
  
  private void doStuff() {
    // do stuff
  }
  
  public void test() {
    lock.lock();
    try {
      doStuff();
    } finally {
      lock.unlock();
    }
  }

  public void testRead() {
    rwLock.readLock().lock();
    try {
      doStuff();
    } finally {
      rwLock.readLock().unlock();
    }
  }
  
  public void testWrite() {
    rwLock.writeLock().lock();
    try {
      doStuff();
    } finally {
      rwLock.writeLock().unlock();
    }
  }
}</programlisting>

          <figure id="not-just-any-locks-results">
            <title>Assurance results for <classname>NotJustAnyLockExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/masquerading-locks.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/masquerading-locks.png"/>
              </imageobject>
            </mediaobject>
          </figure>         
        </sect3>
        
        <sect3>
          <title>mixed java.util.concurrent/intrinsic locking usage(s)</title>
          
          <para>JSure issues warnings when it detects scenarios that indicate 
          that the programmer may be confused about the existence of 
          <package>java.util.concurrent</package> locks in a class.  The class
          <classname>SyncOnJUCLocksExample</classname> below uses 
          <classname>Lock</classname> and <classname>ReadWriteLock</classname> objects
          in <code>synchronized</code> statements.  The Java compiler does not complain
          about this because <emphasis>all</emphasis> objects can be used as a lock.  But this
          usage defeats the purpose of declaring special <package>java.util.concurrent</package>
          locks, and is most likely a mistake.  JSure detects these usages and reports
          warnings, as shown in <xref linkend="juc-sync-results"/>.</para>
          
          <programlisting linenumbering="numbered" startinglinenumber="8">public class SyncOnJUCLocksExample {
  private final Lock lock = new ReentrantLock();
  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
  
  private int v;
  private int w;
  
  public void oops1(final int x) {
    synchronized (lock) {
      v = x;
    }
  }
  
  public void oops2(final int y) {
    synchronized (rwLock) {
      w = y;
    }
  }
}</programlisting>
          
          <figure id="juc-sync-results">
            <title>Assurance results for <classname>SyncOnJUCLocksExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/sync-on-juc-lock.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/sync-on-juc-lock.png"/>
              </imageobject>
            </mediaobject>
          </figure>         
        
          <para>JSure issues warnings of the form <computeroutput
          id="juc-sync">Using a java.util.concurrent.locks lock object
          "<replaceable>lock</replaceable>" in a synchronized
          statement</computeroutput>.  Our example has two of these
          messages:
            <orderedlist>
              <listitem>
                <para>One for the misue of a <classname>Lock</classname>
                object in <function>oops1</function> on line 16.</para>
              </listitem>
              <listitem>
                <para>One for the misuse of a
                <classname>ReadWriteLock</classname> object in
                <function>oops2</function> on line 22.</para>
              </listitem>
            </orderedlist>
          </para>
          
          <para>JSure also generates warnings when an object is used in
          a <code>synchronized</code> statement, and the class of that
          object does not declare (via a
          <classname>@RegionLock</classname> annotation) that the
          receiver is a lock, and the class contains fields with the
          type <classname>java.util.concurrent.locks.Lock</classname> or
          <classname>java.util.concurrent.locks.ReadWriteLocks</classname>.
          JSure can generate two different messages in this case:
            <variablelist>
              <varlistentry>
                <term id="not-a-known-lock-general">The object referenced by
                "<replaceable>expr</replaceable>" is not a known lock,
                but its fields <replaceable>list of fields</replaceable>
                are java.util.concurrent locks</term>
                <listitem>
                  <para>This is a general warning, indicating that the
                  the class of the object referenced by
                  <replaceable>expr</replaceable> does not declare the
                  receiver to be a lock, but that the named fields of
                  the class have the type
                  <classname>java.util.concurrent.locks.Lock</classname>
                  or
                  <classname>java.util.concurrent.locks.ReadWriteLocks</classname>.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term id="not-a-known-lock-specific">The object referenced by
                "<replaceable>expr</replaceable>" is not a known lock,
                but its field "<replaceable>field</replaceable>" is
                declared to be java.util.concurrent lock "<replaceable>lock</replaceable>"</term>
                <listitem>
                  <para>This is a more specific warning, indicating that the
                  the class of the object referenced by
                  <replaceable>expr</replaceable> does not declare the
                  receiver to be a lock, but that the named field of
                  the class has the type
                  <classname>java.util.concurrent.locks.Lock</classname>
                  or
                  <classname>java.util.concurrent.locks.ReadWriteLocks</classname>
                  <emphasis>and</emphasis> the field is declared (in a <classname>@RegionLock</classname> annotation) to be
                  the named lock <replaceable>lock</replaceable>.  This warning appears
                  under the result heading for the lock <replaceable>lock</replaceable>
                  as well as under the general warnings heading.</para>             
                </listitem>
              </varlistentry>
            </variablelist>
            
            The class <classname>NotAKnownLockExample</classname> demonstrates these warnings, shown
            in <xref linkend="not-a-known-lock-result1"/> and
            <xref linkend="not-a-known-lock-result2"/>.  It
            has one general warning, and one specific warning.  The general warning
            for line 21 refers to both fields <structfield>lock1</structfield>
            and <structfield>lock2</structfield> because both have the type 
            <classname>Lock</classname>.  There is a specific warning for
            field <structfield>lock1</structfield>, but not <structfield>lock2</structfield>,
            because there is a <classname>@RegionLock</classname> for <structfield>lock1</structfield> only.
            This specific warning can be seen under the heading for lock <structfield>lock1</structfield>
            as well as under the heading <guilabel>Suggestions and Warnings</guilabel>.
          </para>

          <programlisting linenumbering="numbered" startinglinenumber="8">public class NotAKnownLockExample {
  <emphasis>@RegionLock("L1 is lock1 protects field1")</emphasis>
  private static class C {
    public final Lock lock1 = new ReentrantLock();
    public final Lock lock2 = new ReentrantLock();
    
    public int field1;
    public int field2;
  }
  
  
  
  public void doStuff(final C c) {
    synchronized (c) {
      c.field1 = 1;
    }
  }
}</programlisting>

          <figure id="not-a-known-lock-result1">
            <title>Assurance results for <classname>NotAKnownLockExample</classname></title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/not-a-known-lock-01.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/not-a-known-lock-01.png"/>
              </imageobject>
            </mediaobject>
          </figure>         

          <figure id="not-a-known-lock-result2">
            <title>Assurance results for <classname>NotAKnownLockExample</classname> 2</title>
            <mediaobject>
              <imageobject condition="isHTML">
                <imagedata fileref="images/not-a-known-lock-02.png"/>
              </imageobject>
              <imageobject condition="isFO">
                <imagedata width="100%" scalefit="1" fileref="images/not-a-known-lock-02.png"/>
              </imageobject>
            </mediaobject>
          </figure>         
        </sect3>
      </sect2>
    </sect1>
      
    <sect1 id="thread-effects">
      <title>Thread Effects</title>
      
      <para>Each <classname>@SingleThreaded</classname> annotation creates a new chain of evidence
      under the <guilabel>Thread effects</guilabel> heading in the <guilabel>Verification Status</guilabel>
      view.  The class <classname>ThreadEffectsExample</classname> is used to explore these results:</para>
      
      <programlisting linenumbering="numbered" startinglinenumber="5">public class ThreadEffectsExample {
  private int field;
  
  <emphasis>@Starts("nothing")</emphasis>
  public void goodMethod_Simple() {
    field = 10;
  }
  
  <emphasis>@Starts("nothing")</emphasis>
  public int goodMethod_Complex() {
    goodMethod_Simple();
    return field + 5;
  }
  
  <emphasis>@Starts("nothing")</emphasis>
  public void badMethod_Simple(final Thread t) {
    // BAD: we start a thread
    t.start();
  }
  
  <emphasis>@Starts("nothing")</emphasis>
  public void badMethod_Indirect1(final Thread t) {
    badMethod_Simple(t);
  }
  
  <emphasis>@Starts("nothing")</emphasis>
  public void badMethod_Indirect2() {
    unannotated_method();
  }
  
  // good, but not declared to start nothing
  public void unannotated_method() {
    field = 20;
  }
}</programlisting>

      <para>Two of these annotations assure, while three of them fail to assure:</para>
      
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/thread-effects-01.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/thread-effects-01.png"/>
        </imageobject>
      </mediaobject>
      
      <para>The thread effects analysis checks that a method annotated
      with <classname>@Starts("nothing")</classname></para>

      <itemizedlist spacing="compact">
        <listitem><para>Does not invoke the <function>start()</function>
        on a thread object</para></listitem>

        <listitem><para>Only invokes methods/constructors annotated with
        <classname>@Starts("nothing")</classname></para></listitem>
      </itemizedlist>
      
      <para>Thus, there are four result messages:</para>
      
      <variablelist>
        <varlistentry>
          <term id="no-threads-started">No threads started within <replaceable>method</replaceable></term>
          <listitem><para>The body of the annotated method does not
          directly start any threads.  This does
          <emphasis>not</emphasis> mean that the methods/constructors
          invoked by the method do not start any threads; each
          method/constructor call is handled
          individually.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term id="thread-started">Thread effect declaration prohibits: <replaceable>call to <function>start()</function></replaceable></term>
          <listitem><para>The body of the annotated method starts a
          thread.  This result links to the <function>start()</function>
          method call.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term id="call-starts-nothing">Call "<replaceable>method call</replaceable>" promises to start nothing</term>
          <listitem><para>The annotated method calls a method that is
          annotated with <classname>@Starts("nothing")</classname>.  This
          result starts a new chain of evidence indicating whether the
          called method is assured or not.  This results links to the
          method call in the method body.</para></listitem>
        </varlistentry>

        <varlistentry>
          <term id="call-does-not-promise">Call "<replaceable>method call</replaceable>" does not promise to start nothing</term>
          <listitem><para>The annotated emehtod invokes a method is not
          annoated with <classname>@Starts("nothing")</classname>.  This is
          an assurance failure because the called method might start a
          thread.  The result links to the offending method
          call.</para></listitem>
        </varlistentry>
      </variablelist>
      
      <sect2 id="thread-effects-good">
        <title>Positive Assurance</title>

        <para>The simple method <function>goodMethod_Simple()</function>
        assures.  Its body consists of a single field assignment that
        obviously does not invoke <function>Thread.start()</function>, or
        any other method.  Thus, the chain of evidence for the method is
        a simple <computeroutput>No threads started within
        goodMethod_Simple()</computeroutput>.</para>

        <para>The method <function>goodMethod_Complex()</function> calls
        the method <function>goodMethod_Simple()</function>, which, as we
        discuss above, assures.  So the result <computeroutput>Call
        "this.goodMethod_Simple" promises to start
        nothing</computeroutput> is decorated with the icon
        <guiicon><inlinegraphic
        fileref="images/plus-plus.jpg"/></guiicon> indicating deep
        assurance.</para>
      </sect2>
      
      <sect2 id="thread-effects-bad">
        <title>Negative Assurance</title>

        <para>The method <function>badMethod_Simple()</function> does
        exactly what it is not supposed to do: invokes the
        <function>start()</function> method of the
        <classname>Thread</classname> object passed to it.  Its chain of
        evidence is thus the single negative result
        <computeroutput>Thread effect declaration prohibits:
        t.start()</computeroutput>.</para>

        <para>Method <function>badMethod_Indirect1()</function> calls the
        method <function>badMethod_Simple()</function>.  The method
        <emphasis>does not</emphasis> start any threads itself, so it
        has a <computeroutput>No threads started within
        badMethod_Indirect1(java.lang.Thread)</computeroutput> result. 
        Because the method <function>badMethod_Simple()</function> is
        annotated with <classname>@Starts("nothing")</classname>, there is
        also a <computeroutput>Call "this.badMethod_Simple(t)" promises
        to start nothing</computeroutput> result.  But because, as we
        say above, this method does not assure, this result is decorated
        with the icon <guiicon><inlinegraphic
        fileref="images/plus-x.jpg"/></guiicon>. Overall, the annotation
        on <function>badMethod_Indirect1()</function> fails to
        assure.</para>

        <para>Method <function>badMethod_Indirect2()</function> calls the
        method <function>unannotated_method()</function> that does not
        have a <classname>@Starts("nothing")</classname> annotation.  This
        call prevents assurance of the method because the called method
        could start a thread.  Analysis produces the result
        <computeroutput>Call "this.unannotated_method" does not promise
        to start nothing</computeroutput>.</para>
      </sect2>
      
    </sect1>
    
    <sect1 id="result-index">
      <title>Index of JSure Results</title>
        
      <itemizedlist>
        <listitem><para><link
        linkend="acquires-different"><replaceable>acquires</replaceable>
        call has a different number of matching unlock() calls along
        different control paths</link></para></listitem>

        <listitem><para><link linkend="acquires-match"><replaceable>acquires</replaceable> call has matching
        unlock() call at line <replaceable>line</replaceable></link></para></listitem>

        <listitem><para><link linkend="acquires-no-match"><replaceable>acquires</replaceable> call has no matching
        unlock() calls</link></para></listitem>

        <listitem><para><link
        linkend="checked-by"><replaceable>effect<subscript>1</subscript>
        </replaceable> checked by
        <replaceable>effect<subscript>2</subscript></replaceable></link>
        </para></listitem>

        <listitem><para><link
        linkend="constructor-rule"><replaceable>effect</replaceable>
        checked by constructor rule: writes to a newly created object
        are invisible</link></para></listitem>

        <listitem><para><link linkend="not-juc">"<replaceable>method</replaceable>" does not call a
        method from java.util.concurrent.locks.Lock</link></para></listitem>

        <listitem><para><link linkend="not-rw">"<replaceable>method</replaceable>" does not call a
        method from
        java.util.concurrent.locks.ReadWriteLock</link></para></listitem>

        <listitem><para><link
        linkend="not-accounted-for"><replaceable>effect</replaceable>
        not accounted for by declared effect(s)</link></para></listitem>

        <listitem><para><link linkend="redundant-locks">Acquisition of
        lock "<replaceable>lock</replaceable>" may be
        redundant</link></para></listitem>

        <listitem><para><link linkend="on-behalf-of">Analyzed on behalf
        of constructor
        "<replaceable>constructor</replaceable>"</link></para></listitem>

        <listitem><para><link linkend="call-does-not-promise">Call "<replaceable>method call</replaceable>" does not
        promise to start nothing</link></para></listitem>

        <listitem><para><link linkend="call-starts-nothing">Call "<replaceable>method call</replaceable>" promises to
        start nothing</link></para></listitem>

        <listitem><para><link linkend="trivially-satisfy">Empty effects
        trivially satisfy declared effects</link></para></listitem>

        <listitem><para><link linkend="todo">TO DO: Field Declaration:
        {0}</link></para></listitem>

        <listitem><para><link linkend="possibly-shared-field">Field reference "<replaceable>field ref</replaceable>" may
        be to a shared unprotected object</link></para></listitem>

        <listitem><para><link linkend="intrinsic-lock-held">Intrinsic lock <replaceable>lock</replaceable> is
        held</link></para></listitem>

        <listitem><para><link linkend="juc-lock-held">java.util.concurrent lock
        "<replaceable>lock</replaceable>" is held</link></para></listitem>

        <listitem><para><link linkend="todo">TO DO: Lock "{0}" held as "{2}"
        when accessing {1}</link></para></listitem>

        <listitem><para><link linkend="todo">TO DO: Lock "{0}" held as "{2}"
        when invoking {1}; precondition
        satisfied</link></para></listitem>

        <listitem><para><link linkend="todo">TO DO: Lock "{0}" held as "{2}"
        when invoking {1}</link></para></listitem>

        <listitem><para><link linkend="protected-field-accesses">Lock
        "<replaceable>lock</replaceable>" held when accessing <replaceable>field</replaceable></link></para></listitem>

        <listitem><para><link linkend="preconditions-satisfied">Lock
        "<replaceable>lock</replaceable>" held when invoking <replaceable>method</replaceable>; precondition
        satisfied</link></para></listitem>

        <listitem><para><link linkend="held-when-invoking">Lock "<replaceable>lock</replaceable>" held when
        invoking <replaceable>method</replaceable></link></para></listitem>

        <listitem><para><link linkend="unprotected-field-accesses">Lock
        "<replaceable>lock</replaceable>" not held when accessing <replaceable>field</replaceable></link></para></listitem>

        <listitem><para><link linkend="preconditions-unsatisfied">Lock
        "<replaceable>lock</replaceable>" not held when invoking <replaceable>method</replaceable>; precondition
        unsatisfied</link></para></listitem>

        <listitem><para><link linkend="not-held-when-invoking">Lock "<replaceable>lock</replaceable>" not held when
        invoking <replaceable>method</replaceable></link></para></listitem>

        <listitem><para><link linkend="todo">TO DO: Lock "{0}", needed for
        accessing {1}, is not held within the anonymous class and cannot
        be resolved in the calling context; lock must be held within the
        anonymous class</link></para></listitem>

        <listitem><para><link linkend="does-not-name">Lock expression
        "<replaceable>expr</replaceable>" does not name a programmer-declared lock; consider
        declaring the state protected by the referenced
        lock</link></para></listitem>

        <listitem><para><link linkend="non-final-locks">Lock expression
        "<replaceable>expr</replaceable>" is not final</link></para></listitem>

        <listitem><para><link linkend="todo">TO DO: Lock specification "{0}"
        cannot be resolved in the calling context for {1}; precondition
        unsatisfied</link></para></listitem>

        <listitem><para><link linkend="not-protecting">Locks <replaceable>set of locks</replaceable> not
        needed by body of synchronized block</link></para></listitem>

        <listitem><para><link linkend="indirect-evidence">Method effect <replaceable>effect</replaceable> affects
        region <replaceable>region</replaceable> of <replaceable>field ref</replaceable> which is aggregated into region
        <replaceable>region&prime;</replaceable></link></para></listitem>

        <listitem><para><link linkend="no-threads-started">No threads started within
        <replaceable>method</replaceable></link></para></listitem>

        <listitem><para><link linkend="parameter">Parameter
        "<replaceable>formal</replaceable>" bound to
        "<replaceable>actual</replaceable>"</link></para></listitem>

        <listitem><para><link linkend="possibly-shared-receiver">Receiver "<replaceable>field ref</replaceable>" may be a
        shared unprotected object</link></para></listitem>

        <listitem><para><link linkend="good-return">Return statement
        correctly returns lock "<replaceable>lock</replaceable>"</link></para></listitem>

        <listitem><para><link linkend="returns-lock-bad">Return
        statement expected to return lock "<replaceable>lock</replaceable>"</link></para></listitem>

        <listitem><para><link
        linkend="singleThreaded-escaping">single-threaded constructor has
        possibly escaping receiver</link></para></listitem>

        <listitem><para><link
        linkend="singledThreaded-supported">single-threaded constructor
        supported</link></para></listitem>

        <listitem><para><link
        linkend="does-not-name-static">Synchronized method <replaceable>method</replaceable>:
        "<replaceable>Class</replaceable>.class" is not identifiable as a programmer-declared
        lock</link></para></listitem>

        <listitem><para><link
        linkend="does-not-name-instance">Synchronized method <replaceable>method</replaceable>: "this"
        is not identifiable as a programmer-declared
        lock</link></para></listitem>

        <listitem><para><link linkend="not-a-known-lock-general">The
        object referenced by "<replaceable>expr</replaceable>" is not a
        known lock, but its fields <replaceable>list of
        fields</replaceable> are java.util.concurrent
        locks</link></para></listitem>

        <listitem><para><link linkend="not-a-known-lock-specific">The
        object referenced by "<replaceable>expr</replaceable>" is not a
        known lock, but its field "<replaceable>field</replaceable>" is
        declared to be java.util.concurrent lock
        "<replaceable>lock</replaceable>"</link></para></listitem>

        <listitem><para><link linkend="thread-started">Thread effect declaration
        prohibits: <replaceable>call to start()</replaceable></link></para></listitem>

        <listitem><para><link linkend="release-different">unlock() call has a
        different number of matching lock() calls along different
        control paths</link></para></listitem>

        <listitem><para><link linkend="release-match">unlock() call has matching
        <replaceable>acquires</replaceable> call at line <replaceable>line</replaceable></link></para></listitem>

        <listitem><para><link linkend="release-no-match">unlock() call has no
        matching lock() calls</link></para></listitem>

        <listitem><para><link linkend="juc-sync">Using a
        java.util.concurrent.locks lock object "<replaceable>lock</replaceable>" in a syncronized
        statement</link></para></listitem>
      </itemizedlist>
        
      <para id="todo">TO DO: To be done</para>
    </sect1>
  </chapter>

  <chapter id="reference">
    <title>Reference</title>
    <sect1>
      <title>The JSure menu</title>
      <para>The JSure menu appears as an item on the Eclipse workspace
      main menu.</para>
    </sect1>
    <sect1>
      <title>The Code Verification perspective</title>
      <para>The Code Verification perspective organizes the Eclipse
      workbench to show views which will help you to interact with
      tool findings.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Release notes</title>
    <para>For each release of JSure there are new and noteworthy
    features to try out, and known limitations to avoid or
    workaround. These are presented in the sections below for each
    released version of JSure.</para>
    <sect1>
      <title>JSure version 1.0</title>
      <para>This section describes the 1.0 release of JSure.</para>
      <sect2>
	<title>New and Noteworthy</title>
	<para>This section describes new and noteworthy features in this
	version of JSure.</para>
      </sect2>
      <sect2>
	<title>Known Problems</title>
	<para>This section describes known bugs and limitations in this
	version of JSure.</para>
      </sect2>
    </sect1>
  </chapter>
</book>
