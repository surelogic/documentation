<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book id="jsure-examples" lang="en-US">
  <title>JSure User Guide</title>
  <subtitle>How to use and configure the JSure Eclipse client</subtitle>
  <bookinfo>
    <copyright>
      <year>2008</year>
      <holder>SureLogic, Inc.</holder>
    </copyright>
    <legalnotice>
      <para>The authors and publishers have taken care in the
      preparation of this documentation, but make no expressed or
      implied warranty of any kind and assume no responsibility for
      errors and omissions. No liability is assumed for incidental or
      consequential damages in connection with or arising out of the use
      of the information or programs herein.</para>
    </legalnotice>
    <pubdate>Version 1.0&mdash;January 2009</pubdate>
  </bookinfo>

  <chapter id="preface">
    <title>Preface</title>
    <sect1>
      <title>Audience</title>
      <para>This document is intended for Java developers who want to
      use the JSure tool within the Eclipse Java IDE. We assume
      that the reader understands both the Java programming language and
      the use of Eclipse for Java development.</para>
    </sect1>
    <sect1>
      <title>Contact information</title>
      <para>For technical support or other questions, please
      contact:</para>
      <para><email>support@surelogic.com</email></para>
      <para>5808 Forbes Avenue, Pittsburgh, PA 15217-1602</para>
    </sect1>
  </chapter>

  <chapter id="getting-started">
    <title>Getting started</title>
    <sect1>
      <title>Introduction</title>

      <para><emphasis>What is JSure?</emphasis> TODO</para>
    </sect1>

    <sect1>
      <title>Quick start: How to scan your code and start adding design
      intent</title>

      <para>This section assumes that you have installed JSure. If you
      see a <guimenu>JSure</guimenu> menu item on your Eclipse main menu
      then you can assume JSure has been properly installed.</para>
    </sect1>

    <sect1>
      <title>Tutorial: Verifying BoundedFIFO</title>
    
      <para>This example walks through the complete assurance of a
      simple class and its usage. That is, it demonstrates that is not
      always enough to assure the implementation of a class:
      <emphasis>sometimes the clients of a class must conform to a
      specific behavior as well</emphasis>. This example focuses on
      two classes (plus one auxillary class):</para>
    
      <variablelist>
        <varlistentry>
          <term><varname>BoundedFIFO</varname></term>
          <listitem><para>The "thread safe" class.  See <xref
          linkend="BoundedFIFO.java"/></para></listitem>
        </varlistentry>
      
        <varlistentry>
          <term><varname>BlockingFIFO</varname></term>
          <listitem><para>The client code.  See <xref
          linkend="BlockingFIFO.java"/></para></listitem>
        </varlistentry>
      
        <varlistentry>
          <term><varname>LoggingEvent</varname></term>
          <listitem><para>The class of objects stored in the queue.  See
          <xref
          linkend="LoggingEvent.java"/></para></listitem>
        </varlistentry>
      </variablelist>
    
      <para>The class <varname>BoundedFIFO</varname> is taken from the
      <application>Apache Log4J</application> project. The class
      <varname>BlockingFIFO</varname> we wrote based on actual client code
      in <application>Log4J</application>.</para>

      <para>This example shows off basic features of assuring Java
      lock models using Java intrinsic lock objects:</para>
    
      <itemizedlist>
        <listitem><para><varname>@RegionLock</varname></para></listitem>
        <listitem><para><varname>@RequiresLock</varname></para></listitem>
        <listitem><para><varname>@SingleThreaded</varname></para></listitem>
        <listitem><para><varname>@Borrowed</varname></para></listitem>
        <listitem><para><varname>@Unique</varname></para></listitem>
        <listitem><para><varname>@Aggregate</varname></para></listitem>
        <listitem><para><varname>@Promise</varname></para></listitem>
      </itemizedlist>
    
      <figure id="BoundedFIFO.java">
        <title>Initial Source Code for class <varname>BoundedFIFO</varname></title>
      
        <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  LoggingEvent[] buf;
  
  int numElts = 0;
  int first = 0;
  int next = 0;
  int size;

  /**
   * Instantiate a new BoundedFIFO with a maximum size passed as argument.
   *
   * @param size Maximum size of the BoundedFIFO created.
   */
  public BoundedFIFO(int size) {
    if (size &lt; 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
  }

  /**
   * Get the first element in the buffer. Returns &lt;code&gt;null&lt;/code&gt; if
   * there are no elements in the buffer.
   */
  public LoggingEvent get() {
    if (numElts == 0)
      return null;
    LoggingEvent r = buf[next];
    if (++first == size)
      first = 0;
    numElts--;
    return r;
  }

  /**
   * Place a {@link LoggingEvent} in the buffer. If the buffer is full  then
   * the event is &lt;b&gt;silently dropped&lt;/b&gt;. It is the caller's  responsibility
   * to make sure that the buffer has free space.
   * 
   * @param o The logging event added into the buffer.
   */
  public void put(LoggingEvent o) {
    if (numElts != size) {
      buf[next] = o;
      if (++next == size)
        next = 0;
      numElts++;
    }
  }

  /** 
   * Get the maximum size of the buffer.
   */
  public int getMaxSize() {
    return size;
  }

  /**
   * Get the number of elements in the buffer. This number is guaranteed to be
   * in the range 0 to &lt;code&gt;maxSize&lt;/code&gt; (inclusive).
   */
  public int length() {
    return numElts;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if there is just one element in the buffer. In
   * other words, if there were no elements before the last {@link #put}
   * operation completed.
   */
  public boolean wasEmpty() {
    return numElts == 1;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the number of elements in the buffer plus 1
   * equals the maximum buffer size, returns &lt;code&gt;false&lt;/code&gt; otherwise.
   */
  public boolean wasFull() {
    return numElts + 1 == size;
  }

  /**
   * Returns &lt;code&gt;true&lt;/code&gt; if the number of elements in the buffer equals
   * the maximum buffer size, returns &lt;code&gt;false&lt;/code&gt; otherwise.
   */
  public boolean isFull() {
    return numElts == size;
  }
}
        </programlisting>
      </figure>

      <figure id="BlockingFIFO.java">
        <title>Initial Source Code for class
        <filename>BlockingFIFO</filename></title>
      
        <programlisting>
          <![CDATA[
public class BlockingFIFO {
  private final BoundedFIFO fifo;;

  public BlockingFIFO(int size) {
    fifo = new BoundedFIFO(size);
  }

  public void put(LoggingEvent e) {
    synchronized (this) {
      while (fifo.isFull()) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      fifo.put(e);
      if (fifo.wasEmpty()) {
        fifo.notify();
      }
      fifo.put(e);
      fifo.put(e);
    }
  }

  public LoggingEvent get() {
    synchronized (fifo) {
      LoggingEvent e;
      while (fifo.length() == 0) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      e = fifo.get();
      if (fifo.wasFull()) {
        fifo.notify();
      }
      return e;
    }
  }

  public int length() {
    synchronized (fifo) {
      return fifo.length();
    }
  }
}
          ]]>
        </programlisting>
      </figure>

      <figure id="LoggingEvent.java">
        <title>Initial Source Code for class <varname>BlockingFIFO</varname></title>
      
        <programlisting>
          <![CDATA[
public class LoggingEvent { 
  /* Empty: The contents of this class are not interesting 
   * for our example.
   */
}
          ]]>
        </programlisting>
      </figure>
    
      <sect2 id="declaring-protected-state">
        <title>Declaring Protected State</title>
      
        <para>The <varname>BoundedFIFO</varname> class is a buffer
        meant to be shared between two threads. It obviously must be
        made thread-safe. The usual assumption is that an object
        protects its own state.  In <xref
        linkend="BoundedFIFO.java"/> the class is already
        annotated with this assumption:</para>
      
        <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  &hellip;
}
        </programlisting>

        <para>With this single annotation, analysis by JSure produces
        two main concurrency results, mostly indicating that the
        annotation is not assured, and a few warnings.  There are 27
        unprotected field accesses for <varname>BufLock</varname>, and
        no protected field accesses:</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO1.png"/>
          </imageobject>
        </mediaobject>
      </sect2>

      <sect2 id="declaring-lock-preconditions">
        <title>Declaring Lock Preconditions</title>
    
        <para>Either this class is horribly broken or something else
        is going on.  By double clicking on any of the errors in the
        view, we can focus on the source line in
        <varname>BoundedFIFO</varname>. A quick inspectiion of the
        class reveals that it does not acquire the lock anywhere.  So
        we look at its clients by viewing the call chain, in this case
        by viewing the call hierarchy of method
        <varname>get()</varname> (Select the method
        <varname>get()</varname> in the "Outline" view and then choose
        <menuchoice><guimenuitem>Open Call
        Hierarchy</guimenuitem></menuchoice> in the context menu).  We
        see that the client, <varname>BlockingFIFO</varname> acquires
        the lock on the <varname>BoundedFIFO</varname> object before
        invoking any of the methods on the
        <varname>BoundedFIFO</varname> object, so we decide that the
        intent is that the caller should acquire the lock before
        calling any of the methods of
        <varname>BoundedFIFO</varname>.</para>

        <para>To add this intent to <varname>BoundedFIFO</varname>, we
        need to add the lock precondition
        <varname>@RequiresLock("BufLock")</varname> to all the methods
        of the class.  We can do this in a single annotation on the
        class itself by using a <emphasis>scoped promise</emphasis> to
        add the annotation to all the methods of the class:</para>
    
        <programlisting>
 @RegionLock("BufLock is this protects Instance")
 <emphasis>@Promise("'@RequiresLock BufLock' for *(**)")</emphasis>
 public class BoundedFIFO {
  &hellip;
 }
        </programlisting>  

        <para>After adding the annotation we save (and thus reanalyze
        the project).</para>
      </sect2>  
    
      <sect2 id="wrong-lock">
        <title>Wrong Lock</title>
      
        <para>There is now a "scoped promises" heading, and we can see
        all the places where our <varname>@Promise</varname>
        annotation added <varname>@RequiresLock</varname>
        annotations. Only 4 out of the 7 are currently
        satisfied:</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO2.png"/>
          </imageobject>
        </mediaobject>
      
        <para>Looking at the chain of evidence for the call to
        <varname>isFull()</varname>, we see that the caller is
        confused and is synchronized on <varname>this</varname> (as
        evidenced by the caller holding the lock "this.MUTEX"):</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO3.png"/>
          </imageobject>
        </mediaobject>

        <para>But in the context of the caller,
        <varname>BlockingFIFO</varname>, <varname>this</varname>
        refers to the <varname>BlockingFIFO</varname> object, not the
        <varname>BoundedFIFO</varname> object that is correctly
        refered to by <varname>fifo</varname>. The
        <varname>synchronized</varname> statement in method
        <varname>isFull()</varname> needs to be changed:</para>

        <programlisting>
 public void put(LoggingEvent e) {
   synchronized (<emphasis>fifo</emphasis>) {
     &hellip;
   }
 }
        </programlisting>
      </sect2>
    
      <sect2 id="single-threaded-constructor">
        <title>Single Threaded Constructor</title>

        <para>There are still five unprotected field accesses. These
        all point to either field initializers in field declarations
        or in the constructor: </para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO4.png"/>
          </imageobject>
        </mediaobject>
      
        <para>Because the lock on the <varname>BoundedFIFO</varname>
        object is not held during construction, we need to make sure
        that during construction a reference to the object cannot be
        leaked to another thread. Note that we cannot require the
        caller of the constructor to hold the lock because the object
        doesn't exist yet!  In general, we cannot use
        <varname>synchronized</varname> blocks in the constructor to
        protect the state during construction because we cannot create
        a single atomic block: there would have to be multiple
        distinct <varname>synchronized</varname> blocks in the
        constructor and in the constructors of any subclasses. But if
        we can guarantee that the thread that invokes the constructor
        is the only thread that can access the newly created object
        during the life of the invoked constructor, we can also be
        assured there will be no race conditions involving the
        object's fields during construction. We use a pair of
        annotations on the constructor to declare this intent:</para>

        <programlisting>
 <emphasis>@SingleThreaded</emphasis>
 <emphasis>@Borrowed("this")</emphasis>
 public BoundedFIFO(int size) {
   &hellip;
 }
        </programlisting>
      
        <para>The first declares that no new threads are starting
        during the execution of the constructor.  The second that no
        aliases to the newly constructed object will be created during
        the execution of the constructor.  The assurance of the
        <varname>@SingleThreaded</varname> annotation actually depends
        in part on the assurance of the <varname>@Borrowed</varname>
        annotation.</para>

        <para>Save and reanalyze. The model now assures:</para>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO4-1.png"/>
          </imageobject>
        </mediaobject>
      
        <sect3 id="deep-analysis">
          <title>Deep Analysis</title>
        
          <para>As stated above, the assurance of
          <varname>@SingleThreaded</varname> depends on the assurance
          of <varname>@Borrowed("this")</varname> on the
          constructor. We can see this by</para>
        
          <itemizedlist>
            <listitem><para>Removing the <varname>@Borrowed</varname>
            annotation.</para></listitem>
            <listitem><para>Changing the code to be inconsistent with the
            annotation.</para></listitem>
          </itemizedlist>

          <para>If we remove the <varname>@Borrowed</varname>
          annotation, the assurance now fails:</para>
        
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/BoundedFIFO4-2.png"/>
            </imageobject>
          </mediaobject>

          <para>Here we see that the 27 protected field accesses
          heading has a red X because assurance of some of the
          accesses depends on the constructor being single-threaded,
          and the <varname>@SingleThreaded</varname> annotation is not
          assured.</para>

          <para>We can reinstate the <varname>@Borrowed</varname>
          annotation and instead make the code inconsistent by
          changing the constructor to alias the receiver:</para>
       
          <programlisting>
@RegionLock("BufLock is this protects Instance")
@Promise("'@RequiresLock BufLock' for *(**)")
public class BoundedFIFO {
  &hellip;
  <emphasis>static BoundedFIFO foo;</emphasis>

  @SingleThreaded
  @Borrowed("this")
  public BoundedFIFO(int size) {
    if (size &lt; 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
    
    <emphasis>foo = this;</emphasis>
  }
  &hellip;
}
          </programlisting>
        
          <para>Again, we see that assurance fails:</para>

          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/BoundedFIFO4-3.png"/>
            </imageobject>
          </mediaobject>
        
          <para>In this case, we can see that the assurance of
          <varname>@SingleThreaded</varname> fails because the
          <varname>@Borrowed</varname> annotation is violated by the
          code at line 59.</para>
        </sect3>
      
        <sect3 id="deeper-analysis">
          <title>Deeper Analysis</title>
        
          <para>The analysis used to assure
          <varname>@Borrowed</varname> is sophisticated, and it does
          allow temporary local aliases to the receiver.  If the
          constructor were instead</para>
        
          <programlisting>
@SingleThreaded
@Borrowed("this")
public BoundedFIFO(int size) {
  if (size &lt; 1)
    throw new IllegalArgumentException();
  this.size = size;
  buf = new LoggingEvent[size];
    
  <emphasis>BoundedFIFO local = this;</emphasis>
}
          </programlisting>
        
          <para>then the class would still assure because</para>
        
          <itemizedlist>
            <listitem><para>The alias to <varname>this</varname> in
            <varname>local</varname> is never itself aliased to a global
            location.</para></listitem>
            <listitem><para>The alias disappears when the constructor finishes
            executing.</para></listitem>
          </itemizedlist>
        
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/BoundedFIFO4-4.png"/>
            </imageobject>
          </mediaobject>
        </sect3>
      </sect2>
    
      <sect2 id="aggregated-state">
        <title>Aggregated State</title>
      
        <para>We now have no red X's, but we still have 2 warnings
        about references to possibly shared objects:</para>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO5.png"/>
          </imageobject>
        </mediaobject>

        <para>These 2 warnings refer to access to the contents of the
        array referenced by the field <varname>buf</varname>. This
        array is an object separate from the
        <varname>BoundedFIFO</varname> object and is not protected by
        the lock protecting the fields of the
        <varname>BoundedFIFO</varname> object. We can extend
        protection to the contents of the array by declaring the array
        reference to be <varname>@Unique</varname>&mdash;no object but
        the <varname>BoundedFIFO</varname> object can hold a reference
        to it&mdash;and then by declaring that the state of the array
        is part of the state of the <varname>BoundedFIFO</varname>
        object:</para>
      
        <programlisting>
       @RegionLock("BufLock is this protects Instance")
 @Promise("'@RequiresLock BufLock' for *(**)")
 public class BoundedFIFO {
   <emphasis>@Unique</emphasis>
   <emphasis>@Aggregate("Instance into Instance")</emphasis>
   LoggingEvent[] buf;
   &hellip;
 }
        </programlisting>
      
        <para>Now, as part of the state of the
        <varname>BoundedFIFO</varname> object, the array object
        referenced by <varname>buf</varname> is also protected by the
        lock that protects that state of the buffer.</para>

        <para>Aftering saving (and reanalyzing) we can see the effects
        of this annotation: there are now "29 protected field
        accesses", up from 27. This is because the two array
        dereferences are now counted as protected accesses (lines 71
        and 89):</para>
      
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO5b.png"/>
          </imageobject>
        </mediaobject>      
      </sect2>
    
      <sect2 id="assured">
        <title>Assurance Acheived</title>
      
        <para>The project is now fully assured:</para>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/BoundedFIFO6.png"/>
          </imageobject>
        </mediaobject>      
      </sect2>
    </sect1>
  </chapter>

  <chapter id="understanding-assurance-output">
    <title>Understanding JSure Assurance Output</title>
    
    <para>This chapter descibes using examples the wide variety of
    messages that appear in the JSure assurance output.</para>
    
    <sect1 id="effects-assurance">
      <title>Effects Assurance</title>
      
      <para>This discussion of effects assurance results is based
      on assuring the class <varname>EffectsExample</varname>. This class does absolutely
      nothing useful except to demonstrate the various effects assurance
      results.</para>
      
      <figure id="EffectsExample.java">
        <title>The class <varname>EffectsExample</varname>.</title>
      
        <programlisting>
/**
 * This is a simple class that exists only to show off the 
 * assurance results the Effects Assurance can produce.
 */
public class EffectsExample {
  private int f1;
  private int f2;
  private int f3;

  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }

  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }

  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }

  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }

  /**
   * Indirectly bad!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad();
  }

  /**
   * Missing effects!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad() {
    return getSum() + doesAnything();
  }
}
        </programlisting>
      </figure>
      
      <para>The results of effects assurance are displayed under the
      top-level heading <guilabel>Effects</guilabel> in the
      <guilabel>Verification Status</guilabel> view.  Under this heading
      is a subheading for each method and constructor that is annotated
      with <varname>@RegionEffects</varname>. Each entry is marked with
      either a green plus <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> or a red X
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>
      indicating whether the effects annotation has been positively or
      negatively assured, respectively.</para>
      
      <para>In our example, the the methods <varname>bad()</varname> and
      <varname>indirectlyBad()</varname> fail to assure, while the
      methods <varname>getSum()</varname>, <varname>update()</varname>,
      <varname>doesAnything()</varname>, and the constructor
      <varname>EffectsExample()</varname> assure.</para>
      
      <mediaobject>
        <imageobject role="html">
          <imagedata fileref="images/effects-assurance-01.png"/>
        </imageobject>
      </mediaobject>
      
      <para>There are four kinds of results that can appear as 
      evidence for and children of the promise drops:</para>
      
      <variablelist>
        <varlistentry>
          <term><replaceable>effect</replaceable> not accounted for by
          declared effect(s)</term>
          <listitem><para>The given effect of the method/constructor
          implementation is not accounted for by any of the declared
          effects of the method/constructor. That is, the
          method/constructor implementation affects more state than it
          declares it does.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Empty effects trivially satisfy declared effects</term>
          <listitem><para>The method/constructor has no effects at all
          and thus trivially satisfies its declared effects.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><replaceable>effect<subscript>1</subscript></replaceable> checked by
          <replaceable>effect<subscript>2</subscript></replaceable></term>
          <listitem><para>The particular effect of the
          method/constructor implemenation, <replaceable>effect<subscript>1</subscript></replaceable>, is accounted for by
          the particular declared effect <replaceable>effect<subscript>2</subscript></replaceable>. Often, the
          implementation effect is more specific than the declared
          effect, i.e., it affects a region that is included in the
          region of the declared effect.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><replaceable>effect</replaceable> checked by constructor rule: writes to a newly
          created object are invisible</term>
          <listitem><para>The particular effect of the constructor
          implemenation is accounted for by a special rule. Constructors
          do not need to report any effects they have on the object
          being constructed because these effects are invisible to the
          caller of the constructor (the object doesn't exist before the
          constructor was called).</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The meanings of these results are further elaborated in
      the discussion below.</para>

      <sect2 id="simple-positive-assurances">
        <title>Simple Positive Assurances</title>
        
        <para>Let us examine the assurance results for <varname>doesAnything</varname>,
        <varname>getSum()</varname>, and <varname>EffectsExample()</varname> in more detail.
        Their chains of evidence expand as follows</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/effects-assurance-02.png"/>
          </imageobject>
        </mediaobject>
        
        <sect3 id="doesAnything">
          <title>Method <varname>doesAnything()</varname></title>
          
          <para>This method declares that it could read or write anything
          (<varname>@RegionEffects("writes java.lang.Object:All")</varname>),
          but in fact its implementation has no effects at all:</para>
          
          <programlisting>
  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }
          </programlisting>
          
          <para>Thus, the method assures and the result <computeroutput>"Empty effects
          trivially satisfy declared effects"</computeroutput> appears as evidence for
          the assurance of the declared effects.</para>
        </sect3>

        <sect3 id="getSum">
          <title>Method <varname>getSum()</varname></title>
          
          <para>Method getSum has the following implementation:</para>
          
          <programlisting>
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }
          </programlisting>

          <para>This method declares that could read any of the instance
          fields of the reciever (<varname>"reads instance"</varname>,
          really a shorthand for <varname>"reads
          this:Instance"</varname>). The body of the method reads the
          three fields <varname>f1</varname>, <varname>f2</varname>, and
          <varname>f3</varname>. Thus, there are three effects that need
          to be accounted for in order for the declared effects to be
          assured. We see this in the three result drops that appear as
          evidence for the method's declared effects:</para>
          
          <itemizedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f2" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f3" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
            </listitem>
          </itemizedlist>

          <para>In particular, there is one result for each
          implementation effect of the method, and the result is
          tagged to the line of code that corresponds to the expression
          that creates the effect.  In this case, all the effects eminate
          from line 30.</para>
        </sect3>
        
        <sect3 id="EffectsExample">
          <title>Constructor <varname>EffectsExample</varname></title>

          <para>The constructor declares that has no effects
          (<varname>@RegionEffects("none")</varname>) and has the
          following implementation:</para>
          
          <programlisting>
  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }
          </programlisting>
          
          <para>This case is similar to <varname>getSum()</varname>
          except that the evidence for the assurance is that the special
          constructor rule applies:</para>

          <itemizedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 23</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 24</computeroutput></para>
            </listitem>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:f1" checked by constructor rule: writes to a newly
          created object are invisible at EffectsExample.java line 25</computeroutput></para>
            </listitem>
          </itemizedlist>
        </sect3>
      </sect2>
      
      <sect2 id="complex-positive-assurance">
        <title>Complex Positive Assurance</title>
        
        <para>The assurance results for method <varname>update()</varname> are
        more complicated. This method calls another method, <varname>getSum()</varname>;
        thus some the effects of this method are due to the method that it calls:</para>
        
        <programlisting>
  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }
        </programlisting>
        
        <para>This dependency is reflected in the assurance results:</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/effects-assurance-03.png"/>
          </imageobject>
        </mediaobject>
        
        <para>In particular, we see that the effect "reads
        &lt;this&gt;:Instance" is due to the declared effects of method
        <varname>getSum()</varname>.  Because of this, the results
        become a graph: the results go on to show that the declared
        effects of <varname>getSum()</varname> are assured. These are exactly the same
        results as described above. The point here is that we can see
        the complete line of assurance; in particular, the effect within
        <varname>update()</varname> is accounted for and the source of that effect has been
        assured as well. This is why the icon for the result-drop (line
        35) is a double-plus <guiicon><inlinegraphic
      fileref="images/plus-plus.jpg"/></guiicon>: the large plus indicates effect is
        assured in the context of the method <varname>update()</varname>, while the small
        plus indicates that the <emphasis>source</emphasis> of that effect has also been
        assured.</para>
      </sect2>
      
      <sect2 id="effects-failures">
        <title>Assurance Failures</title>
        
        <para>Now we examine the assurance results of the negatively assured methods
        <varname>bad()</varname> and <varname>indirectlyBad()</varname>.</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/effects-assurance-04.png"/>
          </imageobject>
        </mediaobject>
        
        <sect3 id="method-bad">
          <title>Method <varname>bad()</varname></title>
          
          <para>Method <varname>bad()</varname> is incorrect because it
          invokes the method <varname>doesAnything()</varname> but only
          declares that it could read the state of the receiver
          (<varname>"reads Instance"</varname>).</para>

          <programlisting>
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad() {
    return getSum() + doesAnything();
  }
          </programlisting>

          <para>In particular, there are two results:</para>

          <orderedlist>
            <listitem>
              <para><computeroutput>"reads &lt;this&gt;:Instance" checked by
              "reads &lt;this&gt;:Instance" at EffectsExample.java line
              54</computeroutput> indicates that the effects of invoking
              <varname>getSum()</varname> on line 54 are accounted for by the declared
              effects.</para>
            </listitem>
            <listitem>
              <para><computeroutput>"writes java.lang.Object:All" not
              accounted for by declared effect(s) at EffectsExample.java
              line 54</computeroutput> indicates that the effects of
              invoking <varname>doesAnything()</varname> on line 54 are
              not accounted for.</para>
            </listitem>
          </orderedlist>
        </sect3>
        
        <sect3 id="method-indirectly-bad">
          <title>Method <varname>indirectlyBad()</varname></title>
          
          <para>This method is interesting because its declared effects
          do account for all the effects of its implementation, in the
          sense that the declared effects of called methods are considered
          to be part of the effects of this method. But the method still
          fails to assure because the declared effects of the called
          method&mdash;in this case <varname>bad()</varname>&mdash;cannot be assured.</para>

          <programlisting>
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad();
  }
          </programlisting>

          <para>The method has a single result <computeroutput>"reads
          &lt;this&gt;:Instance" checked by "reads
          &lt;this&gt;:Instance" at EffectsExample.java line
          46</computeroutput>. What is interesting, however, is that
          this drop is marked with a plus subscripted with a red X <guiicon><inlinegraphic
      fileref="images/plus-x.jpg"/></guiicon>.  This means that the effects assure, but that
          the basis for the implementation effects, namely the effects declaration of
          the method <varname>bad</varname>, fails to assure.</para>
        </sect3>
      </sect2>
    </sect1>
    
    <sect1 id="lock-assurance">
      <title>Lock Assurance</title>
      
      <para>Each <varname>@RegionLock</varname> annotion results in a
      new chain of evidence under <guilabel>Concurrency</guilabel>
      heading in the <guilabel>Verification Status</guilabel> view. Each
      of these chains is marked to indicate whether the model associated
      with it is assured or not, via <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>,
      respectively, and contains additional levels of detail describing
      the particulars of the assurance. This detail includes both
      assurance about the protected state, marked with
      <guiicon><inlinegraphic
      fileref="images/folder-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/folder-x.jpg"/></guiicon>,
      as well as with chains of evidence for other annotations used to
      support the lock model (e.g., <varname>@ReturnsLock</varname> and
      <varname>@SingleThreaded</varname>), again marked with
      <guiicon><inlinegraphic
      fileref="images/green-plus.jpg"/></guiicon> and
      <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>. 
      See, for example, <xref linkend="lock-assurance-figure"/>.</para>
      
      <figure id="lock-assurance-figure">
        <title>Example Chains of Evidence for Lock Assurance</title>

        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/lock-assurance-01.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <sect2 id="assuring-region-lock">
        <title>Assuring <varname>@RegionLock</varname></title>
        
        <para>The example class <varname>SimpleLockExample</varname>
        demonstrates the basics of lock assurance:</para>

        <programlisting>
<emphasis>@RegionLock("L1 is this protects Instance")</emphasis>
public class SimpleLockExample {
  private int f;
  private int g;
  
  public synchronized int getF() {
    // Good
    return f;
  }
  
  public void setF(final int v) {
    synchronized (this) {
      // Good
      f = v;
    }
  }
  
  <emphasis>@RequiresLock("L1")</emphasis>
  public void doStuff() {
    // Good
    f = 0;
  }
  
  public int getG() {
    // Bad
    return g;
  }
}
        </programlisting>

        <para>The receiver (<varname>this</varname>) is used as a lock
        to protect the <varname>Instance</varname> region of the object.
        The field <varname>f</varname> is always accessed correctly,
        while the field <varname>g</varname> is accessed
        incorrectly.</para>
        
        <mediaobject>
          <imageobject role="html">
            <imagedata fileref="images/lock-assurance-02.png"/>
          </imageobject>
        </mediaobject>
        
        <para>The correct and incorrect field accesses are grouped under
        distinct subheadings, described below.  The heading <guilabel>lock
        precondition(s)</guilabel> is described below in <xref
        linkend="lock-preconditions"/>.</para>
        
        <sect3 id="protected-field-accesses">
          <title>protected field access(es)</title>
          
          <para>This heading groups together all the accesses to fields in the
          protected region that JSure can assure occur when the correct
          lock is held. For our example, this would be the fields in the
          region <varname>Instance</varname> and the lock referenced by
          <varname>this</varname>.  The individual assurance results
          under this subheading are of the form <computeroutput>Lock
          "<replaceable>lock</replaceable>" held when accessing
          <replaceable>field</replaceable></computeroutput>. In our
          example, there are three of these, one for each access to
          field <varname>f</varname> on lines 13, 19, and 26.</para>
          
          <para>Each assurance result is backed up by
          <guilabel>supporting information</guilabel> that shows the
          locks that can be assured to be held when the field is
          accessed: <computeroutput>Intrinsic lock
          "<replaceable>lock</replaceable>" is held</computeroutput>.
          This result links to the source line of code of the expression
          that acquires the lock. In our example, for the access on line
          11, the supporting information links to the declaration of the
          surrounding <varname>synchronized</varname> method
          <varname>getF()</varname> on line 11. For the access on line
          19, the supporting information links to the surrounding
          <varname>synchronized</varname> block on line 17.  Finally,
          for the access on line 26, the supporting information links to
          the the <varname>@RequiresLock</varname> annotation of the
          surrounding method <varname>doStuff()</varname>on line 23. In
          a more complete example, one in which we have calls to the
          method <varname>doStuff()</varname>, the use of
          <varname>@RequiresLock</varname> would be assured based on the
          correctness of its callsites. If there were unassured
          callsites, then this field access would be marked with a
          <guiicon><inlinegraphic
          fileref="images/plus-x.jpg"/></guiicon> to indicate that
          assurance of one its preconditions failed.</para>
        </sect3>
        
        <sect3 id="unprotected-field-accesses">
          <title>unprotected field access(es); possible race condition detected</title>
          
          <para>This heading groups together all the accesses to fields in the
          protected region that JSure cannot assure always occur when the lock is held.
          The individual assurance results under this subheading are of the 
          form <computeroutput>Lock "<replaceable>lock</replaceable>" not held when
          accessing <replaceable>field</replaceable></computeroutput>.  In our example,
          there is one of these results for the access to the field <varname>g</varname> 
          at line 31.</para>
        </sect3>
      </sect2>
      
      <sect2 id="assuring-requires-lock">
        <title>Assuring Method Preconditions: <varname>@RequiresLock</varname></title>
        
        <para>The result heading for each <varname>@RegionLock</varname>
        annotation collects all the <varname>@RequiresLock</varname> annotations that name
        its lock under the heading <guilabel>lock preconditions</guilabel>; see <xref linkend="RequiresLockExample-results"/>.
        Each <varname>@RequiresLock</varname> annotation is assured by checking
        each call site of the annotated method to see if the correct
        lock is held. As with field access, the good and bad call sites
        are grouped together; again, see <xref linkend="RequiresLockExample-results"/>.</para>
        
        <figure id="RequiresLockExample-results">
          <title>Chains of Evidence for <varname>RequiresLockExample</varname></title>.
          
          <mediaobject>
            <imageobject role="html">
              <imagedata fileref="images/lock-assurance-03.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        
        <para>This section uses class
        <varname>RequiresLockExample</varname> to describe how
        <varname>@RequiresLock</varname> annotations are assured:</para>
        
        <programlisting>
<emphasis>@RegionLock("RL is this protects Instance")</emphasis>
public class RequiresLockExample {
  private int f;
  
  <emphasis>@RequiresLock("RL")</emphasis>
  public int get() { return f; }
  
  <emphasis>@RequiresLock("RL")</emphasis>
  public void set(final int v) { f = v; }
  
  public synchronized void doStuff() {
    //good
    set(
        // good
        get() + 10);
  }
  
  public void doMoreStuff(final int v) {
    synchronized (this) {
      // good
      set(v + 100);
    }
  }
  
  public int bad() {
    // bad
    return get();
  }
}
        </programlisting>
        
        <sect3 id="preconditions-satisfied">
          <title>lock precondition(s) satisfied</title>

          <para>Each call site for which JSure can determine that the
          required lock is held results in an entry under this heading.
          The individual results read <computeroutput>Lock
          "<replaceable>lock</replaceable>" held when invoking
          <replaceable>method</replaceable></computeroutput>.  As with
          the field assurances, these results have supporting
          information indicating which statements acquire the locks. In
          our example, both uses of <varname>set()</varname>, on lines
          18 and 26, are correct, and one use of
          <varname>get()</varname>, on line 20, is correct. For
          <varname>set()</varname>, the supporting information refers to
          the <varname>synchronized</varname> method on line 16 and the
          <varname>synchronized</varname> block on line 24,
          respectively. For <varname>get()</varname>, the supporting
          information refers to the <varname>synchronized</varname>
          method on line 16.</para>
        </sect3>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="reference">
    <title>Reference</title>
    <sect1>
      <title>The JSure menu</title>
      <para>The JSure menu appears as an item on the Eclipse workspace
      main menu.</para>
    </sect1>
    <sect1>
      <title>The Code Verification perspective</title>
      <para>The Code Verification perspective organizes the Eclipse
      workbench to show views which will help you to interact with
      tool findings.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Release notes</title>
    <para>For each release of JSure there are new and noteworthy
    features to try out, and known limitations to avoid or
    workaround. These are presented in the sections below for each
    released version of JSure.</para>
    <sect1>
      <title>JSure version 1.0</title>
      <para>This section describes the 1.0 release of JSure.</para>
      <sect2>
	<title>New and Noteworthy</title>
	<para>This section describes new and noteworthy features in this
	version of JSure.</para>
      </sect2>
      <sect2>
	<title>Known Problems</title>
	<para>This section describes known bugs and limitations in this
	version of JSure.</para>
      </sect2>
    </sect1>
  </chapter>
</book>
