<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<sect2 id="lock-warnings">
  <title>Suggestions and Warnings</title>
  
  <para>Lock assurance can also yield several classes of results under
  the top-level <guilabel>Suggestions and Warnings</guilabel>
  heading.</para>
  
  <sect3 id="shared-unprotected">
    <title>protected reference(s) to a possibly shared unprotected
    object; possible race condition detected</title>

    <para>A lock on a region only protects the fields in that region. 
    It does not protect <emphasis>the objects referenced by those
    fields</emphasis>.  To remind the programmer of this situation,
    JSure generates warnings when the state of objects referenced by
    protected fields is accessed.  Two such warnings are possible:
    
      <variablelist>
        <varlistentry>
          <term id="possibly-shared-field">Field reference
          "<replaceable>field ref</replaceable>" may be to a shared
          unprotected object</term>
          <listitem>
            <para>The field expression accesses a field of an object
            referenced by a field that is protected by a named lock. 
            Specifically,
            
              <itemizedlist>
                <listitem>
                  <para><replaceable>field ref</replaceable> is of
                  the form
                  <code><replaceable>expr</replaceable>.<replaceable>f</replaceable>.<replaceable>f&prime;</replaceable></code>
                  or <code><replaceable>expr</replaceable>.<replaceable>f</replaceable>[&hellip;]</code>
                  </para>
                </listitem>
                <listitem>
                  <para>The field
                  <structfield><replaceable>f&prime;</replaceable></structfield>
                  is not <code>final</code> or
                  <code>volatile</code>.</para>
                </listitem>                    
                <listitem>
                  <para>The region
                  <structfield><replaceable>f&prime;</replaceable></structfield> or
                  <structfield>[]</structfield>, respectively, <emphasis>is
                  not</emphasis> associated with a lock, either
                  directly or by aggregation.</para>
                </listitem>
                <listitem>
                  <para>Either,
                    <itemizedlist>
                      <listitem>
                        <para>The region
                        <structfield><replaceable>f</replaceable></structfield>
                        <emphasis>is</emphasis> protected
                        by a lock, either directly or via
                        aggregation.</para>
                      </listitem>
                    </itemizedlist>
                  or
                    <itemizedlist>
                      <listitem>
                        <para>The field <structfield><replaceable>f</replaceable></structfield>
                        is <code>final</code> or <code>volatile</code> and the class that
                        it is declared in contains at least one <classname>@PolicyLock</classname>
                        or <classname>@RegionLock</classname> annotation.</para>
                      </listitem>
                    </itemizedlist>
                  </para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term id="possibly-shared-receiver">Receiver
          "<replaceable>field ref</replaceable>" may be a shared
          unprotected object</term>
          <listitem>
            <para>The field expression references a field that is
            protected by a lock and is used as the receiver of a
            method call.  Specfically,
              <itemizedlist>
                <listitem>
                  <para><replaceable>field ref</replaceable> is of the form 
                  <code><replaceable>expr</replaceable>.<replaceable>f</replaceable></code>.</para>
                </listitem>
                <listitem>
                  <para>The class/interface of the object referenced by
                  <code><replaceable>expr</replaceable>.<replaceable>f</replaceable></code>
                  <emphasis>is not</emphasis> annotated with <classname>@SelfProtected</classname>.</para>
                </listitem>
                <listitem>
                  <para>The field <structfield><replaceable>f</replaceable></structfield>
                  <emphasis>is not</emphasis>
                  annotated with <classname>@Unique</classname>.</para>
                </listitem>
                <listitem>
                  <para>Either,
                    <itemizedlist>
                      <listitem>
                        <para>The region
                        <structfield><replaceable>f</replaceable></structfield>
                        <emphasis>is</emphasis> protected
                        by a lock, either directly or via
                        aggregation.</para>
                      </listitem>
                    </itemizedlist>
                  or
                    <itemizedlist>
                      <listitem>
                        <para>The field <structfield><replaceable>f</replaceable></structfield>
                        is <code>final</code> or <code>volatile</code> and the class that
                        it is declared in contains at least one <classname>@PolicyLock</classname>
                        or <classname>@RegionLock</classname> annotation.</para>
                      </listitem>
                    </itemizedlist>
                  </para>
                </listitem>
              </itemizedlist>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </para>
    
    <para>Class <classname>SharedUnprotectedStateExample</classname> from project <filename>Lock Output</filename>
    demonstrates these results, shown in <xref
    linkend="shared-unprotected-results"/>:</para>

    <programlisting linenumbering="numbered" startinglinenumber="7"><emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class SharedUnprotectedStateExample {
  private int[] array = new int[10];
  private Object object = new Object();

  @SingleThreaded
  @Borrowed("this")
  public SharedUnprotectedStateExample() {
    // do nothing
  }
  
  public <emphasis>synchronized</emphasis> String doStuff() {
    int sum = 0;
    for (int i = 0; i &lt; array.length; i++) {
      sum += array[i];
    }
    
    return object.toString() + " " + sum;
  }
}</programlisting>
    
    <figure id="shared-unprotected-results">
      <title>Assurance results for <classname>SharedUnprotectedStateExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/shared-unprotected-01.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/shared-unprotected-01.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    
    <para>The warning for line 21, <computeroutput>Field reference
    "this.array[i]" may be to a shared unprotected
    object</computeroutput> reminds us that although the field
    <structfield>array</structfield> is protected by the lock (correctly
    acquired by the <code>synchronized</code> method
    <function>doStuff()</function>), the elements of the array object it
    points to are not.  It is entirely possible that a field of another
    object holds a reference to the same array.  The synchronization on
    <function>doStuff()</function> prevents concurrent access to that
    array through the <structfield>array</structfield> field, but not
    through any other fields of other objects that may reference the
    array.  Thus this situation is potentially unsafe.</para>

    <para>Similarly, the warning for line 24, <computeroutput>Receiver
    "this.object" may be a shared unprotected object</computeroutput>
    remnds us that the object referenced by
    <structfield>object</structfield> may be accessible through the
    fields of other objects as well.  Therefore, it is potentially
    unsafe to access the state of that object by invoking a method on
    it.</para>
  </sect3>
  
  <sect3 id="redundant-locks">
    <title>redundant lock acquisition(s)</title>
    
    <para>This subheading groups together warnings about lock
    acquisitions that may be redundant, that is, that acquire a lock
    that <emphasis>must</emphasis> already be held. The speficic
    warnings under this heading read <computeroutput>Acquisition of lock
    "<replaceable>lock</replaceable>" may be redundant</computeroutput>.
     Each results links to the expression or annotation that is a
    potentially redundant lock acquisition. Class
    <classname>RedundantLockExample</classname> from project <filename>Lock Output</filename> demonstrates these
    results, shown in <xref linkend="redundant-lock-results"/>:</para>
    
    <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class RedundantLockExample {

  private int f;
  
  // not redundant
  public synchronized void m() {
    f = 1;
    // redundant
    synchronized (this) {
      f = 2;
    }
  }
  
  public void n() {
    // not redundant
    synchronized (this) {
      f = 3;
      
      // redundant
      synchronized (this) {
        f = 4;
      }
    }
  }
  
  // Not redundant 
  <emphasis>@RequiresLock("L")</emphasis>
  public void o() {
    f = 5;
    
    // redundant for L, but not for MUTEX
    synchronized (this) {
      f = 6;
    }
  }
}</programlisting>
    
    <figure id="redundant-lock-results">
      <title>Assurance results for <classname>RedundantLockExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/lock-assurance-11.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-11.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    
    <para>The lock acquisitions on lines 15 and 26 are seen as redundant
    acquisitions of two locks, <structfield>MUTEX</structfield> and
    <structfield>L</structfield>, because the expression
    <parameter>this</parameter> could refer to either one of those
    locks. The acquision on line 38 is only redundant for lock
    <structfield>L</structfield> because the
    <classname>@RequiresLock</classname> precondition on the method only
    requires that specific lock.  Thus, although, the expression on line
    38 acquires both locks, the acquisition of
    <structfield>MUTEX</structfield> is not redundant.</para>

    <para>JSure warns about redundant lock acquisitions because they
    make it more difficult to understand the program&rsquo;s design intent.
    Ideally, redundant lock acquisitions should be removed from the
    program.  We are careful to say that these acquisitions
    <emphasis>may be</emphasis> redundant because a program&rsquo;s design
    intent can be more complicated than is expressable using JSure&rsquo;s
    annotations, and thus the lock acquision may satisfy an intent that
    has not been expressed.</para>
  </sect3>
  
  <sect3 id="unidentifiable-locks">
    <title>unidentifiable lock(s); what is the name of the lock? what
    state is being protected?</title>

    <para>This class of warnings identifies those lock acquisitions
    where JSure is unable to determine that a named lock is being
    acquired. That is, there is no lock declared with a
    <classname>@RegionLock</classname> or
    <classname>@PolicyLock</classname> annotation that can be determined
    to be acquired at the identified locations. There are three messages
    that can appear under this heading:</para>
    
    <variablelist>
      <varlistentry>
        <term id="does-not-name">Lock expression
        "<replaceable>expr</replaceable>" does not name a
        programmer-declared lock; consider declaring the state protected
        by the referenced lock</term>

        <listitem><para>The given expression in the identified
        <code>synchronized</code> statement is not identifiable as a
        lock declared in a <classname>@RegionLock</classname> or
        <classname>@PolicyLock</classname> annotation.
        </para></listitem>
      </varlistentry>

      <varlistentry>
        <term id="does-not-name-instance">Synchronized method
        <replaceable>method</replaceable>: "this" is not identifiable as
        a programmer-declared lock</term>

        <listitem><para>This identifies a non-<code>static</code>
        <code>synchronized</code> method for which the receiver
        (<parameter>this</parameter>) is not identifiable as a
        lock.</para></listitem>
      </varlistentry>

      <varlistentry>
        <term id="does-not-name-static">Synchronized method
        <replaceable>method</replaceable>:
        "<replaceable>Class</replaceable>.class" is not identifiable as
        a programmer-declared lock</term>

        <listitem><para>This identifies a <code>static</code>
        <code>synchronized</code> method for which the class reference
        is not identifiable as a lock.</para></listitem>
      </varlistentry>
    </variablelist>
    
    <para>Class <classname>UnidentifiableLockExample</classname> from project <filename>Lock Output</filename> demonstrates these
    results, shown in <xref linkend="unidentifiable-lock-results"/>:</para>
    
    <programlisting linenumbering="numbered" startinglinenumber="3">public class UnidentifiableLockExample {
  private final Object lock = new Object();
  
  private static int s;
  
  private int x;
  private int y;
  
  static {
    // Unidentifiable lock expression
    synchronized (UnidentifiableLockExample.class) {
      s = 100;
    }
  }
  
  // Unidentifiable lock expression
  public static synchronized int getS() {
    return UnidentifiableLockExample.s;
  }
  
  // Unidentifiable lock expression
  public synchronized int getX() {
    return x;
  }
  
  public void setX(final int v) {
    // Unidentifiable lock expression
    synchronized (this) {
      x = v;
    }
  }
  
  public int getY() {
    // Unidentifiable lock expression
    synchronized (lock) {
      return y;
    }
  }
  
  public void setY(final int v) {
    // Unidentifiable lock expression
    synchronized (lock) {
      y = v;
    }
  }
}</programlisting>
    
    <figure id="unidentifiable-lock-results">
      <title>Assurance results for <classname>UnidentifiableLockExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/lock-assurance-12.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-12.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    
    <para>This class does not have any lock annotations, but there are
    numerous lock acquisitions contained within it.  All the points
    where a lock might be acquired have have a warning about the
    undentifiable nature of the lock.</para>

    <para>JSure warns about this situation as way to identify
    potentially missing lock models. For example, the warnings in the
    example can be removed by adding the following annotation to the
    class:</para>
    
    <programlisting>
@RegionLocks({
  @RegionLock("xLock is this protects x"),
  @RegionLock("yLock is lock protects y"),
  @RegionLock("sLock is class protects s")})
    </programlisting>

  </sect3>
  
  <sect3 id="non-final-locks">
    <title>non-final lock expression(s); analysis cannot determine which
    lock is being acquired</title>

    <para>JSure groups together all warnings about non-final expressions
    in <code>synchronized</code> statements under this heading. Each
    warning has the form <computeroutput>Lock expression
    "<replaceable>lock</replaceable>" is not final</computeroutput>. A
    <emphasis>final expression</emphasis> is a reference-valued
    expression that JSure can determine refers to the same object no
    matter where it is evaluated within the context of the
    <code>synchronized</code> statement. JSure requires that the lock
    expression in a <code>synchronized</code> statement be final to
    guarantee that the lock that is acquired is the same lock that is
    needed inside of the statement. The <function>test()</function>
    method of the class <classname>NonFinalLockExample</classname> from project <filename>Lock Output</filename>
    contains two examples of non-final lock expressions, see <xref
    linkend="non-final-lock-results"/>:</para>
    
    <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("L is this protects Instance")</emphasis>
public class NonFinalLockExample {
  private int val;
  
  <emphasis>@RequiresLock("L")</emphasis>
  public int get() {
    return val;
  }

  <emphasis>@RequiresLock("L")</emphasis>
  public void set(final int v) {
    val = v;
  }
  
  public static NonFinalLockExample getNF() {
    return new NonFinalLockExample();
  }
  
  public static void test() {
    NonFinalLockExample nf = new NonFinalLockExample();
    
    // Non-final lock acquisition
    synchronized (nf) {
      int x = nf.get();
      nf = new NonFinalLockExample();
      nf.set(x+1);
    }
    
    // Non-final lock acquisition
    synchronized (getNF()) {
      getNF().set(getNF().get()+1);
    }
  }
}</programlisting>

    <figure id="non-final-lock-results">
      <title>Assurance results for <classname>NonFinalLockExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/lock-assurance-13.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-13.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    
    <para>The expression <code>nf</code> on line 28 is considered
    non-final because the variable <varname>nf</varname> is assigned to
    inside of the <code>synchronized</code> statement. This means that
    the object locked by the <code>synchronized</code> statement is not
    the object that needs to be locked to call the method
    <function>set()</function> in the expression
    <code>nf.set(&hellip;)</code> on the following line. The situation
    is worse on line 35: each call to <function>getNF()</function>
    returns a <emphasis>new</emphasis> object.</para>

    <note>
      <para>This example demonstrates why pattern matching is
      insufficient: the above cases would check using a lexical scanner
      because all the object references are made using the same
      expression. But the <emphasis>value</emphasis> of that expression
      also needs to be considered to reach correct understanding of the
      program.</para>
    </note>
  </sect3>
  
  <sect3 id="not-protecting">
    <title>synchronized blocks not protecting any state; what state is
    being protected?</title>

    <para>JSure collects warnings about possibly superfluous locking
    under this heading.  Individual warnings read <computeroutput>Locks
    <replaceable>set of locks</replaceable> not needed by body of
    synchronized block</computeroutput>. This warning is an attempt to
    suggest areas where the lock model might be too narrow; that is a
    lock may protect more state than it has been declared to protect. 
    Class <classname>UnusedLockExample</classname> from project <filename>Lock Output</filename>, whose results are
    shown in <xref linkend="not-protecting-results"/>, only declares
    that lock <structfield>L</structfield> protects region
    <structfield>R</structfield>:</para>

    <programlisting linenumbering="numbered" startinglinenumber="8"><emphasis>@Regions({</emphasis>
  <emphasis>@Region("R"),</emphasis>
  <emphasis>@Region("Q")})</emphasis>
<emphasis>@RegionLock("L is this protects R")</emphasis>
public class UnusedLockExample {
  <emphasis>@InRegion("R")</emphasis>
  private int f;
  
  <emphasis>@InRegion("Q")</emphasis>
  private int g;
  
  public synchronized int getF() {
    return f;
  }
  
  public synchronized int getG() {
    return g;
  }
  
  public void setBoth(final int a, final int b) {
    synchronized (this) {
      f = a;
      g = b;
    }
  }
}</programlisting>

    <figure id="not-protecting-results">
      <title>Assurance results for <classname>UnusedLockExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/lock-assurance-14.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/lock-assurance-14.png"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The JSure results call our attention to method
    <function>getG()</function> because it is <code>synchronized</code>
    but based on the current annotations its body does not require any
    locks.  In this case, it is clear that the intent is that
    <parameter>this</parameter> is to be used to protect both fields of
    the class, so we should modify the lock annotation to be
    <classname>@RegionLock("L is this protects
    Instance")</classname>.</para>

    <para>This situation often arrises when the class is being annotated
    incrementally: It is first discovered that a particular field is
    being protected by some lock, so the annotation is narrowly tailored
    to that case. Then, it can be discovered that the lock protects more
    state, and so on.</para>
  </sect3>
  
  <sect3>
    <title>calls to methods masquerading as java.util.concurrent.Lock
    methods</title>

    <para>JSure issues warnings when classes similar to the the
    <classname>Lock</classname> and <classname>ReadWriteLock</classname>
    classes are used:</para>
    
    <variablelist>
      <varlistentry>
        <term
        id="not-juc"><computeroutput>"<replaceable>method</replaceable>"
        does not call a method from
        java.util.concurrent.locks.Lock</computeroutput></term>
        <listitem>
          <para>A method named <function>lock</function>,
          <function>tryLock</function>,
          <function>lockInterruptibly</function>, or
          <function>unlock</function> from a class named
          <classname>Lock</classname> that <emphasis>is not</emphasis>
          from the package <package>java.util.concurrent.locks</package>
          is called.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term
        id="not-rw"><computeroutput>"<replaceable>method</replaceable>"
        does not call a method from
        java.util.concurrent.locks.ReadWriteLock</computeroutput></term>
        <listitem>
          <para>A method named <function>readLock</function> or
          <function>writeLock</function> from a class named
          <classname>ReadWriteLock</classname> that <emphasis>is
          not</emphasis> from the package
          <package>java.util.concurrent.locks</package> is
          called.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    
    <para>Consider the class
    <classname>NotJustAnyLockExample</classname> from project <filename>JUC Lock Output</filename> below and its results
    in <xref linkend="not-just-any-locks-results"/>.</para>

    <programlisting linenumbering="numbered" startinglinenumber="3">public class NotJustAnyLockExample {
  public class Lock {
    public void lock() {}
    public void unlock() {}
  }

  public class ReaderWriterLock {
    public java.util.concurrent.locks.Lock readLock() { return null; }
    public java.util.concurrent.locks.Lock writeLock() { return null; }
  }

  
  
  private final ReaderWriterLock rwLock = new ReaderWriterLock();
  private final Lock lock = new Lock();

  
  
  private void doStuff() {
    // do stuff
  }
  
  public void test() {
    lock.lock();
    try {
      doStuff();
    } finally {
      lock.unlock();
    }
  }

  public void testRead() {
    rwLock.readLock().lock();
    try {
      doStuff();
    } finally {
      rwLock.readLock().unlock();
    }
  }
  
  public void testWrite() {
    rwLock.writeLock().lock();
    try {
      doStuff();
    } finally {
      rwLock.writeLock().unlock();
    }
  }
}</programlisting>

    <figure id="not-just-any-locks-results">
      <title>Assurance results for <classname>NotJustAnyLockExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/masquerading-locks.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/masquerading-locks.png"/>
        </imageobject>
      </mediaobject>
    </figure>         
  </sect3>
  
  <sect3>
    <title>mixed java.util.concurrent/intrinsic locking usage(s)</title>

    <para>JSure issues warnings when it detects scenarios that indicate
    that the programmer may be confused about the existence of
    <package>java.util.concurrent</package> locks in a class.  The class
    <classname>SyncOnJUCLocksExample</classname> from project <filename>Lock Output</filename> below uses
    <classname>Lock</classname> and <classname>ReadWriteLock</classname>
    objects in <code>synchronized</code> statements.  The Java compiler
    does not complain about this because <emphasis>all</emphasis>
    objects can be used as a lock.  But this usage defeats the purpose
    of declaring special <package>java.util.concurrent</package> locks,
    and is most likely a mistake.  JSure detects these usages and
    reports warnings, as shown in <xref
    linkend="juc-sync-results"/>.</para>
    
    <programlisting linenumbering="numbered" startinglinenumber="8">public class SyncOnJUCLocksExample {
  private final Lock lock = new ReentrantLock();
  private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
  
  private int v;
  private int w;
  
  public void oops1(final int x) {
    synchronized (lock) {
      v = x;
    }
  }
  
  public void oops2(final int y) {
    synchronized (rwLock) {
      w = y;
    }
  }
}</programlisting>
    
    <figure id="juc-sync-results">
      <title>Assurance results for <classname>SyncOnJUCLocksExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/sync-on-juc-lock.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/sync-on-juc-lock.png"/>
        </imageobject>
      </mediaobject>
    </figure>         
  
    <para>JSure issues warnings of the form <computeroutput
    id="juc-sync">Using a java.util.concurrent.locks lock object
    "<replaceable>lock</replaceable>" in a synchronized
    statement</computeroutput>.  Our example has two of these messages:
      <orderedlist>
        <listitem>
          <para>One for the misue of a <classname>Lock</classname>
          object in <function>oops1</function> on line 16.</para>
        </listitem>
        <listitem>
          <para>One for the misuse of a
          <classname>ReadWriteLock</classname> object in
          <function>oops2</function> on line 22.</para>
        </listitem>
      </orderedlist>
    </para>
    
    <para>JSure also generates warnings when an object is used in a
    <code>synchronized</code> statement, and the class of that object
    does not declare (via a <classname>@RegionLock</classname>
    annotation) that the receiver is a lock, and the class contains
    fields with the type
    <classname>java.util.concurrent.locks.Lock</classname> or
    <classname>java.util.concurrent.locks.ReadWriteLocks</classname>.
    JSure can generate two different messages in this case:
      <variablelist>
        <varlistentry>
          <term id="not-a-known-lock-general">The object referenced by
          "<replaceable>expr</replaceable>" is not a known lock, but its
          fields <replaceable>list of fields</replaceable> are
          java.util.concurrent locks</term>
          <listitem>
            <para>This is a general warning, indicating that the the
            class of the object referenced by
            <replaceable>expr</replaceable> does not declare the
            receiver to be a lock, but that the named fields of the
            class have the type
            <classname>java.util.concurrent.locks.Lock</classname> or
            <classname>java.util.concurrent.locks.ReadWriteLocks</classname>.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term id="not-a-known-lock-specific">The object referenced by
          "<replaceable>expr</replaceable>" is not a known lock, but its
          field "<replaceable>field</replaceable>" is declared to be
          java.util.concurrent lock
          "<replaceable>lock</replaceable>"</term>
          <listitem>
            <para>This is a more specific warning, indicating that the
            the class of the object referenced by
            <replaceable>expr</replaceable> does not declare the
            receiver to be a lock, but that the named field of the class
            has the type
            <classname>java.util.concurrent.locks.Lock</classname> or
            <classname>java.util.concurrent.locks.ReadWriteLocks</classname>
            <emphasis>and</emphasis> the field is declared
            (in a <classname>@RegionLock</classname> annotation) to be
            the named lock <replaceable>lock</replaceable>.  This
            warning appears under the result heading for the lock
            <replaceable>lock</replaceable> as well as under the general
            warnings heading.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      
      The class <classname>NotAKnownLockExample</classname> from project <filename>Lock Output</filename> demonstrates
      these warnings, shown in <xref
      linkend="not-a-known-lock-result1"/> and <xref
      linkend="not-a-known-lock-result2"/>.  It has one general warning,
      and one specific warning.  The general warning for line 21 refers
      to both fields <structfield>lock1</structfield> and
      <structfield>lock2</structfield> because both have the type
      <classname>Lock</classname>.  There is a specific warning for
      field <structfield>lock1</structfield>, but not
      <structfield>lock2</structfield>, because there is a
      <classname>@RegionLock</classname> for
      <structfield>lock1</structfield> only. This specific warning can
      be seen under the heading for lock
      <structfield>lock1</structfield> as well as under the heading
      <guilabel>Suggestions and Warnings</guilabel>.
    </para>

    <programlisting linenumbering="numbered" startinglinenumber="8">public class NotAKnownLockExample {
  <emphasis>@RegionLock("L1 is lock1 protects field1")</emphasis>
  private static class C {
    public final Lock lock1 = new ReentrantLock();
    public final Lock lock2 = new ReentrantLock();
    
    public int field1;
    public int field2;
  }
  
  
  
  public void doStuff(final C c) {
    synchronized (c) {
      c.field1 = 1;
    }
  }
}</programlisting>

    <figure id="not-a-known-lock-result1">
      <title>Assurance results for <classname>NotAKnownLockExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/not-a-known-lock-01.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/not-a-known-lock-01.png"/>
        </imageobject>
      </mediaobject>
    </figure>         

    <figure id="not-a-known-lock-result2">
      <title>Assurance results for <classname>NotAKnownLockExample</classname> 2</title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/not-a-known-lock-02.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/not-a-known-lock-02.png"/>
        </imageobject>
      </mediaobject>
    </figure>         
  </sect3>
</sect2>
