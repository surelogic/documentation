<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<sect2 id="nested-types">
  <title>Nested Types and Locking</title>

  <para>Nested types present a challenge to lock assurance because it
  is not always possible to determine which object&rsquo;s lock should be held
  when the lock is declared to be a qualified receiver. The crux of the
  problem is how to identify <emphasis>lexically enclosing
  instances</emphasis>.<footnote>
      <para>An object <varname>o</varname> is the <emphasis>zeroth
      lexically enclosing instance of itself</emphasis>. An object
      <varname>o</varname> is the
      <emphasis>n<superscript>th</superscript> lexically enclosing
      instance of an instance <varname>i</varname></emphasis> if it is
      the immediately enclosing instance of the
      (n-1)<superscript>st</superscript> lexically enclosing instance of
      <varname>i</varname> (<citetitle pubwork="book">The Java Language
      Specification, 3<superscript>rd</superscript> Edition</citetitle>
      [JLS3] &sect;8.1.3).</para>

      <para>An instance <varname>i</varname> of a direct inner class
      <classname>C</classname> of a class <classname>O</classname> is
      associated with an instance of <classname>O</classname>, known as
      the <emphasis>immediately enclosing instance of
      <varname>i</varname></emphasis>. The immediately enclosing
      instance of an object, if any, is determined when the object is
      created (JLS3 &sect;8.1.3).</para>

      <para>An inner class C is a <emphasis>direct inner class of a
      class <classname>O</classname></emphasis> if
      <classname>O</classname> is the immediately lexically enclosing
      class of <classname>C</classname> and the declaration of
      <classname>C</classname> does not occur in a static context (JLS3
      &sect;8.1.3).</para>

      <para>An <emphasis>inner class</emphasis> is a nested class that
      is not explicitly or implicitly declared <code>static</code> (JLS3
      &sect;8.1.3).</para>

      <para>A <emphasis>nested class</emphasis> is any class whose
      declaration occurs within the body of another class or interface
      (JLS3 &sect;8).</para>

      <para>A statement or expression <emphasis>occurs in a
      <code>static</code> context</emphasis> if and only if the
      innermost method, constructor, instance initializer,
      <code>static</code> initializer, field initializer, or explicit
      constructor invocation statement enclosing the statement or
      expression is a <code>static</code> method, a <code>static</code>
      initializer, the variable initializer of a <code>static</code>
      variable, or an explicit constructor invocation statement (JLS3
      &sect;8.1.3).</para>
    </footnote>        
  Inside the declaration of a nested type the lexcially enclosing
  instances can be identified using qualified
  <parameter>this</parameter> expressions.  Thus, there is no problem
  assuring the correct implementation of the class.  The problem arises
  when assuring the correct <emphasis>use</emphasis> of the class: Java
  does not provide a way to statically know what are the lexically
  enclosing instances of an object.  To be more concrete, given the
  variable <varname>x</varname> initialized with <code>o. new
  Inner(&hellip;)</code>, there is no way to recover from the object
  referenced by <varname>x</varname> that its immediately enclosing
  instance is the object referenced by <varname>o</varname>.</para>

  <para>Because locking is considered an implementation detail, the
  problem of identifying lexically enclosing instances surfaces in two
  situations:
    <orderedlist>
      <listitem><para>When interpreting lock specifications in
      <classname>@RequiresLock</classname> annotations at the call site
      of a method.</para></listitem>

      <listitem><para>When computing the lock that must be held in an
      instance initializer block of an anonymous
      class.</para></listitem>
    </orderedlist>
  </para>
  
  <sect3>
    <title>Lock Preconditions and Qualfied <parameter>this</parameter>
    Expressions</title>

    <para>Assurance runs into trouble when method that has a
    <classname>@RequiresLock</classname> annotation that names a lock of
    a lexically enclosing instance is called from a class other than the
    one that declares it.  When this happens, assurance is unable to
    determine what object reference in the calling context corresponds
    to the lexically enclosing instance required by the method. 
    Assurance fails in this situation, with a message of the form
    <computeroutput id="cannot-be-resolved">Lock specification
    "<replaceable>lock spec</replaceable>" cannot be resolved in the
    calling context for <replaceable>method</replaceable>; precondition
    unsatisfied</computeroutput>.  The class
    <classname>CannotBeResolvedExample</classname> below, and its
    results in <xref linkend="cannot-be-resolved-results"/>, demonstrate
    this message.</para>
  
    <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>RegionLock("oLock is this protects Instance")</emphasis>
public class CannotBeResolvedExample {
  public int oField;
  
  <emphasis>@RegionLock("in1Lock is this protects Instance")</emphasis>
  public class Inner1 {
    public int in1Field;
    
    <emphasis>@RegionLock("in2Lock is this protects Instance")</emphasis>
    public class Inner2 {
      public int in2Field;

      <emphasis>@RequiresLock("this:in2Lock, Inner1.this:in1Lock, CannotBeResolvedExample.this:oLock")</emphasis>
      public void requiresLockOkay() {
        this.in2Field = 1;
        Inner1.this.in1Field = 2;
        CannotBeResolvedExample.this.oField = 3;
      }
      
      public void canResolve() {
        synchronized (this) {
          synchronized (Inner1.this) {
            synchronized (CannotBeResolvedExample.this) {
              requiresLockOkay();
            }
          }
        }
      }
    }

    public void cannotResolve() {
      final Inner2 in2 = this. new Inner2();
      synchronized (in2) {
        in2.requiresLockOkay();
      }
    }
  }
}</programlisting>
  
    <para>The example consists of three &ldquo;layers&rdquo; of classes,
    <classname>CannotBeResolvedExample</classname>, its direct inner
    class <classname>Inner1</classname>, and its
    (<classname>Inner1</classname>&rsquo;s) direct inner class
    <classname>Inner2</classname>.  The three classes each declare the
    locks <structfield>oLock</structfield>,
    <structfield>in1Lock</structfield>, and
    <structfield>in2Lock</structfield>, respectively, that are
    represented by the instances themselves
    (<parameter>this</parameter>).  The method
    <function>requiresLockOkay()</function> of the innermost class
    <classname>Inner2</classname> references state of its own instance
    (<parameter>this</parameter>), as well as the state of the first and
    second lexically enclosing instances of the receiver:
    <parameter>Inner2.this</parameter> and
    <parameter>CannotBeResolvedExample.this</parameter>, respectively. 
    Straightforwardly, the body of the method thus requires that the
    locks <code>this:in2Lock</code>, <code>Inner1.this:in1Lock</code>,
    and <code>CannotBeResolvedExample.this:oLock</code> be held.  The
    method satisfies these requiresments by declaring a lock
    precondition.</para>

    <para>As stated previously, the challenge in this case is assuring
    calls to <function>requiresLockOkay()</function>. The method
    <function>canResolve</function> in <classname>Inner2</classname>
    calls the method from within three nested <code>synchronized</code>
    statements on line 29. As can be seen in <xref
    linkend="cannot-be-resolved-results"/>, this lock precondition
    (declared on line 18) is satisfied for the call on line 29. Because
    the precondition names three locks, it appears under the result
    heading for each lock that it names.  The chain of evidence for the
    lock precondition is identical in each case, so in the figure it is
    only expanded once, under the heading for lock
    <code>test.CannotBeResolvedExample.oLock</code>. JSure can assure
    this call because it occurs within the body of the class that
    declared the method <emphasis>and</emphasis> the receiver of the
    call is <parameter>this</parameter>.  In this case, we can identify
    the lexically enclosing instances using the qualified receiver
    expressions, just as they have been identified in the lock
    precondition.</para>

    <para>The call to <function>requiresLockOkay</function> from the
    method <function>cannotResolve</function> in inner class
    <classname>Inner1</classname> is another story.  This method creates
    a new instance of <classname>Inner2</classname> whose immediately
    enclosing lexical instance is the method&rsquo;s receiver
    (<parameter>this</parameter>). This makes the new object&rsquo;s second
    enclosing lexical instance the object referenced by
    <parameter>CannotBeResolvedExample.this</parameter>.
    <emphasis>However</emphasis>, at the use of <varname>in2</varname>
    on line 39, JSure does not retain this information about the
    referenced object&rsquo;s lexically enclosing instances; we discuss this
    more in the <link linkend="next-p">next paragraph</link>.  Because
    this information is missing, JSure cannot determine how two of three
    needed locks should be referenced.  Thus, the results show two
    unsatisfied preconditions:

      <itemizedlist>
        <listitem>
          <para><computeroutput>Lock specification
          "CannotBeResolvedExample.this:oLock" cannot be resolved in the
          calling context for in2.requiresLockOkay; precondition
          unsatisfied at CannotBeResolvedExample.java line
          39</computeroutput></para>
        </listitem>
        <listitem>
          <para><computeroutput>Lock specification "Inner1.this:in1Lock"
          cannot be resolved in the calling context for
          in2.requiresLockOkay; precondition unsatisfied at
          CannotBeResolvedExample.java line 39</computeroutput></para>
        </listitem>
      </itemizedlist>
    </para>

    <figure id="cannot-be-resolved-results">
      <title>Assurance results for
      <classname>CannotBeResolvedExample</classname></title>
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/cannot-be-resolved-01.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/cannot-be-resolved-01.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    
    <para id="next-p">Why does assurance fail in this case, when we can
    identify the necessary objects with <parameter>this</parameter> and
    <parameter>CannotBeResolvedExample.this</parameter>?  This
    information is lost because it is not available from the
    <emphasis>use</emphasis> of <varname>in2</varname> on line 39.  As
    stated previusly, there is no way to recover from the object
    referenced by <varname>in2</varname> the references to its lexically
    enclosing instances.  It is true that in this case, analysis could
    have recovered this information by using a definition&ndash;use
    analysis to discover that the object referenced by
    <varname>in2</varname> originated from the qualified new expression
    <code>this. new Inner()</code> on line 37.  There are several
    reasons why we do not do this:
      <itemizedlist>
        <listitem><para>We have not encountered many (if any) uses of
        qualified receivers in lock preconditions in production code. 
        That is to say, the authors of production code are not currently
        making such elaborate uses of locks.  The availability of a tool
        such as JSure could change this situation in the
        future.</para></listitem>

        <listitem><para>It is not clear how useful the results would be
        in methods that have more complicated control
        flow.</para></listitem>

        <listitem><para>Definition&ndash;use analysis would not help in
        the situtation were we do not locally know how the inner class
        instance was created, such as when the inner class instance is
        referenced by a field or method parameter.</para></listitem>
      </itemizedlist>
    </para>
  </sect3>
  
  <sect3>
    <title>Anonymous Class Expressions and Instance Initializers</title>

    <para>Anonymous class expressions also present a challenge for
    assurance when locks from lexically enclosing instances are
    required.  They are also interesting because the field
    initialization expressions and instance initializer blocks of the
    class being instanstiated run in the context of the method
    containing the anoymous class expression.  This means assurance can
    take advantage of locks held by the calling context.  The qualified
    receivers that identify the lexically enclosing instances of the
    anonymous class instance can sometimes be mapped to expressions in
    the calling context.  In this case, JSure has a series of &ldquo;held as&rdquo;
    lock assurance messages:
      <itemizedlist>
        <listitem id="held-as-1">
          <para>Lock "<replaceable>lock</replaceable>" held as
          "<replaceable>lock&prime;</replaceable>" when accessing
          <replaceable>field</replaceable></para>
        </listitem>
        <listitem id="held-as-2">
          <para>Lock "<replaceable>lock</replaceable>" held as
          "<replaceable>lock&prime;</replaceable>" when invoking
          <replaceable>method</replaceable>; precondition
          satisfied</para>
        </listitem>
        <listitem id="held-as-3">
          <para>Lock "<replaceable>lock</replaceable>" held as
          "<replaceable>lock&prime;</replaceable>" when invoking
          <replaceable>method</replaceable></para>
        </listitem>
      </itemizedlist>
    This messages are the same as the non-&ldquo;held as&rdquo; versions, except
    that they indicate that the needed lock
    <replaceable>lock</replaceable> is actually held in the calling
    context as the lock <replaceable>lock&prime;</replaceable>.  If the
    needed lock is not held locally by the initializer of the anonymous
    class, and it cannot be mapped to a specific reference in the
    calling context, then JSure has a special assurance failure message:
    <computeroutput id="not-held-within">Lock
    "<replaceable>lock</replaceable>", needed for accessing
    <replaceable>field</replaceable>, is not held within the anonymous
    class and cannot be resolved in the calling context; lock must be
    held within the anonymous class</computeroutput>.  The class
    <classname>HeldAsExample</classname> demonstrates these
    messages.</para>
    
    <programlisting linenumbering="numbered" startinglinenumber="10"><emphasis>@RegionLock("T is lockT protects t")</emphasis>
public class HeldAsExample { <co id="heldas.class" linkends="heldas.class.ref"/>
  public final Object lockT = new Object();
  public int t;
  
  <emphasis>@RegionEffects("reads array:Instance")</emphasis>
  public static void useArray(final <emphasis>@Borrowed</emphasis> int[] array) {} <co id="heldas.useArray" linkends="heldas.useArray.ref"/>
   
  <emphasis>@RegionLock("C is lockC protects c")</emphasis>
  public class Container { <co id="container.class" linkends="container.class.ref"/>
    public final Object lockC = new Object();
    public int c;
    
    <emphasis>@RegionLock("F is lockF protects f")</emphasis>
    public class Super { <co id="super.class" linkends="super.class.ref"/>
      public final Object lockF = new Object();
      public int f;
    }
    
    <emphasis>@RegionLock("M1 is lockM1 protects m1")</emphasis>
    public class Middle1 { <co id="middle1.class" linkends="middle1.class.ref"/>
      public final Object lockM1 = new Object();
      public int m1;
      
      <emphasis>@RegionLock("M2 is lockM2 protects m2")</emphasis>
      public class Middle2 { <co id="middle2.class" linkends="middle2.class.ref"/>
        public final Object lockM2 = new Object();
        public int m2;
        <emphasis>@Unique</emphasis>
        <emphasis>@Aggregate("Instance into m2")</emphasis>
        public final int[] array = new int[] { 1, 2, 3 }; <co id="middle2.array" linkends="middle2.array.ref"/>
        
        <emphasis>@RequiresLock("M2")</emphasis>
        public void accessM2() {} <co id="middle2.accessM2" linkends="middle2.accessM2.ref"/>
                
        <emphasis>@RequiresLock("other:C")</emphasis>
        public void stuff1(final Container other) { <co id="stuff1.method" linkends="stuff1.method.ref"/>
          synchronized (this.lockM2) {
            /* The immediately enclosing instance of s6 is "this" (a Middle2 object)
             * The immediately enclosing instance with respect to Super is other.
             */
            final Super s6 = other. new Super() { <co id="stuff1.anonclass" linkends="stuff1.anonclass.ref"/>
              {
                Middle1.this.m1 = 20; // M1 not resolvable
                Middle2.this.m2 = 30;
                Middle2.this.accessM2();
                HeldAsExample.useArray(Middle2.this.array);
                HeldAsExample.this.t += 1; // T not resolvable
                Container.this.c = 9;
              }
            };
          }
        }
      }
    }
  }
}</programlisting>

    <calloutlist>
      <callout id="heldas.class.ref" arearefs="heldas.class">
        <para>Class <classname>HeldAsExample</classname> declares a lock
        <structfield>T</structfield> to protect its state.</para>
      </callout>
      <callout id="heldas.useArray.ref" arearefs="heldas.useArray">
        <para>It also declares a <code>static</code> method
        <function>useArray</function> that reads the elements of the
        <classname>@Borrowed</classname> integer array it takes as a
        parameter.</para>
      </callout>
      <callout id="container.class.ref" arearefs="container.class">
        <para>Class <classname>Container</classname> is a direct inner
        class of <classname>HeldAsExample</classname>.  It declares a
        lock <structfield>C</structfield> to protect its state.</para>
      </callout>
      <callout id="super.class.ref" arearefs="super.class">
        <para>Class <classname>Super</classname> is a direct inner class
        of <classname>Container</classname>.  It declares a lock
        <structfield>F</structfield> to protect its state.</para>
      </callout>
      <callout id="middle1.class.ref" arearefs="middle1.class">
        <para>Class <classname>Middle1</classname> is also a direct
        inner class of <classname>Container</classname>. It declares a
        lock <structfield>M1</structfield> to protect its state.</para>
      </callout>
      <callout id="middle2.class.ref" arearefs="middle2.class">
        <para>Class <classname>Middle2</classname> is a direct inner
        class of <classname>Middle1</classname>.  It declares a lock
        <structfield>M2</structfield> that protects its state.</para>
      </callout>
      <callout id="middle2.array.ref" arearefs="middle2.array">
        <para>It declares that the integer array referenced by field
        <structfield>array</structfield> is a
        <classname>@Unique</classname> and aggregates its state into the
        field/region <structfield>m2</structfield>.</para>
      </callout>
      <callout id="middle2.accessM2.ref" arearefs="middle2.accessM2">
        <para>Its method <function>accessM2</function> requires the
        caller to hold the lock <structfield>M2</structfield>.</para>
      </callout>
      <callout id="stuff1.method.ref" arearefs="stuff1.method">
        <para>Method <function>Middle2.stuff1</function> requires its
        callers to hold the lock <structfield>C</structfield> on the
        object passed to the parameter <parameter>other</parameter>. 
        Its body acquires the lock <structfield>M2</structfield> on the
        receiver (<parameter>this</parameter>).</para>
      </callout>
      <callout id="stuff1.anonclass.ref" arearefs="stuff1.anonclass">
        <para>The method body creates a new instance of an anonymous
        class derived from the class
        <classname>HeldAsExample.Container.Super</classname>.</para>
      </callout>
    </calloutlist>

    <para>The object created at line 51 has many lexically enclosing
    objects, as defined by JLS3 &sect;15.9.2:
      <itemizedlist>
        <listitem>
          <para>The immediately enclosing instance, also known as the
          first lexically enclosing instance, is the
          <classname>Middle2</classname> instance that is executing the
          <function>stuff1</function> method.  This instance is known as
          <parameter>this</parameter> within
          <function>stuff1</function>, hereafter referred to as the
          <emphasis>calling context</emphasis>, and as
          <parameter>Middle2.this</parameter> within the anonymous
          class.</para>
        </listitem>
        <listitem>
          <para>The immediately enclosing instance with respect to
          <classname>Super</classname><footnote>
              <para>For every superclass <classname>S</classname> of
              <classname>C</classname> which is itself a direct inner
              class of a class <classname>SO</classname>, there is an
              instance of <classname>SO</classname> associated with
              <varname>i</varname>, known as the <emphasis>immediately
              enclosing instance of <varname>i</varname> with respect to
              <classname>S</classname></emphasis>. The immediately
              enclosing instance of an object with respect to its class&rsquo;
              direct superclass, if any, is determined when the
              superclass constructor is invoked via an explicit
              constructor invocation statement (JLS3
              &sect;8.1.3).</para>
            </footnote>
          is the object referenced by the expression used to qualify the
          anonymous class expression.  This object is known as
          <parameter>other</parameter> in the calling context and
          <parameter>Container.this</parameter> in the anonymous class
          body.</para>
        </listitem>
        <listitem>
          <para>The second lexically enclosing instance is the
          <classname>Middle1</classname> object that is the immediately
          enclosing instance of the <classname>Middle2</classname>
          instance that is executing the <function>stuff1</function>
          method.  This object is known as
          <parameter>Middle1.this</parameter> within both the calling
          context and the anonymous class.</para>
        </listitem>
      </itemizedlist>
    </para>
  </sect3>
</sect2>
