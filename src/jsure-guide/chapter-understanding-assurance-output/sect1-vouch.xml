<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect1 id="vouch">
  <title>Programmer Vouch Capability</title>
  
  <para>Instances of the <classname>@Vouch</classname> annotation are not assured, but they
  do change the way that other assurance results are displayed.  Consider the class
  <classname>Controller</classname> below:</para>
    
  <programlisting linenumbering="numbered" startinglinenumber="6"><emphasis>@RegionLock("ControllerLock is this protects Instance")</emphasis>
public class Controller {
  private String id;

  private Controller() {
    super();
  }
	
  public static Controller makeController(final String id) {
    final Controller c = new Controller();
    c.init(id);
    return c;
  }
	
  private void init(final String id) {
    this.id = id; 
  }
	
  public synchronized String getId() {
    return id; // Correctly accessed
  }
}</programlisting>

  <para>This class declares a lock model to protect its state at line 6.  The
  method <function>getId</function> is correctly <code>synchronized</code>, but
  the method <function>init</function> is not.  Thus we are not surprised by the
  assurance results:</para>
  
  <mediaobject>
    <imageobject condition="isHTML">
      <imagedata fileref="images/vouch-01.png"/>
    </imageobject>
  </mediaobject>
  
  <para>The assignment to field <structfield>id</structfield> on line 21 is not
  consistent with the annotated assertions.  But the intent is that the <function>init</function> method is only
  called by the factory method <function>makeController</function> while the
  newly constructed <classname>Controller</classname> object is still confined
  to a single thread.  Thus we can use the <classname>@Vouch</classname>
  annotation to quiet the negative assurance result:</para>
  
    
  <programlisting linenumbering="numbered" startinglinenumber="6">@RegionLock("ControllerLock is this protects Instance")
public class Controller {
  private String id;

  private Controller() {
    super();
  }
	
  public static Controller makeController(final String id) {
    final Controller c = new Controller();
    c.init(id);
    return c;
  }

  <emphasis>@Vouch("Only called from the factory method before the object is shared with other threads")</emphasis>
  private void init(final String id) {
    this.id = id; 
  }
	
  public synchronized String getId() {
    return id; // Correctly accessed
  }
}</programlisting>
  
  <para>Now any negative (or inconsistent) assurance result that occurs within the body of the
  <function>init</function> method is promoted to a <emphasis>trusted</emphasis>
  positive result.  These "vouched" results are marked with a grey plus <guiicon><inlinegraphic
  fileref="images/grey-plus.png"/></guiicon>:</para>
  
  <mediaobject>
    <imageobject condition="isHTML">
      <imagedata fileref="images/vouch-02.png"/>
    </imageobject>
  </mediaobject>
  
  <para>Note, however, that the result is still displayed under the negative
  assurance heading "unprotected field accesses(es)".  In addition, all the
  icons along the entire
  chain of evidence for that result, starting from the <classname>@Vouch</classname>
  annotation and ending with the <guilabel>Concurrency</guilabel> heading are
  "poisoned" with a red dot to indicate that the assurance is conditional on the
  programmer-supplied testament of assurance.</para>
  
  <para>All vouches are also displayed under a separate <guilabel>Vouches</guilabel> 
  heading.  Each <classname>@Vouch</classname> annotation result shows as supporting
  information all the assurance results that it promotes to being trusted.</para>
</sect1>
