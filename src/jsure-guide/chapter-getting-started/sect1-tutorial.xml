<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<sect1 id="tutorial">
  <title>Tutorial: Verifying BoundedFIFO</title>
  
  <para>In this turorial we walk through the creation of a project and 
  its complete assurance using JSure.  Specifically, we assure both
  the implementation and <emphasis>usage</emphasis> of a simple class.
  That is, we demonstrate that is not always
  enough to assure the implementation of a class: <emphasis>sometimes
  the clients of a class must conform to a specific behavior as
  well</emphasis>. This example focuses on two classes (plus one
  auxillary class):
    <variablelist>
      <varlistentry>
        <term><classname>BoundedFIFO</classname></term>
        <listitem><para>The &ldquo;thread safe&rdquo; class.  This class
        is taken from the Apache Log4J project.</para></listitem>
      </varlistentry>
    
      <varlistentry>
        <term><classname>BlockingFIFO</classname></term>
        <listitem><para>The client code.  We wrote this class based on
        actual client code in Log4J.</para></listitem>
      </varlistentry>
    
      <varlistentry>
        <term><classname>LoggingEvent</classname></term>
        <listitem><para>The class of objects stored in the queue.  This
        class is not interesting, and is merely a placeholder for queue
        objects.</para></listitem>
      </varlistentry>
    </variablelist>
  </para>

  <para>In addition to showing the basic usage of JSure with Eclipse,
  this example shows off the JSure annotations
  <classname>@RegionLock</classname>,
  <classname>@RequiresLock</classname>,
  <classname>@SingleThreaded</classname>,
  <classname>@Borrowed</classname>, <classname>@Unique</classname>,
  <classname>@Aggregate</classname>, and
  <classname>@Promise</classname>. </para>

  <sect2>
    <title>Creating the BoundedFIFO Project</title>
    
    <orderedlist>
      <listitem>
        <para>Create a new Java project called &ldquo;BoundedFIFO&rdquo;. 
        Make sure the project is configured to use Java 5 or greater so that
        you can use Java annotation types; see <xref
        linkend="fig-create-java-project"/>.</para>
      </listitem>
      <listitem>
        <para>Create a new package <package>test</package> in the project.</para>
      </listitem>
    </orderedlist>
    
    <figure id="fig-create-java-project">
      <title>Creating the Project BoundedFIFO</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/create-java-project.png"/>
        </imageobject>
      </mediaobject>
    </figure>

    <sect3>
      <title>Create <classname>BoundedFIFO</classname></title>
            
      <para>Create a new class <classname>test.BoundedFIFO</classname>, and replace its
      contents with the following</para>
    
      <programlisting><![CDATA[
package test;

/*
 * Copyright (C) The Apache Software Foundation. All rights reserved.
 *
 * This software is published under the terms of the Apache Software License
 * version 1.1, a copy of which has been included  with this distribution in
 * the LICENSE.txt file.
 * 
 * Contributors:     Mathias Bogaert
 *                   joelr@viair.com
 * 
 * Annotations by Aaron Greenhouse - Carnegie Mellon University
 */

/**
 * <code>BoundedFIFO</code> serves as the bounded first-in-first-out buffer
 * heavily used by the {@link org.apache.log4j.AsyncAppender}.
 * 
 * @author Ceki G&uuml;lc&uuml;
 * @since version 0.9.1
 */

public class BoundedFIFO {
  LoggingEvent[] buf;
  
  int numElts = 0;
  int first = 0;
  int next = 0;
  int size;

  /**
   * Instantiate a new BoundedFIFO with a maximum size passed as argument.
   *
   * @param size Maximum size of the BoundedFIFO created.
   */
  public BoundedFIFO(int size) {
    if (size < 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
  }

  /**
   * Get the first element in the buffer. Returns <code>null</code> if
   * there are no elements in the buffer.
   */
  public LoggingEvent get() {
    if (numElts == 0)
      return null;
    LoggingEvent r = buf[next];
    if (++first == size)
      first = 0;
    numElts--;
    return r;
  }

  /**
   * Place a {@link LoggingEvent} in the buffer. If the buffer is full  then
   * the event is <b>silently dropped</b>. It is the caller's  responsibility
   * to make sure that the buffer has free space.
   * 
   * @param o The logging event added into the buffer.
   */
  public void put(LoggingEvent o) {
    if (numElts != size) {
      buf[next] = o;
      if (++next == size)
        next = 0;
      numElts++;
    }
  }

  /** 
   * Get the maximum size of the buffer.
   */
  public int getMaxSize() {
    return size;
  }

  /**
   * Get the number of elements in the buffer. This number is guaranteed to be
   * in the range 0 to <code>maxSize</code> (inclusive).
   */
  public int length() {
    return numElts;
  }

  /**
   * Returns <code>true</code> if there is just one element in the buffer. In
   * other words, if there were no elements before the last {@link #put}
   * operation completed.
   */
  public boolean wasEmpty() {
    return numElts == 1;
  }

  /**
   * Returns <code>true</code> if the number of elements in the buffer plus 1
   * equals the maximum buffer size, returns <code>false</code> otherwise.
   */
  public boolean wasFull() {
    return numElts + 1 == size;
  }

  /**
   * Returns <code>true</code> if the number of elements in the buffer equals
   * the maximum buffer size, returns <code>false</code> otherwise.
   */
  public boolean isFull() {
    return numElts == size;
  }
}
]]></programlisting>
    </sect3>
    
    <sect3>
      <title>Create <classname>BlockingFIFO</classname></title>

      <para>Create a new class <classname>test.BlockingFIFO</classname>, and replace its
      contents with the following</para>

      <programlisting><![CDATA[
package test;

public class BlockingFIFO {
  private final BoundedFIFO fifo;;

  public BlockingFIFO(int size) {
    fifo = new BoundedFIFO(size);
  }

  public void put(LoggingEvent e) {
    synchronized (this) {
      while (fifo.isFull()) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      fifo.put(e);
      if (fifo.wasEmpty()) {
        fifo.notify();
      }
      fifo.put(e);
      fifo.put(e);
    }
  }

  public LoggingEvent get() {
    synchronized (fifo) {
      LoggingEvent e;
      while (fifo.length() == 0) {
        try {
          fifo.wait();
        } catch (InterruptedException ie) {
          // ignore
        }
      }
      e = fifo.get();
      if (fifo.wasFull()) {
        fifo.notify();
      }
      return e;
    }
  }

  public int length() {
    synchronized (fifo) {
      return fifo.length();
    }
  }
}
]]></programlisting>
    </sect3>
    
    <sect3>
      <title>Create <classname>LoggingEvent</classname></title>

      <para>Create a new class <classname>test.LoggingEvent</classname>, and replaced its
      contents with the following</para>

      <programlisting><![CDATA[
package test;

public class LoggingEvent { 
  // This class is not interesting
}
]]></programlisting>
    </sect3>
    
    <sect3>
      <title>Add the SureLogic Annotation Types</title>
      
      <para>Before we can add annotations to the project, we need to add the
      SureLogic annotation types to the class path:
        <orderedlist>
          <listitem>
            <para>Copy <filename>promises.jar</filename> to the project.  [TODO: 
            Where to get this file from!]</para>
          </listitem>
          <listitem>
            <para>Select <filename>promises.jar</filename> in the
            project and choose <menuchoice><guisubmenu>Build
            Path</guisubmenu> <guimenuitem>Add to Build
            Path</guimenuitem></menuchoice> from the context menu to add
            it to the project&rsquo;s build path.</para>
          </listitem>
        </orderedlist>
      </para>
    </sect3>
  </sect2>
  
  <sect2 id="declaring-protected-state">
    <title>Declaring Protected State</title>
    
    <para>The <classname>BoundedFIFO</classname> class is a buffer
    meant to be shared between two threads. It obviously must be made
    thread-safe. The usual assumption is that an object protects its
    own state, and we intend for that to be the case here.  Declare this 
    design intent by adding a <classname>>@RegionLock</classname> annotation
    to the class <classname>BoundedFIFO</classname>:</para>
    
    <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  &hellip;
}
    </programlisting>

    <para>Adding the annotation is not enough to get assurance.  We must enable
    assurance for the BoundedFIFO project:
      <orderedlist>
        <listitem>
          <para>Select the project in the <guilabel>Package Explorer</guilabel>.</para>
        </listitem>
        <listitem>
          <para>Press the icon <guiicon><inlinegraphic
          fileref="images/jsure_verify.gif"/></guiicon> in the
          <guilabel>Package Explorer</guilabel> toolbar.</para>
        </listitem>
      </orderedlist>
    </para>

    <para>With this single annotation, analysis by JSure produces two
    main concurrency results, mostly indicating that the annotation is
    not assured, and a few warnings.  There are 27 unprotected field
    accesses for <structfield>BufLock</structfield>, and no protected
    field accesses:</para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO1.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO1.png"/>
      </imageobject>
    </mediaobject>
  </sect2>

  <sect2 id="declaring-lock-preconditions">
    <title>Declaring Lock Preconditions</title>
  
    <para>Either this class is horribly broken or something else is
    going on.  By double clicking on any of the errors in the view, we
    can focus on the source line in
    <classname>BoundedFIFO</classname>. A quick inspectiion of the
    class reveals that it does not acquire the lock anywhere.  So we
    look at its clients by viewing the call chain, in this case by
    viewing the call hierarchy of method <function>get()</function>
    (Select the method <function>get()</function> in the &ldquo;Outline&rdquo;
    view and then choose <menuchoice><guimenuitem>Open Call
    Hierarchy</guimenuitem></menuchoice> in the context menu).  We see
    that the client, <classname>BlockingFIFO</classname> acquires the
    lock on the <classname>BoundedFIFO</classname> object before
    invoking any of the methods on the
    <classname>BoundedFIFO</classname> object, so we decide that the
    intent is that the caller should acquire the lock before calling
    any of the methods of <classname>BoundedFIFO</classname>.</para>

    <para>To add this intent to <classname>BoundedFIFO</classname>, we
    need to add the lock precondition
    <classname>@RequiresLock("BufLock")</classname> to all the methods
    of the class.  We can do this in a single annotation on the class
    itself by using a <emphasis>scoped promise</emphasis> to add the
    annotation to all the methods of the class:</para>
  
    <programlisting>
 @RegionLock("BufLock is this protects Instance")
 <emphasis>@Promise("'@RequiresLock BufLock' for *(**)")</emphasis>
 public class BoundedFIFO {
   &hellip;
 }
    </programlisting>  

    <para>After adding the annotation we save (and thus reanalyze the
    project).</para>
  </sect2>  
  
  <sect2 id="wrong-lock">
    <title>Wrong Lock</title>
    
    <para>There is now a &ldquo;scoped promises&rdquo; heading, and we can see all
    the places where our <classname>@Promise</classname> annotation
    added <classname>@RequiresLock</classname> annotations. Only 4 out
    of the 7 are currently satisfied:</para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO2.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO2.png"/>
      </imageobject>
    </mediaobject>
    
    <para>Looking at the chain of evidence for the call to
    <function>isFull()</function>, we see that the caller is
    confused and is synchronized on <parameter>this</parameter> (as
    evidenced by the caller holding the lock <code>this.MUTEX</code>):</para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO3.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO3.png"/>
      </imageobject>
    </mediaobject>

    <para>But in the context of the caller,
    <classname>BlockingFIFO</classname>, <parameter>this</parameter>
    refers to the <classname>BlockingFIFO</classname> object, not the
    <classname>BoundedFIFO</classname> object that is correctly
    refered to by <structfield>fifo</structfield>. The
    <code>synchronized</code> statement in method
    <function>isFull()</function> needs to be changed:</para>

    <programlisting>
 public void put(LoggingEvent e) {
   synchronized (<emphasis>fifo</emphasis>) {
     &hellip;
   }
 }
    </programlisting>
  </sect2>
  
  <sect2 id="single-threaded-constructor">
    <title>Single Threaded Constructor</title>

    <para>There are still five unprotected field accesses. These all
    point to either field initializers in field declarations or in the
    constructor: </para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO4.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4.png"/>
      </imageobject>
    </mediaobject>
  
    <para>Because the lock on the <classname>BoundedFIFO</classname>
    object is not held during construction, we need to make sure that
    during construction a reference to the object cannot be leaked to
    another thread. Note that we cannot require the caller of the
    constructor to hold the lock because the object does not exist yet!
     In general, we cannot use <code>synchronized</code> blocks in the
    constructor to protect the state during construction because we
    cannot create a single atomic block: there would have to be
    multiple distinct <code>synchronized</code> blocks in the
    constructor and in the constructors of any subclasses. But if we
    can guarantee that the thread that invokes the constructor is the
    only thread that can access the newly created object during the
    life of the invoked constructor, we can also be assured there will
    be no race conditions involving the object&rsquo;s fields during
    construction. We use a pair of annotations on the constructor to
    declare this intent:</para>

    <programlisting>
 <emphasis>@SingleThreaded</emphasis>
 <emphasis>@Borrowed("this")</emphasis>
 public BoundedFIFO(int size) {
   &hellip;
 }
    </programlisting>
    
    <para>The first declares that no new threads are starting during
    the execution of the constructor.  The second that no aliases to
    the newly constructed object will be created during the execution
    of the constructor.  The assurance of the
    <classname>@SingleThreaded</classname> annotation actually depends
    in part on the assurance of the <classname>@Borrowed</classname>
    annotation.</para>

    <para>Save and reanalyze. The model now assures:</para>

    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO4-1.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-1.png"/>
      </imageobject>
    </mediaobject>
    
    <sect3 id="deep-analysis">
      <title>Deep Analysis</title>
      
      <para>As stated above, the assurance of
      <classname>@SingleThreaded</classname> depends on the assurance
      of <classname>@Borrowed("this")</classname> on the constructor.
      We can see this by</para>
      
      <itemizedlist>
        <listitem><para>Removing the <classname>@Borrowed</classname>
        annotation.</para></listitem>
        <listitem><para>Changing the code to be inconsistent with the
        annotation.</para></listitem>
      </itemizedlist>

      <para>If we remove the <classname>@Borrowed</classname>
      annotation, the assurance now fails:</para>
      
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/BoundedFIFO4-2.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-2.png"/>
        </imageobject>
      </mediaobject>

      <para>Here we see that the 27 protected field accesses heading
      has a red X because assurance of some of the accesses depends on
      the constructor being single threaded, and the
      <classname>@SingleThreaded</classname> annotation is not
      assured.</para>

      <para>We can reinstate the <classname>@Borrowed</classname>
      annotation and instead make the code inconsistent by changing
      the constructor to alias the receiver (in this case by storing a
      reference to it in a <code>static</code> field):</para>
     
<programlisting>
@RegionLock("BufLock is this protects Instance")
@Promise("'@RequiresLock BufLock' for *(**)")
public class BoundedFIFO {
  &hellip;
  static BoundedFIFO foo;

  @SingleThreaded
  @Borrowed("this")
  public BoundedFIFO(int size) {
    if (size &lt; 1)
      throw new IllegalArgumentException();
    this.size = size;
    buf = new LoggingEvent[size];
    
    foo = this; <lineannotation>(Line 59)</lineannotation>
  }
  &hellip;
}
      </programlisting>
      
      <para>Again, we see that assurance fails:</para>

      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/BoundedFIFO4-3.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-3.png"/>
        </imageobject>
      </mediaobject>
      
      <para>In this case, we can see that the assurance of
      <classname>@SingleThreaded</classname> fails because the
      <classname>@Borrowed</classname> annotation is violated by the
      code at line 59.</para>
    </sect3>
    
    <sect3 id="deeper-analysis">
      <title>Deeper Analysis</title>
      
      <para>The analysis used to assure
      <classname>@Borrowed</classname> is sophisticated, and it does
      allow temporary local aliases to the receiver.  If the
      constructor were instead</para>
      
      <programlisting>
@SingleThreaded
@Borrowed("this")
public BoundedFIFO(int size) {
  if (size &lt; 1)
    throw new IllegalArgumentException();
  this.size = size;
  buf = new LoggingEvent[size];
    
  <emphasis>BoundedFIFO local = this;</emphasis>
}
      </programlisting>
      
      <para>then the class would still assure because</para>
      
      <itemizedlist>
        <listitem><para>The alias to <parameter>this</parameter> in
        <varname>local</varname> is never itself aliased to a global
        location.</para></listitem>
        <listitem><para>The alias disappears when the constructor finishes
        executing.</para></listitem>
      </itemizedlist>
      
      <mediaobject>
        <imageobject condition="isHTML">
          <imagedata fileref="images/BoundedFIFO4-4.png"/>
        </imageobject>
        <imageobject condition="isFO">
          <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO4-4.png"/>
        </imageobject>
      </mediaobject>
    </sect3>
  </sect2>
  
  <sect2 id="aggregated-state">
    <title>Aggregated State</title>
    
    <para>We now have no red Xs, but we still have 2 warnings about
    references to possibly shared objects:</para>

    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO5.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO5.png"/>
      </imageobject>
    </mediaobject>

    <para>These 2 warnings refer to access to the contents of the
    array referenced by the field <structfield>buf</structfield>. This
    array is an object separate from the
    <classname>BoundedFIFO</classname> object and is not protected by
    the lock protecting the fields of the
    <classname>BoundedFIFO</classname> object. We can extend
    protection to the contents of the array by declaring the array
    reference to be <classname>@Unique</classname>&mdash;no object but
    the <classname>BoundedFIFO</classname> object can hold a reference
    to it&mdash;and then by declaring that the state of the array is
    part of the state of the <classname>BoundedFIFO</classname>
    object:</para>
    
    <programlisting>
 @RegionLock("BufLock is this protects Instance")
 @Promise("'@RequiresLock BufLock' for *(**)")
 public class BoundedFIFO {
   <emphasis>@Unique</emphasis>
   <emphasis>@Aggregate("Instance into Instance")</emphasis>
   LoggingEvent[] buf;
   &hellip;
 }
    </programlisting>
    
    <para>Now, as part of the state of the
    <classname>BoundedFIFO</classname> object, the array object
    referenced by <structfield>buf</structfield> is also protected by
    the lock that protects that state of the buffer.</para>

    <para>Aftering saving (and reanalyzing) we can see the effects of
    this annotation: there are now 29 protected field accesses, up
    from 27. This is because the two array dereferences are now
    counted as protected accesses (lines 71 and 89):</para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO5b.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO5b.png"/>
      </imageobject>
    </mediaobject>      
  </sect2>
  
  <sect2 id="assured">
    <title>Assurance Acheived</title>
  
    <para>The project is now fully assured:</para>

    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/BoundedFIFO6.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/BoundedFIFO6.png"/>
      </imageobject>
    </mediaobject>      
  </sect2>
</sect1>
