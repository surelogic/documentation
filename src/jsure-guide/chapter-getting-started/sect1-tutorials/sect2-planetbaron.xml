<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect2 id="planetbaron"
    xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Verifying PlanetBaron</title>
  
  <para>This example demonstrates more sophisticated annotations and
  analysis results using a simple network capture the planet game:
  <application>PlanetBaron</application>.  It will use the tutorial
  project <application>PlanetBaronJSure</application>.</para>

  <para>The <application>PlanetBaronJSure</application> does not
  compile because it already contains JSure annotations. Add the
  needed annotation library by selecting
  <menuchoice><guimenuitem>JSure</guimenuitem><guimenuitem>Add/Update
  Promises Library...</guimenuitem></menuchoice> from the Eclipse main menu.</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/quick-start-add-jar.png" />
      </imageobject>
    </mediaobject>

  <para>In the dialog that appears select the
  <application>PlanetBaronJSure</application> project and press
  <guimenuitem>OK</guimenuitem>.</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/tutorial-add-jar-dialog.png" />
      </imageobject>
    </mediaobject>

   <para>At this point the project should compile without errors.</para>

  <para>Enable assurance for the PlanetBaronJSure project by selecting
  <menuchoice><guimenuitem>JSure</guimenuitem><guimenuitem>Focus
  Verification...</guimenuitem></menuchoice> and again choosing the
  <application>PlanetBaronJSure</application> project in the dialog
  that appears. Finally, press <guimenuitem>OK</guimenuitem>.  This
  project already contains lock model annotations about its locking
  policies, not all of which assure. In the rest of this example we
  fix these assurance failures.</para>
  
  <sect3>
    <title>Running PlanetBaron</title>

    <para>Although we do not need to run
    <application>PlanetBaron</application> to  it with JSure, it
    is helpful in the discussion below to know what the game does.  In
    particular, it makes it easier to understand the roles of the
    classes encountered in the assurance results. 
    <application>PlanetBaron</application> is a network-based real-time
    strategy game. It contains three programs:
      <itemizedlist>
        <listitem>
          <para>A server program that manages game state.</para>
        </listitem>
        <listitem>
          <para>A client user interface program that allows players to
          interact with the game.</para>
        </listitem>
        <listitem>
          <para>A program, called the chat-test client, that allows
          direct interaction with the server. The chat-test client is
          used to shutdown a running server.</para>
        </listitem>
      </itemizedlist>
    </para>
    
    <para>Let us run a <application>PlanetBaron</application> game. In
    the <guilabel>Package Explorer</guilabel>, select
    <filename>Server.java</filename> in the
    <package>com.surelogic.jsure.planetbaron.server</package> package.  Select
    <menuchoice><guisubmenu>Run As</guisubmenu> <guimenuitem>Java
    Application</guimenuitem></menuchoice> in the context menu. You
    should see following output in the <guilabel>Console</guilabel>
    view which indicates that the server has started successfully:

      <screen>
[INFO "server-main"] PlanetBaron game server listening for clients on port 8693 and playing on a 15x15 map [com.surelogic.jsure.planetbaron.server.Server.startListening()]
      </screen>
    </para>

    <para>Now we need to add some players. Select
    <filename>PlayerUI.java</filename> in the
    <package>com.surelogic.jsure.planetbaron.client</package> package. Select
    <menuchoice><guisubmenu>Run As</guisubmenu> <guimenuitem>Java
    Application</guimenuitem></menuchoice> in the context menu. You
    will see a Swing application start that has a blank grid. In the
    lower right-hand-corner enter a player name,
    <userinput>Laurel</userinput>, and press
    <guibutton>Connect</guibutton>.</para>
    
    <para>The screen will change to contain several planets and one
    ship with <guilabel>Laurel</guilabel> as its label. By moving your
    mouse around the grid you can direct your ship. Place your mouse
    over a planet and left-click.  This action will cause your ship to
    move slowly to that planet. When your ship arrives you will become
    the owner of that planet. This is called &ldquo;taking
    ownership&rdquo; of a planet. Go ahead an take ownership of a
    planet. Note that while your ship is moving you are not allowed to
    change its destination. Once it arrives at the destination you
    selected you can then select a subsequent destination.</para>

    <para>Now, go back to Eclipse and start a second instance of
    <filename>PlayerUI.java</filename>. In the lower right-hand-corner
    enter a player name, <userinput>Hardy</userinput>, and press
    <guibutton>Connect</guibutton>.</para>

    <para>The game supports as many players as you choose to connect to
    the server. Notice that the planets that Laurel owns are red in the
    Hardy PlayerUI while they are white in the Laurel PlayerUI. Moving
    back and forth between the two PlayerUIs move the ships to play the
    game. Note that the idea of the game is to own as many planets as
    you can. A game screenshot is shown in <xref linkend="fig-PlayerUI"/>.</para>
    
    <figure id="fig-PlayerUI">
      <title>The PlanetBaron PlayerUI for Laurel</title>
      
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/PlayerUI.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>To finish the game press <guibutton>Disconnect</guibutton> in
    both PlayerUI instances and then terminate the programs by normally.
    This action ends both player user interfaces but
    the server is still running. To terminate the server we need to use
    the chat-test client program.</para>

    <para>Select <filename>ChatTestClient.java</filename> in the
    <package>com.surelogic.jsure.planetbaron.client</package>
    package. <menuchoice><guisubmenu>Run As</guisubmenu>
    <guimenuitem>Java Application</guimenuitem></menuchoice> in the
    context menu.  You will see a Swing application start. This
    program allows you to directly control the game server. We want to
    use it to shutdown the game server. To do this, press
    <guibutton>Connect</guibutton> to connect to the game server and
    enter <userinput>shutdown</userinput> as the command. Your screen
    should now look like the one shown in <xref
    linkend="fig-chat-test-client"/>.</para>
    
    <figure id="fig-chat-test-client">
      <title>The ChatTestClient</title>
      
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/chat-test-client.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Press <guibutton>Send</guibutton> to shutdown the server. A
    dialog will appear stating that the server has disconnected from the
    ChatTestClient that you may dismiss. You can now terminate the
    ChatTestClient. Back in the Eclipse
    console for the server you should see the following message:
    
      <screen>
&hellip;      
[INFO "server-main"] PlanetBaron game server shutdown complete [com.surelogic.jsure.planetbaron.server.Server.startListening()]
      </screen>
    </para>
      
    <para>We are now ready to use JSure to assure
    <application>PlanetBaron</application>.</para>
  </sect3>
  
  <sect3 id="init-results">
    <title>Initial Assurance Results</title>
    
    <para>The initial assurance results for the PlanetBaronJSure
    project are shown in <xref
    linkend="fig-pb-initial-state"/>.</para>
    
    <figure id="fig-pb-initial-state">
      <title>Initial assurance results for PlanetBaron</title>
      
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-initial-state.png" />
        </imageobject>
      </mediaobject>
    </figure>
    
    <para id="lock-viz-problems">The lock model for lock
    <structfield>ThingLock</structfield> in class
    <classname>com.surelogic.jsure.planetbaron.game.Thing</classname>
    fails to assure. This project also has two modeling problems
    listed in the <guilabel>Modeling Problems</guilabel> view. This
    view displays problems with the annotations themselves. By default
    this view only becomes visible when modeling problems exist in
    your project.  Almost always these are annotation syntax errors,
    and the erroneous annotations are ignored by JSure.  Results under
    this heading include parsing problems with annotation contents,
    name resolution errors (for example, naming a region that does not
    exist in a <classname>@Region</classname> annotation), and
    semantic errors (for example, using the object referenced by a
    non-<code>static</code> field as the lock for a
    <code>static</code> field).  In this case, however, we have two
    instances of the same warning: the visibility of the field that
    references a lock object is less visible than the region protected
    by that lock.  This is potentially problematic because it means
    there are contexts in which the region is visible, but the lock
    needed to access that region is not visible.  One of these
    warnings refers to the the lock
    <structfield>ThingLock</structfield>&mdash;a lock we look more
    closely at in the following sections&mdash;and the other refers to
    the lock <structfield>MapLock</structfield>.  Whether this will be
    a problem for us remains to be seen.</para>
  </sect3>
  
  <sect3>
    <title>Introducing ThingLock</title>
    
    <para>As can be seen in <xref linkend="fig-pb-initial-state"/>,
    the code is inconsistent with the
    <structfield>ThingLock</structfield> annotation.  This lock is
    declared in the class
    <classname>com.surelogic.jsure.planetbaron.game.Thing</classname>:
    
      <programlisting linenumbering="numbered" startinglinenumber="20"><emphasis>@RegionLock("ThingLock is f_lock protects Instance")</emphasis>
public abstract class Thing {

  /**
   * A logger for subclasses.
   */
  protected static final Logger LOG = ConciseFormatter.getLogger("things");

  private final GameMap f_map; // immutable

  @Unique("return")
  Thing(GameMap map) {
    assert map != null;
    f_map = map;
  }

  @Borrowed("this")
  public GameMap getMap() {
    return f_map;
  }

  /**
   * Protects the state of this object including state added by subclasses.
   */
  <emphasis>protected final ReadWriteLock f_lock = new ReentrantReadWriteLock();</emphasis>
}</programlisting>

    The lock <structfield>ThingLock</structfield> associates the lock
    object referenced by <structfield>f_lock</structfield> with the
    class's non-<code>static</code> state.  In this case, the lock
    field <structfield>f_lock</structfield> refers to a
    <classname>java.util.concurrent.lock.ReadWriteLock</classname>
    object.  JSure understands the semantics of these locks, in
    particular that

      <itemizedlist>
        <listitem><para>Each <function>lock()</function> call must be
        matched to a <function>unlock()</function> call, and vice
        versa.</para></listitem>
        
        <listitem><para>The protected region must not be written to
        when only the read lock is held.</para></listitem>
      </itemizedlist>
    </para>
    
    <para>Class <classname>Thing</classname> is the superclass for all
    the &ldquo;things&rdquo; in the game: it has the subclasses
    <classname>Player</classname>, <classname>Planet</classname>, and
    <classname>Ship</classname>.  The lock annotation thus binds the
    implementations of these subclasses as well, extending its
    protection to all the instance fields declared in them. </para>
    
    <para>Digging into the results for
    <structfield>ThingLock</structfield> we see that model-code
    consistency is prevented by one unprotected field access and three
    inconsistent lock preconditions:
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-thing-lock-start.png" />
        </imageobject>
      </mediaobject>

    We can also see, by the "i" result near the bottom, that JSure
    matches up <function>lock()</function> and
    <function>unlock()</function> calls. Calls to
    <function>lock()</function> and <function>unlock()</function> are
    tracked separately because they do not need to be matched up
    one-to-one. JSure will also flag if <function>lock()</function> or
    <function>unlock()</function> cannot be matched or if it matches
    inconsistently along different control-flow paths.</para>
  </sect3>

  <sect3>
    <title>Unprotected Field Access</title>

    <para>We first look at the unprotected field access:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-unprotected-field.png" />
        </imageobject>
      </mediaobject>

      The field <structfield>f_location</structfield> is read without
      holding the read lock in the class <classname>Ship</classname>.
      Before even looking at the field access, we emphasize that this
      error occurs in a <emphasis>subclass of
      <classname>Thing</classname></emphasis>, and that the field
      <structfield>f_location</structfield> is declared in
      <classname>Ship</classname>.  The erroneous access occurs in the
      method <function>Ship.moveTo()</function>:

        <programlisting linenumbering="numbered" startinglinenumber="155">  public void moveTo(Location destination) {
    if (isMoving())
      throw new IllegalStateException(
          "a moving ship can't change its destination");

    if (<emphasis>f_location</emphasis>.equals(destination)) {
      LOG.log(Level.WARNING,
          "ignored attempt to move ship to its current location");
    } else {
      <emphasis>f_lock.writeLock().lock();</emphasis>
      try {
        f_isMoving = true;
        f_turnsMoving = 0;
        f_destination = destination;
        f_moveDistance = f_location.distanceTo(f_destination);
        f_percentageMoved = 0.0;
        sendReport(); // OK to invoked holding a write lock
      } finally {
        <emphasis>f_lock.writeLock().unlock();</emphasis>
      }
    }
  }</programlisting>

    We see that the field access on line 160 in the condition of the
    <code>if</code>-statement occurs outside of the critical section
    that only spans the <code>else</code>-block.  We need to edit the
    method to expand the critical section to contain the entire
    conditional statement:

      <programlisting>  public void moveTo(Location destination) {
    if (isMoving())
      throw new IllegalStateException(
          "a moving ship can't change its destination");

    f_lock.writeLock().lock();
    try {
      if (f_location.equals(destination)) {
        LOG.log(Level.WARNING,
            "ignored attempt to move ship to its current location");
      } else {
        f_isMoving = true;
        f_turnsMoving = 0;
        f_destination = destination;
        f_moveDistance = f_location.distanceTo(f_destination);
        f_percentageMoved = 0.0;
        sendReport(); // OK to invoked holding a write lock
      }
    } finally {
      f_lock.writeLock().unlock();
    }
  }</programlisting>
    </para>

    <para>After making the change, saving, and reassuring, we have 54
    protected field accesses, up from the previous 53:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-field-access-corrected.png" />
        </imageobject>
      </mediaobject>
    </para>
  </sect3>

  <sect3>
    <title>Read&ndash;Write Locks</title>

    <para>You can demonstrate to yourself that JSure understands the
    when the read component and when the write component of a
    read&ndash;write lock needs to be held by changing lines 160 and
    174 of <function>Ship.moveTo()</function> to acquire the read lock
    instead of the write lock:

      <programlisting linenumbering="numbered" startinglinenumber="155">  public void moveTo(Location destination) {
    if (isMoving())
      throw new IllegalStateException(
          "a moving ship can't change its destination");

    f_lock.<emphasis>readLock()</emphasis>.lock();
    try {
      if (f_location.equals(destination)) {
        LOG.log(Level.WARNING,
            "ignored attempt to move ship to its current location");
      } else {
        f_isMoving = true;
        f_turnsMoving = 0;
        f_destination = destination;
        f_moveDistance = f_location.distanceTo(f_destination);
        f_percentageMoved = 0.0;
        sendReport(); // OK to invoked holding a write lock
      }
    } finally {
      f_lock.<emphasis>readLock()</emphasis>.unlock();
    }
  }</programlisting>

    If you save these changes, the results show 49 protected field
    accesses and 5 unprotected field accesses:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-needs-write-lock.png" />
        </imageobject>
      </mediaobject>
      
    In particular, all the write access from the
    <code>else</code>-branch are unprotected because they require the
    write lock to be held, but only the read lock component of
    <structfield>ThingLock</structfield> is held.</para>

    <para>Restore the method to its previously corrected form by
    changing lines 160 and 174 to invoke
    <function>writeLock()</function> instead of
    <function>readLock()</function>.</para>
  </sect3>

  <sect3>
    <title>Unsatisfied Preconditions</title>

    <para>We now move on to the three unsatisfied lock preconditions.
    Expanding the results as shown in <xref linkend="fig-pb-unsatisfied-preconditions"/> reveals
     
     <itemizedlist>
       <listitem>
	 <para>The method <function>drawPlanet()</function> of class
	 <classname>com.surelogic.jsure.planetbaron.client.MapView</classname>
	 requires the read lock to be held on its
	 <classname>Planet</classname> parameter.</para>
       </listitem>
       <listitem>
	 <para>The method <function>drawShip()</function> of class
	 <classname>MapView</classname> requires the read lock to be
	 held on its <classname>Ship</classname> parameter.</para>
       </listitem>
       <listitem>
	 <para>The method <function>drawShipMovementTrail()</function> of
	 class <classname>MapView</classname> requires the read lock
	 to be held on its <classname>Ship</classname>
	 parameter.</para>
       </listitem>
       <listitem>
	 <para>All three erroneous method calls originate in the
	 method <function>paintComponent()</function> of class
	 <classname>MapView</classname></para>
       </listitem>
     </itemizedlist>
    </para>

    <figure id="fig-pb-unsatisfied-preconditions">
      <title>Expanded precondition results</title>
      
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-unsatisfied-preconditions.png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>Looking at the method
    <function>MapView.paintComponent()</function>, we see that it draws
    the basic game map, and then iterates over all the ships and
    planets to draw them individually by calling the methods
    <function>drawShipMovementTrail()</function> (line 131),
    <function>drawPlanet()</function> (line 136), and
    <function>drawShip()</function> (line 142):

      <programlisting linenumbering="numbered" startinglinenumber="116">  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);

    final int height = getHeight();
    final int width = getWidth();

    // fill the entire component with black
    g.setColor(Color.black);
    g.fillRect(0, 0, width, height);

    drawGridOutline(g);

    for (Ship s : GameMap.getInstance().getShips()) {
      synchronized (s) {
        <emphasis>drawShipMovementTrail(g, s);</emphasis>
      }
    }
    for (Planet p : GameMap.getInstance().getPlanets()) {
      synchronized (p) {
        <emphasis>drawPlanet(g, p);</emphasis>
      }
    }
    drawCursor(g);
    for (Ship s : GameMap.getInstance().getShips()) {
      synchronized (s) {
        <emphasis>drawShip(g, s);</emphasis>
      }
    }
  }</programlisting>

    At first glance, it is not easy to see what is the problem because
    all the method calls originate from within
    <code>synchronized</code> blocks that do lock on the
    <classname>Ship</classname> or <classname>Planet</classname>
    object.
    </para>
  </sect3>

  <sect3>
    <title>Mixed Lock Paradigms</title>

    <para>The problem in this case is that the
    <code>synchronized</code> block is not the correct mechanism to
    acquire the needed locks.  As stated previously, the needed locks
    in this case are the read locks of the
    <classname>Ship</classname>/<classname>Planet</classname> objects,
    and these are acquired and released via explicit method calls.</para>

    <para>What if we, like the author of this method, were too
    forgetful to identify this problem on our own?  JSure has already
    pointed out this problem to us via three warnings that appear with
    the assurance results for <structfield>ThingLock</structfield>:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-mixed-usage-warnings.png" />
        </imageobject>
      </mediaobject>

    JSure generates three warnings, one for each bad synchronized
    statement, telling us that the object being synchronized on is not
    known to be a lock (because there is no relevant
    <classname>@RegionLock</classname> annotation), but that the
    <classname>f_lock</classname> field of each object is known to be
    a <package>java.util.concurrent</package> lock object named
    <structfield>ThingLock</structfield>. These warnings are meant to
    suggest that we are locking on the wrong object, and that perhaps
    we should be using the object referenced by the field
    <structfield>f_lock</structfield> as the lock instead.  A quick
    inspection of the <structfield>f_lock</structfield> field
    declaration tells us the lock is a
    <classname>ReadWriteLock</classname>.</para>

    <para>The call sites can be fixed by replacing the
    <code>synchronized</code> blocks with the appropriate
    <code>try</code>&ndash;<code>finally</code> blocks:

      <programlisting>  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);

    final int height = getHeight();
    final int width = getWidth();

    // fill the entire component with black
    g.setColor(Color.black);
    g.fillRect(0, 0, width, height);

    drawGridOutline(g);

    for (Ship s : GameMap.getInstance().getShips()) {
      <emphasis>s.f_lock.readLock().lock();</emphasis>
      <emphasis>try {</emphasis>
        drawShipMovementTrail(g, s);
      <emphasis>} finally {</emphasis>
        <emphasis>s.f_lock.readLock().unlock();</emphasis>
      <emphasis>}</emphasis>
    }
    for (Planet p : GameMap.getInstance().getPlanets()) {
      <emphasis>p.f_lock.readLock().lock();</emphasis>
      <emphasis>try {</emphasis>
        drawPlanet(g, p);
      <emphasis>} finally {</emphasis>
        <emphasis>p.f_lock.readLock().unlock();</emphasis>
      <emphasis>}</emphasis>
    }
    drawCursor(g);
    for (Ship s : GameMap.getInstance().getShips()) {
      <emphasis>s.f_lock.readLock().lock();</emphasis>
      <emphasis>try {</emphasis>
        drawShip(g, s);
      <emphasis>} finally {</emphasis>
        <emphasis>s.f_lock.readLock().unlock();</emphasis>
      <emphasis>}</emphasis>
    }
  }</programlisting>

    When you make these changes (or cut and paste them from above),
    you will see that the class <classname>MapView</classname> no
    longer compiles; see <xref
    linkend="fig-pb-paintComponent-errors"/>.  Eclipse complains that
    <computeroutput>The field Thing.f_lock is not
    visible</computeroutput>.  Of course, <link
    linkend="lock-viz-problems">as previously discussed</link>, this is
    just the situation that JSure is warning us about when it tells us
    that <computeroutput>lock field "this.f_lock" is less visible than
    region "Instance"; consider protecting a less visible region or adding a lock getter method on Lock ThingLock is this.f_lock protects
    Instance at Thing.java</computeroutput>.  Here, in class
    <code>MapView</code>, we cannot make use of the contents of the
    <classname>Ship</classname> and <classname>Planet</classname>
    objects because we cannot access the necessary lock.</para>

    <figure id="fig-pb-paintComponent-errors">
      <title>Compile-time errors after correcting the critical sections in <function>MapView.paintComponent()</function></title>
      
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-paintComponent-errors.png" />
        </imageobject>
      </mediaobject>
    </figure>
  </sect3>

  <sect3>
    <title>Fixing the Lock Visibility</title>

    <para>We could fix this problem by simply making the field
    <structfield>f_lock</structfield> <code>public</code> instead of
    <code>protected</code>.  Generally speaking, this violates the
    principles of data hiding and abstraction.  The superior
    alternative supported by JSure is to add a &ldquo;lock
    getter&rdquo; method to <classname>Thing</classname> to return the
    lock object.  We annotate this method with a
    <classname>@ReturnsLock</classname> annotation so JSure knows we
    intend to use it to return a lock object and assures that we do in
    fact return the correct lock object:

      <programlisting>
  @ReturnsLock("ThingLock")
  public final ReadWriteLock getThingLock() {
    return f_lock;
  }
      </programlisting>
    </para>

    <para>We can now update
    <function>MapView.paintComponent()</function> (again) to use the
    new lock getter method:

      <programlisting>  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);

    final int height = getHeight();
    final int width = getWidth();

    // fill the entire component with black
    g.setColor(Color.black);
    g.fillRect(0, 0, width, height);

    drawGridOutline(g);

    for (Ship s : GameMap.getInstance().getShips()) {
      s.<emphasis>getThingLock()</emphasis>.readLock().lock();
      try {
        drawShipMovementTrail(g, s);
      } finally {
        s.<emphasis>getThingLock()</emphasis>.readLock().unlock();
      }
    }
    for (Planet p : GameMap.getInstance().getPlanets()) {
      p.<emphasis>getThingLock()</emphasis>.readLock().lock();
      try {
        drawPlanet(g, p);
      } finally {
        p.<emphasis>getThingLock()</emphasis>.readLock().unlock();
      }
    }
    drawCursor(g);
    for (Ship s : GameMap.getInstance().getShips()) {
      s.<emphasis>getThingLock()</emphasis>.readLock().lock();
      try {
        drawShip(g, s);
      } finally {
        s.<emphasis>getThingLock()</emphasis>.readLock().unlock();
      }
    }
  }</programlisting>
    </para>

    <para>The class <classname>MapView</classname> now compiles, and
    we have JSure assurance results again.  Surprisingly, the lock
    preconditions still fail to assure:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-after-getThingLock.png" />
        </imageobject>
      </mediaobject>

    Do note, however, that the method
    <function>Thing.getThingLock()</function> is assured to return the
    correct lock object.</para>
  </sect3>

  <sect3>
    <title>One More Fix</title>

    <para>What is the lingering problem with the lock preconditions?
    To find out, we turn our attention once more to the
    <guilabel>Suggestions and warnings</guilabel> section of the
    results.  Here we find method
    <function>MapView.paintComponent()</function> contains 6
    &ldquo;non-final lock expressions:&rdquo;

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pb-non-final-locks.png" />
        </imageobject>
      </mediaobject>

    What does this mean?  In JSure, a lock expression is an expression
    used to reference a lock object.  For example <code>this</code> in
    <code>synchronized (this) { &hellip; }</code>.  A <emphasis>final
    lock expression</emphasis> is a lock expression that JSure can
    determine must always evaluate to the same value, that is, the
    expression is idempotent at run time.</para>

    <para>The problem in <function>paintComponent()</function> is that
    the local variables <varname>s</varname> and <varname>p</varname>
    are not <code>final</code>, so JSure is worried that the value of
    <varname>s</varname>, for example, at the time it is used to
    acquire the lock will not be the same as the value of
    <varname>s</varname> as the time it is used to release the lock.
    We can fix this by declaring <varname>s</varname> (at lines 129 and 146) and
    <varname>p</varname> (at line 137) to be <code>final</code>:

      <programlisting linenumbering="numbered" startinglinenumber="116">  @Override
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);

    final int height = getHeight();
    final int width = getWidth();

    // fill the entire component with black
    g.setColor(Color.black);
    g.fillRect(0, 0, width, height);

    drawGridOutline(g);

    for (<emphasis>final Ship s</emphasis> : GameMap.getInstance().getShips()) {
      s.getThingLock().readLock().lock();
      try {
        drawShipMovementTrail(g, s);
      } finally {
        s.getThingLock().readLock().unlock();
      }
    }
    for (<emphasis>final Planet p</emphasis> : GameMap.getInstance().getPlanets()) {
      p.getThingLock().readLock().lock();
      try {
        drawPlanet(g, p);
      } finally {
        p.getThingLock().readLock().unlock();
      }
    }
    drawCursor(g);
    for (<emphasis>final Ship s</emphasis> : GameMap.getInstance().getShips()) {
      s.getThingLock().readLock().lock();
      try {
        drawShip(g, s);
      } finally {
        s.getThingLock().readLock().unlock();
      }
    }
  }</programlisting>
    </para>

    <para>After making this change, the complete model for
    <structfield>ThingLock</structfield> assures:

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/pb-thing-lock-assures.png" />
      </imageobject>
    </mediaobject>

    There is one modeling problem remaining (as can be seen above),
    however, it is about the <code>GameMap</code> locking model. We
    leave this as an exercise for the reader to fix. There are several
    other locking models in this code that can be examined at your
    leisure.</para>
  </sect3>
</sect2>
