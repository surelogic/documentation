<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect2 id="util.concurrent"
    xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Verifying <package>util.concurrent</package></title>

  <para>In this example we examine <package>util.concurrent</package> from Doug
  Lea, a concurrency library that eventually grew into the current
  <package>java.util.concurrent</package> library.</para>
  
  <para>Load the oswego.util.concurrent project into your workspace
  using <menuchoice><guimenu>JSure</guimenu> <guimenuitem>Run JSure
  Tutorials</guimenuitem></menuchoice>.  The class
  <classname>SynchronizedVariable</classname> is the parent class of
  several thread-safe wrapper classes.  We can view this hierachy in
  Eclipse by
  
    <orderedlist>
      <listitem>
        <para>Selecting <menuchoice><guimenu>Navigate</guimenu>
        <guimenuitem>Open Type in
        Hierarchy&hellip;</guimenuitem></menuchoice>.</para>
      </listitem>
      <listitem>
        <para>Entering <classname>SynchronizedVariable</classname> in the
        resulting dialog box.</para>
      </listitem>
    </orderedlist>
  
  You should see a hierarchy like in <xref linkend="fig-sv-hierarchy"/>.
  </para>
  
  <figure id="fig-sv-hierarchy">
    <title>Class Hierarchy rooted at <classname>SynchronizedVariable</classname></title>
      
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/sv-hierarchy.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>In this example we model the locking policy of
  <classname>SynchronizedVariable</classname> and its subclasses.  Make
  sure to add the promises library to the probject, using
  <menuchoice><guimenu>JSure</guimenu> <guimenuitem>Add/Update
  Promises Library&hellip;</guimenuitem></menuchoice> for example.
  We start by annotating <classname>SynchronizedVariable</classname>:
  
    <programlisting><emphasis>@Region("protected VarState")</emphasis>
<emphasis>@RegionLock("VarLock is lock_ protects VarState")</emphasis>
public class SynchronizedVariable implements Executor {
  &hellip;
}</programlisting>

  This creates an empty <code>protected</code> (as in protected visibility) region
  called <structfield>VarState</structfield> that is protected by
  holding a lock on the object referenced by the field
  <structfield>lock_</structfield>. The class
  <classname>SychronizedVariable</classname> does not have any fields
  besides the lock reference: it is in the subclasses that we need to
  map data into <structfield>VarState</structfield>.  A subclass can
  add state to any region declared in a superclass that is visible to it
  according to standard Java visibility rules.  Add the following to
  the <structfield>value_</structfield> field in class
  <classname>SynchronizedLong</classname> and save:

    <programlisting>  <emphasis>@InRegion("VarState")</emphasis>
  protected long value_;</programlisting>
  
  At this point, you should have the following verification results:
  
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/sv-initial.png" />
      </imageobject>
    </mediaobject>
  </para>
  
  <para>The model fails to assure because there are three unprotected field
  accesses.  Closer inspection (by clicking on the results) reveals that
  the first two of these are field initializations in the class&rsquo;s constructors.
  In the case of the constructors <function>SynchronizedLong(long)</function>
  and <function>SynchronizedVariable()</function>, we cannot use the annotation
  <classname>@Unique("return")</classname> because the constructor
  <function>SynchronizedVariable()</function> aliases the new object into the
  field <structfield>lock_</structfield>:
  
    <programlisting>  /**
   * Create a SynchronizedVariable using itself as the lock
   **/
  public SynchronizedVariable() {
    lock_ = this;
  }</programlisting>
  
  Instead we need to use state and thread effects to establish that the 
  constructors are thread-confined.  In general, a constructor is also
  considered to be thread-confined if it does not start any threads
  and only writes to the object under construction.  This prevents
  the thread executing the constructor from passing information to
  any new or existing threads, respectively.  The constructor may
  declare any amount of read effects.  In this case, it is sufficient
  to declare that the constructors have no effects.
  </para>
  
  <para>Annotate the constructors to be thread-confined by adding
  
    <programlisting>  @Unique("return")</programlisting>
    
  to <function>SynchronizedVariable(Object)</function> and 
  <function>SynchronizedLong(long, Object)</function>, and
  by adding 
  
    <programlisting>  @RegionEffects("none")
  @Starts("nothing")</programlisting>
  
  to <function>SynchronizedVariable()</function> and 
  <function>SynchronizedLong(long)</function>.  Aftering saving
  and reassuring the project, there is still one unprotected
  field access:

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/sv-thread-confined.png" />
      </imageobject>
    </mediaobject>
  </para>
  
  <para>The unprotected access is in the <code>return</code>
  statement of the <function>swap</function> method:
  
    <programlisting>  public long swap(SynchronizedLong other) {
    if (other != this) {
      SynchronizedLong fst = this;
      SynchronizedLong snd = other;
      if (System.identityHashCode(fst) > System.identityHashCode(snd)) {
        fst = other;
        snd = this;
      }
      synchronized (fst.lock_) {
        synchronized (snd.lock_) {
          fst.set(snd.set(fst.get()));
        }
      }
    }
    return value_;
  }</programlisting>
  
  This is incorrect for two reasons: (1) By occuring outside of the 
  synchronized blocks the return is not atomic with the rest of the method
  and thus another thread could alter the value of the <structfield>value_</structfield>
  before <function>swap</function> returns. And (2) Java does guarantee that a read of 
  the two 32-bit halves of a <code>long</code> value is atomic.</para>
  
  <para>This method is tricky to fix because of its preamble which
  both short-circuits the swap if both objects are the same, and (2)
  sorts the objects according to their identity hash code to establish a 
  global lock ordering to prevent deadlock.  To correct the method and
  preserve the atomicity intent (which is not assured by JSure), 
  we must change it to 
  
    <programlisting>  public long swap(SynchronizedLong other) {
    if (other == this) return get();
    SynchronizedLong fst = this;
    SynchronizedLong snd = other;
    if (System.identityHashCode(fst) > System.identityHashCode(snd)) {
      fst = other;
      snd = this;
    }
    synchronized (fst.lock_) {
      synchronized (snd.lock_) {
        fst.set(snd.set(fst.get()));
        return get();
      }
    }
  }</programlisting>
  
  Using the <code>synchronized</code> <function>get</function> method 
  helps aleviate the problem that it is not statically detectable
  to know whether the lock on <varname>fst</varname> or <varname>snd</varname> is
  the correct lock for <code>this.value_</code> inside the <code>synchronized</code>
  blocks.
  </para>
  
  <para>The lock model assures after making this change:
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/sv-final.png" />
      </imageobject>
    </mediaobject>
  </para>    
</sect2>
