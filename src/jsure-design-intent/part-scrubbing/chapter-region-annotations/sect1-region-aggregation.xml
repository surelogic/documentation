<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect1>
  <title>Region Aggregation</title>
  
  <para>When a field refers to a <classname>@Unique</classname>
  reference, the regions of the referenced object must be aggregated
  into the regions of the referring object. This effectively allows the
  referenced object to be treated as part of the referring object. This
  is achieved using the field annotation

    <synopsis>
@Aggregate("<co id="agg.src.region"/><replaceable>R<subscript>1</subscript></replaceable> into <co id="agg.dest.region"/><replaceable>Q<subscript>1</subscript></replaceable>, &hellip; <replaceable>R<subscript>n</subscript></replaceable> into <replaceable>Q<subscript>n</subscript></replaceable>")<co id="agg.n"/>
    </synopsis>
    
    <calloutlist>
      <callout
      arearefs="agg.src.region"><para><replaceable>R<subscript>i</subscript></replaceable> are regions of the annotated
      field's class.</para></callout>

      <callout
      arearefs="agg.dest.region"><para><replaceable>Q<subscript>i</subscript></replaceable> are regions of the class
      that declares the field.</para></callout>

      <callout arearefs="agg.n"><para><replaceable>n</replaceable>
      &ge; 1.</para></callout>
    </calloutlist>

    <para>The flexibility of the aggregation depends on whether the
    annotated field is or is not <code>final</code>:
    
      <itemizedlist>
        <listitem><para>When the field is not <code>final</code>, all
        the regions of the referenced object must be mapped into regions
        of the object that contain the field. Generally, in this case,
        the best thing to do is to map the
        <structfield>Instance</structfield> region of the referenced
        object into the field itself, for example,
  
          <programlisting>
@Unique
@Aggregate("Instance into record")
protected PersonRecord record;
          </programlisting>
        </para></listitem>

        <listitem><para>When the field is <code>final</code>, the
        regions of the referenced object may be mapped more freely, as
        long as they respect the region hierarchy.</para></listitem>
      </itemizedlist>
    </para>
  </para>
  
  <para>The <classname>@Aggregate</classname> annotation may be used as
  a marker annotation, in which case it is equivalent to writing
  <code>@Aggregate("Instance into Instance")</code>:
  
    <programlisting>
@Unique
@Aggregate
protected final PersonRecord record;
    </programlisting>
  </para>        
  
  <sect2>
    <title>Constraints</title>
    
    <para>An <classname>@Aggregate</classname> annotation on a
    field <structfield>field</structfield> with class type
    <classname>D</classname> declared in a class
    <classname>C</classname> is subject to the following
    constraints:
      <itemizedlist>
        <listitem>
          <formalpara>
            <title>The field <structfield>field</structfield> must
            also be annotated with
            <classname>@Unique</classname></title>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>The type <classname>D</classname> must be a non-primitive type</title>
            
            <para>Practically, this is guaranteed by the first
            rule, because <classname>@Unique</classname> is only applicable to fields
            with a non-primitive type.</para>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title><replaceable>R<subscript>i</subscript></replaceable>
            must be a non-<code>static</code> region
            from class <classname>D</classname></title>
            
            <para>If <classname>D</classname> is an array, that is
            <classname>D</classname> &equiv;
            <classname>T[]&hellip;[]</classname>, then we treat
            <classname>D</classname> as if it is the class
            <classname>java.lang.Array</classname>.</para>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>Each
            <replaceable>R<subscript>i</subscript></replaceable>
            must be unique</title>
            
            <para>A region cannot be aggregated more than once.</para>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>If <structfield>field</structfield> is not
            <code>final</code> then
            <structfield>field</structfield> must be a subregion
            of or equal to each
            <replaceable>Q<subscript>i</subscript></replaceable></title>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title><replaceable>Q<subscript>i</subscript></replaceable> cannot be <code>final</code> or <code>volatile</code></title>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>If <structfield>field</structfield> is
            <code>final</code> and <code>static</code> then all regions
            <replaceable>Q<subscript>i</subscript></replaceable>
            must be <code>static</code></title>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>Each
            <replaceable>R<subscript>i</subscript></replaceable>
            must be accessible in the context of class
            <classname>C</classname></title>

            <para>It violates abstraction to refer to
            <code>private</code> regions of the referenced
            object.</para>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>Each
            <replaceable>Q<subscript>i</subscript></replaceable>
            must be accessible in the context of class
            <classname>C</classname></title>

            <para>It violates abstraction to refer to
            <code>private</code> regions of <classname>C</classname>'s ancestors.</para>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>All instance regions of
            <classname>D</classname> must be mapped into a region
            of <classname>C</classname></title>

            <para>Practically, speaking, this requirement means
            that the <structfield>Instance</structfield> of
            <classname>D</classname> must be explicitly aggregated
            into a region of <classname>C</classname>.</para>
          </formalpara>
        </listitem>
        
        <listitem>
          <formalpara>
            <title>Aggregation must respect the region
            hierarchy</title>

            <para>Formally, if the annotation maps
            <replaceable>R<subscript>i</subscript></replaceable>
            into
            <replaceable>Q<subscript>i</subscript></replaceable>
            and
            <replaceable>R<subscript>j</subscript></replaceable>
            into
            <replaceable>Q<subscript>j</subscript></replaceable>,
            and
            <replaceable>R<subscript>i</subscript></replaceable>
            is a subregion of
            <replaceable>R<subscript>j</subscript></replaceable>,
            then
            <replaceable>Q<subscript>i</subscript></replaceable>
            <emphasis>must</emphasis> be a subregion of
            <replaceable>Q<subscript>j</subscript></replaceable>.</para>
          </formalpara>
        </listitem>
      </itemizedlist>
    </para>
  </sect2>
</sect1>

