<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

    <chapter id="lock-annotations" xmlns:xi="http://www.w3.org/2001/XInclude">
      <title>Lock Annotations</title>
      
      <sect1>
        <title>Region Lock Declaration</title>
        
        <para>Region lock declarations have the form
          <synopsis>
@RegionLock("<co id="reg.lock.name"/><replaceable>lock</replaceable> is <co id="reg.lock.field"/><replaceable>field</replaceable> protects <co id="reg.lock.region"/><replaceable>region</replaceable>")          
          </synopsis>
          
          <calloutlist>
            <callout arearefs="reg.lock.name">
              <para>The name of the lock or <emphasis>lock id</emphasis>.</para>
            </callout>
            <callout arearefs="reg.lock.field">
              <para>The <emphasis>lock field</emphasis>: the name of a
              field, <structfield>class</structfield>,
              <parameter>this</parameter>, or a qualified
              <parameter>this</parameter> expression
              (<parameter><replaceable>class_name</replaceable>.this</parameter>).</para>
            </callout>
            <callout arearefs="reg.lock.region">
              <para>The name of a region.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2 id="lock.id.constraints">
          <title>Lock Id Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The lock id must be unique within the class and
                its ancestors</title>
                
                <para>That is, a class cannot declare a lock
                that has the same id as a lock declared in an ancestor.
                This simplifies things by eliminating name hiding.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
        
        <sect2 id="lock.field.constraints">
          <title>Lock Field Constraints</title>

          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The lock field must exist</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>If <replaceable>field</replaceable> is non-<code>static</code>, it must be
                from the class being annotated or one of its ancestors</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The lock field must be <code>final</code></title>
                
                <para>Otherwise the object referenced by the field could
                be changed and then JSure will not be able to guarantee
                that all <code>synchronized</code> statements that use
                that field are locking the same object.
                <parameter>this</parameter> and
                <structfield>class</structfield> are implicitly
                <code>final</code>.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The type of the lock field must not be primitive</title>
                
                <para>Java does not allow primitive types to be used in
                <code>synchronized</code> statements.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
        
        <sect2>
          <title>Region Constraints</title>

          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The region must exist</title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The region must not be associated with any other
                locks in the same class or its ancestors</title>
                
                <para>Mutual exclusion cannot be guaranteed if multiple
                locks protect the same region. For
                non-<code>static</code> regions, this means there cannot
                be an ancestor class <classname>S</classname>, where
                <classname>S</classname> could be the class containing
                the annotation in question, that also associates a lock
                with the region. For <code>static</code> regions, it
                means the class that declares the region cannot
                associate more than one lock with it. (A rule below
                requires that a <code>static</code> region can only be
                associated with a lock by the class that declares the
                region.)</para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>A <code>static</code> region must be protected by
                a <code>static</code> lock field, or
                <structfield>class</structfield></title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>A non-<code>static</code> region must be
                protected by a non-<code>static</code> lock field, or
                <parameter>this</parameter> or a qualified
                <parameter>this</parameter> expression</title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>If the region is <code>static</code>, it must be
                declared in the same class as the lock
                declaration</title>
                
                <para>It's not fair to impose locking constraints on a
                class from another class.</para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The lock field must be at least as visible as the region</title>

                <para>Otherwise, you have severely limited the
                usefulness of the region, because it won't be usable
                outside of the scope of the lock field. The field itself
                need not be declared to have the necessary visibility.
                The visibility of a lock field can be modified through
                the use of methods that are annotated with
                <classname>@ReturnsLock</classname>. So a
                <code>private</code> field can be used to protect a
                <code>protected</code> region as long as there is a
                <code>protected</code> (or <code>public</code>) method
                in the class that is declared to return the lock.</para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>If the region is inherited (not declared in the
                annotated class), it must not contain any fields</title>
                
                <para>It may have subregions, but those subregions
                cannot contain fields. This is necessary to prevent
                upcasting from being used to compromise lock
                policies.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>

      <sect1>
        <title>Policy Lock Declaration</title>
        
        <para>Policy lock declarations have the form
          <synopsis>
@RegionLock("<co id="policy.lock.name"/><replaceable>lock</replaceable> is <co id="policy.lock.field"/><replaceable>field</replaceable>")          
          </synopsis>
          
          <calloutlist>
            <callout arearefs="policy.lock.name">
              <para>The name of the lock or <emphasis>lock id</emphasis>.</para>
            </callout>
            <callout arearefs="policy.lock.field">
              <para>The <emphasis>lock field</emphasis>: the name of a
              field, <structfield>class</structfield>,
              <parameter>this</parameter>, or a qualified
              <parameter>this</parameter> expression
              (<parameter><replaceable>class_name</replaceable>.this</parameter>).</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <para>Policy lock declarations have the same <link
          linkend="lock.id.constraints">lock id</link> and <link
          linkend="lock.field.constraints">lock field</link> constraints
          as region lock declarations.</para>
        </sect2>
      </sect1>
      
      <sect1 id="lock.names">
        <title>Lock Names</title>
      
        <para><classname>@ReturnsLock</classname> and
        <classname>@RequiresLock</classname> annotations make use of
        <emphasis>lock names</emphasis>. Lock names have their own
        semantic constraints. A lock name identifies a lock in a
        particular object reference or class. It differs from a
        <emphasis>lock id</emphasis>: The lock id is the name of the
        lock as it is declared, while the lock name represents a
        particular instance of the lock.</para>
        
        <para>For <emphasis><code>static</code> locks</emphasis>
        (locks whose lock field is a <code>static</code> field or a
        class object), there is only one instance of the lock and its
        name is the lock id qualified by the name of the class in which
        it is declared.</para>
        
        <para>Otherwise we have an <emphasis>instance lock</emphasis> whose
        lock name is the lock id qualified by the name of a local
        variable (possibly <parameter>this</parameter>) that references the
        object that contains the lock.</para>
        
        <para>We differentiate between a <emphasis>raw</emphasis> lock name and a 
        <emphasis>decorated</emphasis> lock name.  This distinction is necessary
        because of the nature of read&ndash;write locks as implemented by
        <classname>ReadWriteLock</classname> in <package>java.util.concurrent</package>.
        A raw lock name refers to a declared lock, identified with an object referenced
        as a Java intrinsic lock, a <classname>java.util.concurrent.Lock</classname> object,
        or a <classname>java.util.concurrent.ReadWriteLock</classname> object.  In most cases
        a <classname>ReadWriteLock</classname> identified by a raw lock name is not useful
        because it cannot be acquired directly: the read or write lock must be identified.  
        This is the role of the decorated lock name, which is a raw lock name enhanced to 
        further identify either the read or write lock.</para>
                
        <sect2 id="naming.raw.locks">
          <title>Raw Lock Names</title>
          
          <para>A raw lock name must conform
          to the syntax and constraints shown in <xref linkend="lock.name.constraints"/>.
          </para>
          
          <table id="lock.name.constraints">
            <title>Syntax and Constraints for Naming Raw Locks</title>
            
            <tgroup align="left" cols="2">
              <thead>
                <row align="center">
                  <entry>Syntax</entry>
                  <entry>Constraints</entry>
                </row>
              </thead>
          
              <tbody>
                <row>
                  <entry>
                    <synopsis>
<co id="lockid1"/><replaceable>lock_id</replaceable><!--no break here--><footnote><para>This form is really a shorthand for either
                    <parameter>this</parameter><code>:</code><replaceable>lock_id</replaceable> or
                    <classname>fully.qualified.class.name</classname><code>:</code><replaceable>lock_id</replaceable> where
                    <classname>fully.qualified.class.name</classname> is
                    the name of the class containing the annotated method.
                     The ambiguity is resolved by checking whether
                    <replaceable>lock_id</replaceable> names a instance or
                    <code>static</code> lock, respectively.</para></footnote></synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lockid1">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title><replaceable>lock_id</replaceable> must
                          exist in the class containing the annotated
                          method</title>
                        </formalpara>
                      </listitem>
                      
                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          refer to a <code>static</code> lock if the
                          method is <code>static</code></title>

                          <para>Although, a non-<code>static</code> method
                          may refer to either a <code>static</code> or an instance
                          lock.</para>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>

                <row>
                  <entry>
                    <synopsis>
<co id="lock.name.param"/><replaceable>parameter_name</replaceable>:<co id="lockid2"/><replaceable>lock_id</replaceable>
                    </synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lock.name.param">
                        <para>The name of a method/constructor parameter,
                        including <parameter>this</parameter>.</para>
                      </callout>
                      <callout arearefs="lockid2">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title>The parameter
                          <replaceable>parameter_name</replaceable> must
                          be a <code>final</code> parameter of the annotated
                          method/constructor</title>
                        
                          <para>If the parameter isn't <code>final</code>
                          then the object referenced by the parameter can
                          change during execution of the method and the
                          named lock is not unique.  Note that
                          <parameter>this</parameter> <emphasis>is
                          not</emphasis> a parameter of
                          <code>static</code> methods.</para>
                        </formalpara>
                      </listitem>
  
                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          name an instance lock in the type of the parameter</title>
                        
                          <para>For clarity purposes we do not allow
                          <code>static</code> locks to be named through instances; it
                          only leads to confusion.</para>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>

                <row>
                  <entry>
                    <synopsis>
<co id="lock.name.fqclass1"/><replaceable>fully.qualified.class.name</replaceable>:<co id="lockid3"/><replaceable>lock_id</replaceable>
                    </synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lock.name.fqclass1">
                        <para>A fully qualified class name.</para>
                      </callout>
                      <callout arearefs="lockid3">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title>The named class
                          <replaceable>fully.qualified.class.name</replaceable>
                          must exist.</title>
                        </formalpara>
                      </listitem>

                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          name a <code>static</code> lock in the type <replaceable>fully.qualified.class.name</replaceable></title>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>

                <row>
                  <entry>
                    <synopsis>
<co id="lock.name.fqclass2"/><replaceable>fully.qualified.class.name</replaceable>.this:<co id="lockid4"/><replaceable>lock_id</replaceable>
                    </synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lock.name.fqclass2">
                        <para>A fully qualified class name.</para>
                      </callout>
                      <callout arearefs="lockid4">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title>The qualified receiver
                          <replaceable>fully.qualified.class.name</replaceable>.this
                          must exist for the annotated method</title>
                        </formalpara>
                      </listitem>
  
                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          name an instance lock in the type <replaceable>fully.qualified.class.name</replaceable></title>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </sect2>
        
        <sect2 id="naming.decorated.locks">
          <title>Decorated Lock Names</title>
          
          <para>The syntax and constraints for a decorated lock name are similar
          to those shown in <xref linkend="lock.name.constraints"/> with the following
          exceptions:
          
            <itemizedlist>
              <listitem>
                <formalpara>
                  <title><replaceable>lock_id</replaceable>
                    <emphasis>must</emphasis> refer to a lock whose lock
                    field refers to an object of type
                    <classname>java.util.concurrent.locks.ReadWriteLock</classname>
                  </title>
                
                  <para>Intrinsic locks and
                  <classname>java.util.concurrent.locks.Lock</classname>
                  objects do not have any sub components.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title><replaceable>lock_id</replaceable> must be followed
                    by either "<code>.readLock()</code>" or "<code>.writeLock()</code>"
                  </title>
                  
                  <para>This refers to the read lock or write lock component, respectively.</para>
                </formalpara>
              </listitem>
            </itemizedlist>
          </para>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Returns Lock</title>
        
        <para>A declaration that a method returns a particular lock has the form

          <synopsis>
@ReturnsLock("<co id="ret.lock.name"/><replaceable>raw_lock_name</replaceable>")
          </synopsis>
          
          <calloutlist>
            <callout arearefs="ret.lock.name">
              <para>A raw lock name.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The raw lock name <replaceable>raw_lock_name</replaceable> must be
                <link linkend="naming.raw.locks">well-formed</link></title>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Lock Preconditions</title>
        
        <para>Methods and constructors declare lock preconditions using

          <synopsis>
@RequiresLock("<co id="req.lock.name"/><replaceable>lock_name<subscript>1</subscript></replaceable>, &hellip;, <replaceable>lock_name<subscript>n</subscript></replaceable>")<co id="req.lock.n"/>
          </synopsis>
          
          <calloutlist>
            <callout arearefs="req.lock.name">
              <para><replaceable>lock_name<subscript>i</subscript></replaceable> are
              lock names.</para>
            </callout>
            <callout arearefs="req.lock.n">
              <para><replaceable>n</replaceable> &ge; 1.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>Each <replaceable>lock_name<subscript>i</subscript></replaceable>, which may be a raw or decorated lock name, must be
                <link linkend="lock.names">well-formed</link></title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>If <replaceable>lock_name<subscript>i</subscript></replaceable>
                  is a raw lock name, then the <replaceable>lock_id</replaceable> <emphasis>cannot</emphasis> refer
                  to a lock whose lock field refers to an object of
                  type <classname>java.util.concurrent.locks.ReadWriteLock</classname>.</title>
                
                <para>It does not make sense to require a read&ndash;write lock object because that
                lock cannot be acquired.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>Constructors and <code>static</code> methods
                cannot require callers to hold locks on the receiver
                (<parameter>this</parameter>)</title>
                
                <para><code>static</code> methods don't have a receiver
                so this would be nonsense. For constructors, the
                receiver doesn't yet exist at the call site, so a caller
                could never acquire it before hand.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>If the lock is a non-<code>static</code> lock of the receiver,
                or is a <code>static</code> lock from the same class as the annotated
                method/constructor then it must be at least as visible as
                the method/constructor</title>
                
                <para>To be truly useful, the required lock should be
                visible at the <emphasis>call site</emphasis> of the
                method. This is not determinable in general when looking
                at the annotated method; it can only be determined by
                looking at the call sites. But these are two common
                cases that can be checked at the method
                declaration.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>A particular lock for a particular object can
                only be named once per method</title>
                
                <para>There is no advantage to naming a lock more than
                once; it probably represents an error on the part of the
                programmer.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
    </chapter>
