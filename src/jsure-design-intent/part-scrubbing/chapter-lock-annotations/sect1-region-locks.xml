<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect1>
  <title>Region Lock Declaration</title>
  
  <para>Region lock declarations have the form
    <synopsis>
@RegionLock("<co id="reg.lock.name"/><replaceable>lock</replaceable> is <co id="reg.lock.field"/><replaceable>field</replaceable> protects <co id="reg.lock.region"/><replaceable>region</replaceable>")          
    </synopsis>
    
    <calloutlist>
      <callout arearefs="reg.lock.name">
        <para>The name of the lock or <emphasis>lock id</emphasis>.</para>
      </callout>
      <callout arearefs="reg.lock.field">
        <para>The <emphasis>lock field</emphasis>: the name of a
        field, <structfield>class</structfield>,
        <parameter>this</parameter>, or a qualified
        <parameter>this</parameter> expression
        (<parameter><replaceable>class_name</replaceable>.this</parameter>).</para>
      </callout>
      <callout arearefs="reg.lock.region">
        <para>The name of a region.</para>
      </callout>
    </calloutlist>
  </para>
  
  <sect2 id="lock.id.constraints">
    <title>Lock Id Constraints</title>
    
    <itemizedlist>
      <listitem>
        <formalpara>
          <title>The lock id must be unique within the class and its
          ancestors</title>

          <para>That is, a class cannot declare a lock that has the same
          id as a lock declared in an ancestor. This simplifies things
          by eliminating name hiding.</para>
        </formalpara>
      </listitem>
    </itemizedlist>
  </sect2>
  
  <sect2 id="lock.field.constraints">
    <title>Lock Field Constraints</title>

    <itemizedlist>
      <listitem>
        <formalpara>
          <title>The lock field must exist</title>
        </formalpara>
      </listitem>

      <listitem>
        <formalpara>
          <title>If <replaceable>field</replaceable> is non-<code>static</code>, it must be
          from the class being annotated or one of its ancestors</title>
        </formalpara>
      </listitem>

      <listitem>
        <formalpara>
          <title>The lock field must be <code>final</code></title>
          
          <para>Otherwise the object referenced by the field could be
          changed and then JSure will not be able to guarantee that all
          <code>synchronized</code> statements that use that field are
          locking the same object. <parameter>this</parameter> and
          <structfield>class</structfield> are implicitly
          <code>final</code>.</para>
        </formalpara>
      </listitem>

      <listitem>
        <formalpara>
          <title>The type of the lock field must not be primitive</title>
          
          <para>Java does not allow primitive types to be used in
          <code>synchronized</code> statements.</para>
        </formalpara>
      </listitem>
    </itemizedlist>
  </sect2>
  
  <sect2>
    <title>Region Constraints</title>

    <itemizedlist>
      <listitem>
        <formalpara>
          <title>The region must exist</title>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>The region must not be associated with any other locks
          in the same class or its ancestors</title>

          <para>Mutual exclusion cannot be guaranteed if multiple locks
          protect the same region. For non-<code>static</code> regions,
          this means there cannot be an ancestor class
          <classname>S</classname>, where <classname>S</classname> could
          be the class containing the annotation in question, that also
          associates a lock with the region. For <code>static</code>
          regions, it means the class that declares the region cannot
          associate more than one lock with it. (A rule below requires
          that a <code>static</code> region can only be associated with
          a lock by the class that declares the region.)</para>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>A <code>static</code> region must be protected by
          a <code>static</code> lock field, or
          <structfield>class</structfield></title>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>A non-<code>static</code> region must be
          protected by a non-<code>static</code> lock field, or
          <parameter>this</parameter> or a qualified
          <parameter>this</parameter> expression</title>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>If the region is <code>static</code>, it must be
          declared in the same class as the lock
          declaration</title>
          
          <para>It's not fair to impose locking constraints on a
          class from another class.</para>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>The lock field must be at least as visible as the
          region</title>

          <para>Otherwise, you have severely limited the usefulness of
          the region, because it won't be usable outside of the scope of
          the lock field. The field itself need not be declared to have
          the necessary visibility. The visibility of a lock field can
          be modified through the use of methods that are annotated with
          <classname>@ReturnsLock</classname>. So a <code>private</code>
          field can be used to protect a <code>protected</code> region
          as long as there is a <code>protected</code> (or
          <code>public</code>) method in the class that is declared to
          return the lock.</para>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>If the region is inherited (not declared in the
          annotated class), it must not contain any fields</title>

          <para>It may have subregions, but those subregions cannot
          contain fields. This is necessary to prevent upcasting from
          being used to compromise lock policies.</para>
        </formalpara>
      </listitem>
    </itemizedlist>
  </sect2>
</sect1>
