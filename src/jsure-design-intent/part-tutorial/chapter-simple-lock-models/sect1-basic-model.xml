<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect1 id="basic-model">
  <title>The Basic Lock Model</title>
      
  <para>The canonical Java model whereby an object protects itself is
  declared by annotating a class with
  <classname>@RegionLock</classname>:<footnote><para>We use emphasis in
  the code to highlight interesting annotations or interesting segments
  of code.  Specifically, we are not placing emphasis on all annotations
  that occur within the displayed source code.</para></footnote>
      
    <programlisting>
<emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class C {
  protected int f;
  &hellip;
}
    </programlisting>
 
  This single class annotation does three things:

    <orderedlist>
      <listitem><para>Declares a new lock named
      <structfield>Lock</structfield>.  The lock name enables consistent
      reference to the lock object in other
      annotations.</para></listitem>

      <listitem><para>Identifies that lock with instances of the class
      (<parameter>this</parameter>).</para></listitem>

      <listitem><para>Protects all the fields in instances of the class
      (the <emphasis>region</emphasis>
      <structfield>Instance</structfield>).  Regions are described in
      more detail in <xref linkend="declaring-regions"/>; for now it is
      enough to know

        <itemizedlist> 
          <listitem><para>All classes have an
          <structfield>Instance</structfield> region.</para></listitem>

          <listitem><para>The region contains all the
          non-<code>static</code> fields of the class.</para></listitem>
        </itemizedlist>
      </para></listitem>
    </orderedlist>

  In other words, all accesses to instance variables, for example
  <structfield>f</structfield>, of objects of class
  <classname>C</classname> must be within blocks
  <code>synchronized</code> on the instance.</para>
      
  <para>The following two methods of class <classname>C</classname>
  would assure

    <programlisting>
  public synchronized set(final int value) {
    this.f = value;
  }
  public int get() {
    synchronized (this) {
      return this.f;
    }
  }
   </programlisting>

  The following method of <classname>C</classname>, however, would not
  because although the method correctly protects the read of the field
  <structfield>f</structfield> of the object referenced by
  <parameter>other</parameter>, it does not protect the write to the
  field <structfield>f</structfield> of the object referenced by
  <parameter>this</parameter>:

    <programlisting>
  public void copy(final C other) {
    synchronized (other) {
      this.f = other.f;
    }
  }
    </programlisting>

  To make this code assure (i.e., make it consistent with the locking
  model) it needs to be holding two locks:

    <programlisting>
  public synchronized void copy(final C other) {
    synchronized (other) {
      this.f = other.f;
    }
  }
    </programlisting>
  </para>
</sect1>
