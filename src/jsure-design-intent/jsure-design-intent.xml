<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book id="guide-to-design-intent" lang="en-US">
  <title>JSure Annotation Guide</title>
  <bookinfo>
    <copyright>
      <year>2008</year>
      <holder>SureLogic, Inc.</holder>
    </copyright>
    <legalnotice>
      <para>The authors and publishers have taken care in the
      preparation of this documentation, but make no expressed or
      implied warranty of any kind and assume no responsibility for
      errors and omissions. No liability is assumed for incidental or
      consequential damages in connection with or arising out of the use
      of the information or programs herein.</para>
    </legalnotice>
    <pubdate>Version 1.0&mdash;January 2009</pubdate>
  </bookinfo>

  <chapter id="preface">
    <title>Preface</title>
    <section>
      <title>Audience</title>
      <para>This document is intended for Java developers who want to
      use the JSure. We assume that the reader understands both the
      Java programming language and the use of Eclipse for Java
      development.</para>
    </section>
    <section>
      <title>Contact information</title>
      <para>For technical support or other questions, please
      contact:</para>
      <para><email>support@surelogic.com</email></para>
      <para>5808 Forbes Avenue, Pittsburgh, PA 15217-1602</para>
    </section>
  </chapter>

  <chapter id="simple-lock-models">
    <title>Simple Lock Models</title>
    <sect1 id="basic-model">
      <title>The Basic Lock Model</title>
      
      <para>The canonical Java model whereby an object protects itself
      is declared by annotating a class with
      <varname>@RegionLock</varname>:<footnote><para>We use emphasis in
      the code to highlight interesting annotations or interesting
      segments of code.  Specifically, we are not placing emphasis on
      all annotations that occur within the displayed source
      code.</para></footnote></para>
      
      <programlisting>
<emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class C {
  protected int f;
  &hellip;
}
      </programlisting>

      <para>This single class annotation does three things:</para>

      <orderedlist>
	<listitem><para>Declares a new lock named
	<computeroutput>Lock</computeroutput>.  The lock name enables
	consistent reference to the lock object in other
	annotations.</para></listitem>

	<listitem><para>Identifies that lock with instances of the
	class
	(<computeroutput>this</computeroutput>).</para></listitem>

	<listitem><para>Protects all the fields in instances of the
	class (the <emphasis>region</emphasis>
	<computeroutput>Instance</computeroutput>) .  Regions are
	described in more detail in XXX; for now it is enough to
	know</para>

	  <itemizedlist>
	    <listitem><para>All classes have an
	    <computeroutput>Instance</computeroutput>
	    region.</para></listitem>

	    <listitem><para>The region contains all the
	    non-<computeroutput>static</computeroutput> fields of the
	    class.</para></listitem>
  	  </itemizedlist>
	</listitem>
      </orderedlist>

      <para>In other words, all accesses to instance variables, for
      example <varname>f</varname>, of objects of class
      <varname>C</varname> must be within blocks
      <varname>synchronized</varname> on the instance.  The following
      two methods of class <varname>C</varname> would assure</para>

      <programlisting>
  public synchronized set(final int value) {
    this.f = value;
  }
  public int get() {
    synchronized (this) {
      return this.f;
    }
  }
      </programlisting>

      <para>The following method of <varname>C</varname>, however,
      would not because although the method correctly protects the
      read of the field <varname>f</varname> of the object referenced
      by <varname>other</varname>, it does not protect the write to
      the field <varname>f</varname> of the object referenced by
      <varname>this</varname>:</para>

      <programlisting>
  public void copy(final C other) {
    synchronized (other) {
      this.f = other.f;
    }
  }
      </programlisting>
    </sect1>
    
    <sect1 id="extended-model1">
      <title>Extending the Model: Caller Locking</title>
      
	  <para>A frequent exception to the basic lock model is the
      expectation by a method implementation that it is the
      responsibility of the caller of the method to acquire the lock. 
      Analysis can assure this expectation if it is declared using the
      <varname>@RequiresLock</varname> method annotation:</para>
      
      <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  private int f;

  <emphasis>@RequiresLock("Lock")</emphasis>
  public void m() { &hellip; }
  &hellip;
}
      </programlisting>
      
      <para>When analyzing the implementation of method
      <varname>C.m()</varname>, analysis assumes that lock
      <varname>Lock</varname> is held.  When analyzing the callsite of
      the method, however, analysis requires that the calling context
      hold the lock object identified with <varname>Lock</varname>.  The
      method implementations <varname>C.m()</varname> and
      <varname>C.calls_m()</varname>, below, are thus both
      correct:</para>

	  <programlisting>
  <emphasis>@RequiresLock("Lock")</emphasis>
  public void m() {
    this.f = 0;
  }
  
  protected synchronized void calls_m() {
    this.m();
  }
      </programlisting>

      <para>The method implementation of <varname>Other.bad()</varname>
      is, however, erroneous because it does acquire the lock on the
      object referenced by <varname>cObject</varname>:</para>
      
      <programlisting>
public class Other {
  &hellip;
  public bad(final C cObject) {
    cObject.m(); // bad callsite!
  }
}
      </programlisting>
    </sect1>
    
    <sect1 id="extended-model2">
      <title>Extending the Model: Aggregating Arrays and Other
      Objects</title>
      
      <para>An array in Java is a separate object from the object whose
      field refers to the array. Protecting an array-typed field thus
      protects <emphasis>the reference to the array only</emphasis>. It
      is not sufficient to extend the protection to the elements of the
      array: we also need to know that the array object is accessible
      through that field only. If the array could be referenced by
      through other fields, then it would still be possible to access it
      concurrently because the locking model could be bypassed by
      accessing the array through a different field.</para>

      <para>Much of the time, however, it is not intended that an array
      is aliased; in these cases, the array can be incorporated into the
      state of the object that references it.  We call this
      <emphasis>aggregating state</emphasis>. An array is aggregated
      into the object that references it by adding a pair of annotations
      to the field that references the array:</para>
      
      <programlisting>
<emphasis>@Unique</emphasis>
<emphasis>@Aggregate("Instance into Instance")</emphasis>
private Object[] myArray;
      </programlisting>
      
      <para>This does two things:</para>

      <orderedlist>
        <listitem><para>Declares the programmer’s intent that the field
        is the only field that references the array object it
        references.  A separate analyses is used to assure that a
        <varname>@Unique</varname> field is never aliased.  A new
        expression always creates an unaliased object, so it is always
        safe to assign the results of a new expression to a
        <varname>@Unique</varname> field.</para></listitem>
      
        <listitem><para>Extends the state of the referencing object to
        include the elements of the array (recall that the
        <varname>Instance</varname> region is the
        non-<varname>static</varname> state of an object).  State
        aggregation is not automatically transitive; thus if the array
        elements are objects, those objects are not aggregated, only the
        references to them.</para></listitem>
      </orderedlist>
      
      <para>In the example below, the constructor
      <varname>Buffer(Object[])</varname> does not assure because it
      assigns an array to field buf that might be aliased, conflicting
      with the <varname>@Unique</varname> annotation on the field. The
      assignment to buf in the constructor
      <varname>Buffer(int)</varname> assures because it assigns a fresh
      array to the field.  The lock <varname>Lock</varname> does not
      need to be held to access the field <varname>buf</varname> because
      it is <varname>final</varname>. The implementation of
      <varname>copyContents()</varname> does not assure because even
      though <varname>Lock</varname> does not need to be held to access
      the field <varname>buf</varname> or the field
      <varname>length</varname>, <varname>Lock</varname> must be held to
      access the contents of the array referenced by
      <varname>buf</varname>.  Analysis knows that the method
      <varname>System.arraycopy()</varname> reads from the
      <varname>Instance</varname> region of its first parameter, and
      thus via aggregation, reads from the <varname>Instance</varname>
      region of the <varname>Buffer</varname> object.  (This analysis is
      informed by effects analysis and annotations, described in
      XXX.)</para>
      
      <programlisting>
<emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class Buffer {
  <emphasis>@Unique</emphasis>
  <emphasis>@Aggregate("Instance into Instance")</emphasis>
  private final Object[] buf;
  &hellip;
  public Buffer(int size) {
    this.buf = new Object[size]; // good!
  }
  &hellip;
  public Buffer(Object[] newBuffer) {
    this.buf = newBuffer; // bad!
  }

  public Object[] copyContents() {
    final Object[] copy = new Object[this.buf.length];
    System.arraycopy(this.buf, 0, copy, 0, this.buf.length);
    return copy;
  }
}
      </programlisting>
      
      <para>Aggregation applies not only to arrays, but to objects in
      general.  So any object-typed field can be declared
      <varname>@Unique</varname> and can then have its state aggregated
      into the state of its referring object. </para>
    </sect1>
    
    <sect1 id="constructors">
      <title>Constructors</title>
      
      <para>Constructors cannot be declared
      <varname>synchronized</varname> in Java, but our assurance
      requires that fields protected by a lock be accessed only when
      that lock is held.  So how do we keep assurance from failing when
      analyzing a constructor?  We rely on the fact that during object
      construction, an object is almost always accessed by a single
      thread only: the thread that invoked the constructor. When this is
      the case, we can proceed as if the locks for the object’s state
      are already held. The programmer can declare this <emphasis>single
      threaded intent</emphasis> by annotating the constructor:</para>
      
      <programlisting>
<emphasis>@SingleThreaded</emphasis>
<emphasis>@Borrowed("this")</emphasis>
public C(&hellip;) { &hellip; }
      </programlisting>

      <para>One way that analysis can assure the single-threadedness of
      a constructor is to leverage the assurance that the constructor
      <emphasis>borrows</emphasis> the constructed object&mdash;that is,
      that it does not create an alias to it. (The
      <varname>@Borrowed</varname> annotation is further described
      below.) In particular, when analysis knows that the constructor
      does not create such an alias, it also knows that it is impossible
      for another thread to obtain a reference to the object under
      construction during the constructor’s execution.</para>
      
      <para>Annotating a constructor as being
      <varname>@SingleThreaded</varname> requires that the
      super-constructor it invokes is also
      <varname>@SingleThreaded</varname>.</para>

      <sect2 id="field-initialization">
        <title>Field Initialization and Implicit Constructors</title>
        
        <para>Field initializers are part of the object construction
        process, and fields that have initializers are considered to be
        written to.  Instance initializer blocks are also part of the
        object construction process and need to be assured accordingly. 
        This can be become problematic when a class does not have an
        explicit constructor:</para>
        
        <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  private int f = 1;
  private int g;
  
  {
    g = 2;
  }
  public synchronized int getF() {
    return f;
  }
  
  public synchronized void incG() {
    g += 1;
  }
}
        </programlisting>
        
        <para>Lock assurance will not assure the correct use of
        <varname>Lock</varname> because the accesses to fields
        <varname>f</varname> and <varname>g</varname> during
        construction are not protected.  One way to fix this is to make
        the constructor explicit and annotate it:</para>
        
        <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  &hellip;
  <emphasis>@SingleThreaded</emphasis>
  <emphasis>@Borrowed("this")</emphasis>
  public C() {}
  &hellip;
}
        </programlisting>
        
        <para>Alternatively, if it is undesirable to insert the
        constructor explicitly, the constructor can still be annotated
        using a <emphasis>scoped promise</emphasis>.  These are
        described in more detail below, but for the case of annotating
        an implicit constructor, we would annotate the class as follows:
        </para>
        
        <programlisting>
@RegionLock("Lock is this protects Instance")
<emphasis>@Promise({</emphasis>
  <emphasis>"'@SingleThreaded' for new()",</emphasis>
  <emphasis>"'@Borrowed this' for new()"})</emphasis>
public class C {
  &hellip;
}
        </programlisting>
      </sect2>
    </sect1>
    
    <sect1 id="self-protected-objects">
      <title>Self-Protected Objects</title>
      
      <para>Region aggregation, described above, is one technique that
      can be used to deal with the fact that fields
      <emphasis>reference</emphasis> objects.  But it is not always
      possible to use region aggregation to simplify reasoning about
      protected state because a field may be aliased.  In such cases,
      the tool may produce warnings that a reference of the form
      <varname>e.f.g</varname>, where <varname>f</varname> is field
      protected by a lock, is a “possibly unsafe reference to protected
      shared state.”  The message is meant to remind the programmer that
      although the field <varname>f</varname> is protected by a lock,
      this lock does not also protect the field <varname>g</varname> of
      the referenced object.  (If field <varname>f</varname> is of class
      <varname>C</varname> and class <varname>C</varname> declares that
      <varname>g</varname> is protected by a lock then this warning is
      not produced: the tool instead attempts to assure that the
      appropriate lock for <varname>g</varname> is held.)  There are
      situations where invoking a method via <varname>e.f.m()</varname>
      will also produce a the above warning.</para>
      
      <para>Region aggregation and lock declaration (as described above)
      can be used to suppress these warnings.  In general, we can
      suppress this warning for a field <varname>f</varname> that
      references objects of class <varname>C</varname> by annotating
      class <varname>C</varname> with <varname>@SelfProtected</varname>.
       This <emphasis>unchecked</emphasis> annotation declares that
      instances of the class/interface are meant to be “thread safe.” 
      Exactly what is meant by this is presently unspecified; the
      annotation is intended to encompass non&ndash;lock-based
      protections schemes such as single-threadedness and
      immutability.</para>
      
      <important>
        <para>No analysis is performed on classes declared to be
        self-protected to assure that the implementation is thread
        safe.</para>
      </important>
      
      <para>As an example, let's consider the simple rational numbers
      class below.</para>

      <programlisting>
public class Rational {
  private final int numerator;
  private final int denominator;

  public Rational(int n, int d) { 
    numerator = n; 
    denominator = d; 
  }

  public int getNumerator() { return n; }
  public int getDenominator() { return d; } 
}
      </programlisting>
      
      <para>Suppose we have a client class that has a lock-protected
      reference to a <varname>Rational</varname> object:</para>
      
      <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  &hellip;
  private Rational r;

  public synchronized doStuff() {
    int n = r.getNumerator();  // (*)
    &hellip;
  }
}
      </programlisting>
      
      <para> JSure is going to generate a warning attached to call
      <varname>r.getNumerator()</varname> that “Receiver r may be a
      shared unprotected object.”  That is, we may be doing something
      unsafe: accessing the state of the rational object in multiple
      threads without protection.  But in this case, we know that
      <varname>Rational</varname> objects are immutable, and thus thread
      safe, so we can suppress this warning by annotating the
      <varname>Rational</varname> class:</para>
      
      <programlisting>
<emphasis>@SelfProtected</emphasis>
public class Rational {
  &hellip;
}
      </programlisting>
    </sect1>
  </chapter>
  
  <chapter id="advanced-locks">
    <title>Advanced Lock Models</title>
    
    <sect1 id="regions-and-locks">
      <title>Regions and Locks</title>
      
      <para>The lock annotation <varname>@RegionLock</varname> actually
      associates a lock with a region.  A <emphasis>region</emphasis> is
      a named, hierarchical abstraction of state.  All fields are
      regions, and thus a region is a named, extensible set of fields. 
      Using annotations, the programmer can declare new abstract regions
      as members of a class, and then associate different locks with
      different regions.  The state of an object may thus be partitioned
      into multiple abstract regions, each protected by a different
      lock, enabling concurrent access to different segments of the
      object’s state.</para>

      <sect2 id="declaring-regions">
        <title>Declaring New Regions</title>
        
        <para>New regions are declared by annotating a class with</para>
        
        <programlisting>
@Region("<replaceable>visibility</replaceable> <replaceable>Region</replaceable> extends <replaceable>Parent</replaceable>")
        </programlisting>
        
        <para>which declares a new region
        <replaceable>Region</replaceable> which is a subregion of
        <replaceable>Parent</replaceable>.  A region may be declared to
        be <varname>static</varname>, and may have any of the standard
        Java visibility modifiers (or none).  A
        <varname>static</varname> region must extend another
        <varname>static</varname> region; non-<varname>static</varname>
        regions may extend <varname>static</varname> regions.  If no
        parent region is specified, <varname>Instance</varname> is used
        for non-<varname>static</varname> regions; the root
        region&mdash;the <varname>static</varname> region
        <varname>All</varname>&mdash;is used for
        <varname>static</varname> regions.  Java only allows a single
        annotation of each type to be used at time, so to declare more
        than one region on a class, the <varname>@Regions</varname>
        annotation is used:</para>
        
        <programlisting>
<emphasis>@Regions</emphasis>({
  @Region("region1"), // region with default visibility, extends Instance
  @Region("private static region2"), // static private region, extends All
  @Region("public region3 extends region2") // public instance region
})
        </programlisting>
        
        <para>Unless otherwise specified, a <varname>static</varname>
        field is in the region <varname>All</varname>, and a
        non-<varname>static</varname> field is in the region
        <varname>Instance</varname>.  To place a field in a
        user-declared region, the <varname>@InRegion</varname> annotation
        is used:</para>
        
        <programlisting>
@Region("protected NewRegion")
public class C {
  <emphasis>@InRegion("NewRegion")</emphasis>
  private int f;
  &hellip;
}
        </programlisting>
        
        <para>As with abstract regions, a <varname>static</varname>
        field may only be placed into a <varname>static</varname>
        region.  Non-<varname>static</varname> fields may be placed into
        either <varname>static</varname> or
        non-<varname>static</varname> regions.</para>

      </sect2>
      
      <sect2 id="locks-with-regions">
        <title>Associating Locks with Regions</title>
        
        <para>The general form of the <varname>@RegionLock</varname> annotation is</para>
        
        <programlisting>
@RegionLock("<replaceable>LockName</replaceable> is <replaceable>Lock</replaceable> protects <replaceable>Region</replaceable>")
        </programlisting>
        
        <para>where <replaceable>LockName</replaceable> is a
        programmer-declared name for the lock,
        <replaceable>Lock</replaceable> is a reference to the lock
        object, and <replaceable>Region</replaceable> is the name of a
        region.  More specifically, <replaceable>Lock</replaceable> must
        be one of the following:</para>

        <variablelist>
          <varlistentry>
            <term><varname>this</varname></term>
            
            <listitem><para>The object itself is acquired to protect the
            state.</para></listitem>
          </varlistentry>
          
          <varlistentry>
            <term>A field declared in the class being annotated or an
            ancestor of the class being annotated that is visible within
            the class, for example, a protected field from an
            ancestor.</term>
            
            <listitem><para>The field must refer to an object.  The
            field must be <varname>final</varname>: otherwise the lock
            object referenced by the field could change.  The field may
            be <varname>static</varname> or instance.</para></listitem>
          </varlistentry>
          
          <varlistentry>
            <term><varname>class</varname></term>
            
            <listitem><para>The unique <varname>Class</varname> object
            referenced by the <varname>static</varname> pseudo-field
            <varname>class</varname>.  (This is the object that is
            locked by <varname>static synchronized</varname>
            methods.)</para></listitem>
          </varlistentry>
            
          <varlistentry>
            <term>A field of an outer class.</term>
            
            <listitem><para>If a class is declared inside class
            <varname>Outer</varname>, and wants to declare that the
            field <varname>f</varname> of the <varname>Outer</varname>
            instance that is the container for the inner class's
            instance protects a region of the inner class, then the lock
            reference is given by
            <varname>Outer.this.f</varname>.</para>
            
            <para>Although the tool supports declaring locks that are
            the fields of outer classes, it is not presently possible to
            assure their correct use.  This is because of deficiencies
            in both our internal representation and with Java syntax. 
            Given a variable <varname>v</varname> that refers to an
            instance of a non-<varname>static</varname> inner class,
            there is no syntactic expression that evaluates to the
            “outer” object of that instance, that is, the object
            referenced by <varname>o</varname> in the expression
            <varname>o.new Inner()</varname>.</para>
            
            <para>We allow the declaration of such locks, even though
            they cannot be assured, because we have encountered them in
            real code and it is nice to be able to document the design
            intent.</para></listitem>
          </varlistentry>
        </variablelist>
        
        <para>A region may only be associated with a lock declared in a
        class <varname>C</varname> if the region doesn't contain any
        fields from superclasses of <varname>C</varname>.  This is
        trivially true if the region is declared in
        <varname>C</varname>.  The region may have abstract sub-regions,
        but they also cannot contain any fields.  Specifically, the
        region (and any of its subregions) cannot contain any fields,
        when considered from the point of view of the class in which the
        lock declaration appears.  (Indeed, otherwise you could never
        associate a lock with a region.)  This restriction exists to
        prevent unsoundness.  Suppose class <varname>C</varname>
        declares a region <varname>R</varname> and populates it with
        field <varname>f</varname>.  Suppose <varname>D</varname>
        extends <varname>C</varname>, adds field <varname>g</varname> to
        region <varname>R</varname>, and also associates
        <varname>R</varname> with a lock.  The problem is, in contexts
        where a <varname>D</varname> object is viewed as a
        <varname>C</varname>, such as when a <varname>D</varname> object
        is passed a method with a <varname>C</varname> parameter,
        analysis cannot enforce <varname>D</varname>'s locking policy. 
        Thus, fields in <varname>R</varname> that should be protected
        might not be, and analysis would not complain.</para>
          
        <para>We allow the protection of an empty region to be delayed
        because no state can be accessed through that region by
        “unprotected” superclasses.  Any actual code that accesses state
        in that region must access the region through a subclass that
        does know about the protection, and therefore analysis can
        enforce the protection.</para>
          
        <para>A <varname>static</varname> region must be protected by a
        <varname>static</varname> field or by
        <varname>class</varname>.</para>

        <para>A region may be associated with a lock only if none of its
        ancestors are associated with a lock.  This prevents a region
        from being protected by multiple locks.</para>
      </sect2>
      
      <sect2 id="multiple-locks">
        <title>Declaring Multiple Locks</title>
        
        <para>Multiple locks are declared as members of a class my using
        the <varname>@RegionLocks</varname> annotation:</para>
        
        <programlisting>
@Regions({
  @Region("public Location"),
  @Region("public Appearance")
})
<emphasis>@RegionLocks({</emphasis>
  <emphasis>@RegionLock("LocationLock is this protects Location"),</emphasis>
  <emphasis>@RegionLock("AppearanceLock is appLock protects Appearance")</emphasis>
<emphasis>})</emphasis>
public class Sprite {
  protected static Object appLock = new Object();
  &hellip;
}
        </programlisting>
      </sect2>
    </sect1>
    
    <sect1 id="returning-locks">
      <title>Returning Locks</title>
      
      <para>A method may be declared to return a particular lock using
      the <varname>@ReturnsLock</varname> annotation.  This allows an
      implementation to provide access to a lock object without
      revealing how that lock is “implemented.”  That is, the identity
      of the field that refers to the lock is kept hidden by the
      implementation, although the lock object is made accessible to
      clients.  The <varname>@ReturnsLock</varname> annotation is fully
      checked: it is checked that the method actually returns the object
      representing the lock it says it returns.  The following code
      fragment shows an example use of the
      <varname>@ReturnsLock</varname> annotation.</para>
      
      <programlisting>
@RegionLock("DataLock is lock protects DataRegion")
@Region("protected DataRegion")
public class C {
  // NOTE: field is private
  private final Object lock = new Object();

  <emphasis>@ReturnsLock("DataLock")</emphasis>
  protected Object getDataLock() {
    return lock;
  }
  &hellip;
  public void doSomething() {
    synchronized (<emphasis>getDataLock()</emphasis>) {
      // Access DataRegion
    }
  }
}
      </programlisting>

      <para>An example of this sort of thing in production code is the
      method <varname>getTreeLock()</varname> in the JDK class
      <varname>java.awt.Container</varname>.</para>
    </sect1>
    
    <sect1 id="policy-locks">
      <title>Policy Locks</title>
      
        <para>Sometimes there is no obvious state to associate with a
        lock.  That is, a lock is being used to enforce a higher-level
        invariant that requires a section of code to execute atomically
        with respect to some other section of code.  We call locks used
        for such a purpose <emphasis>policy locks</emphasis>.  They can
        be declared using the class annotation</para>
        
        <programlisting>
@PolicyLock("LockName is Lock")
        </programlisting>
        
        <para>This annotation is basically the same as the
        <varname>@RegionLock</varname> annotation except that it does
        not associate the lock with any particular region of state.  The
        tool does not provide any assurance about the uses of policy
        locks.  The annotation is primarily used to document the intent
        behind the lock, and to suppress tool warnings about a
        particular lock object being an unknown lock.</para>
        
        <para>One common use for policy locks is to enforce an
        “initialize once” invariant.  Consider this example from
        <varname>java.util.logging.Logger</varname>:</para>
        
        <programlisting>
<emphasis>@PolicyLock("InitLock is class")</emphasis>
public class Logger {
  &hellip;
  public static synchronized Logger getLogger(String name) { 
    LogManager manager = LogManager.getLogManager(); 
    Logger result = manager.getLogger(name);
   if (result == null) {
     result = new Logger(name, null); 
      manager.addLogger(result);
     result = manager.getLogger(name); 
    }
   return result;
  }
}
      </programlisting>
      
      <para>First, note the <varname>static</varname> method does not
      change any state directly; it is difficult so say what state the
      lock <varname>Logger.class</varname> is protecting.  This is
      because the lock is ensuring that the method
      <varname>getLogger</varname> executes atomically with respect to
      itself.  If two threads were allowed to simultaneously execute the
      method it would be possible to create two new
      <varname>Logger</varname> objects with the same name, but only one
      of them would be registered in the global log registry.  This
      would cause problems later on during the use of the loggers.  The
      synchronization ensures that only one <varname>Logger</varname>
      object is ever created for any given name.</para>
    </sect1>
  </chapter>
    
  <chapter id="method-effects">
    <title>Method Effects</title>
      
    <para>Regions provide an abstract way to name the state of an
    object. The effects of a method&mdash;the state read and written
    during the execution of that method&mdash;may be expressed in terms
    of regions. Effects are useful when determining whether code can be
    reordered by a refactoring, and are also necessary to support the
    analyses that assure <varname>@Unique</varname> and
    <varname>@RegionLock</varname> annotations. </para>

    <sect1 id="declaring-effects">
      <title>Declaring Effects</title>

      <para>The effects of a constructor or method are declared using
      the <varname>@RegionEffects</varname> annotation:</para>
      
      <programlisting>
@RegionEffects(
  "reads <replaceable>readTarget<subscript>1</subscript></replaceable>, &hellip;, <replaceable>readTarget<subscript>N</subscript></replaceable>; writes <replaceable>writeTarget<subscript>1</subscript></replaceable>, &hellip;, <replaceable>writeTarget<subscript>M</subscript></replaceable>")
      </programlisting>
      
      <para>Specifically, the annotation contains reads and write
      clauses that each have a list of one or more
      <emphasis>targets</emphasis>.  The <varname>reads</varname> clause
      describes the state that may be read by the method/constructor;
      the <varname>writes</varname> clause describes the state that may
      be <emphasis>read or written</emphasis> by the method/constructor.
       Because writing includes reading, there is no need to list a
      target in the reads clause if its state is already described in
      the <varname>writes</varname> clause.</para>

      <para>Both the <varname>reads</varname> and the
      <varname>writes</varname> clauses are optional: to indicate that
      there are no effects use
      <varname>@RegionEffects("none")</varname>.</para>

      <para>A target is an extrinsic syntactic mechanism to name
      references to regions, and can be one of</para>

      <variablelist>
        <varlistentry>
          <term><varname>this:<replaceable>Region</replaceable></varname></term>
          <term><replaceable>Region</replaceable></term>
          <listitem><para><replaceable>Region</replaceable> is a region
          of the class containing the method.  The method affects the
          named region of the receiver object.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term><varname><replaceable>param</replaceable>:<replaceable>Region</replaceable></varname></term>
          <listitem><para><replaceable>param</replaceable> is a
          parameter of the method that references an object. 
          <replaceable>Region</replaceable> is a region of the class of
          <replaceable>param</replaceable>'s type.  The method affects
          the named region of the object referenced by
          <replaceable>param</replaceable> <emphasis>at the start of the
          method's execution</emphasis>.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term><varname><replaceable>pkg.C</replaceable>.this:<replaceable>Region</replaceable></varname></term>
          <listitem><para><replaceable>pkg.C</replaceable> is an “outer
          class” of the class that contains the annotated method.  That
          is, the method being annotated is in class
          <replaceable>D</replaceable>, and <replaceable>D</replaceable>
          is an inner class of <replaceable>C</replaceable>. 
          <replaceable>Region</replaceable> is a region of class
          <replaceable>pkg.C</replaceable>.  The method affects the
          named region of the given outer class
          receiver.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term><varname>any(<replaceable>pkg.C</replaceable>):<replaceable>Region</replaceable></varname></term>
          <listitem><para><replaceable>pkg.C</replaceable> is a class
          name and <replaceable>Region</replaceable> is a region of
          <replaceable>pkg.C</replaceable>.  This target indicates that
          the method affects the given region of any object of class
          <replaceable>pkg.C</replaceable>.</para></listitem>
        </varlistentry>
        
        <varlistentry>
          <term><varname><replaceable>pkg.C</replaceable>:<replaceable>Region</replaceable></varname></term>
          <listitem><para><replaceable>Region</replaceable> is a
          <varname>static</varname> region of class
          <replaceable>pkg.C</replaceable>.  The method affects the
          given <varname>static</varname> region.</para></listitem>
        </varlistentry>
      </variablelist>
      
      <para>Assurance checks that the actual effects of the method
      implementation are no greater than its declared effects.  There
      are several fine points to this:</para>
      
      <itemizedlist>
        <listitem><para>Uses of <varname>final</varname> fields produce
        no effects.</para></listitem>
        <listitem><para>Effects on local variables are not visible
        outside of a method/constructor.</para></listitem>
        <listitem><para>Effects on objects created within a method are
        not visible outside of a method.</para></listitem>
        <listitem><para>Constructors do not have to report effects on
        the <varname>Instance</varname> region of the newly constructed
        object.</para></listitem>
        <listitem><para>Region aggregation (described below) is taken
        into account.</para></listitem>
      </itemizedlist>
      
      <para>Here is a simple “variable” class with effects
      annotations:</para>
      
      <programlisting>
@Region("public Value")
public class Var {
  @InRegion("Value")
  private int value;

  <emphasis>@RegionEffects("none")</emphasis>
  public Var(int v) {
    value = v;
  }

  <emphasis>@RegionEffects("reads Value")</emphasis>
  public int getValue() {
    return value;
  }

  <emphasis>@RegionEffects("writes Value")</emphasis>
  public void setValue(int v) {
    value = v;
  }
}
      </programlisting>
    </sect1>
    
    <sect1 id="effects-and-single-threaded">
      <title>Effects and Single-Threaded Constructors</title>
      
      <para>A <varname>@SingleThreaded</varname> constructor may also be
      assured by checking whether the declared write effects of the
      constructor are included in the effect
      <varname>@RegionEffect("writes Instance")</varname>.  The
      constructor must also be annotated with a declaration that it does
      not start any threads: <varname>@Starts("nothing")</varname>. 
      Such a constructor cannot pass  a reference to the new object to a
      preexisting thread because it does not write to any objects that
      existed prior to the invocation of the constructor.  It can write
      a reference to the new object to other objects created during
      execution of the constructor, but because it cannot start any
      threads, such a reference cannot be read by another thread.</para>
      
      <para>Here is an example of typical usage, which, for example, was
      used to assure much of Doug Lea's
      <application>util.concurrent</application> library (for which
      <varname>@Borrowed("this")</varname> could not be used because of
      aliasing of <varname>this</varname> into a
      <varname>private</varname> field):</para>
      
      <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  <emphasis>@SingleThreaded</emphasis>
  <emphasis>@RegionEffects("writes nothing")</emphasis>
  <emphasis>@Starts("nothing")</emphasis>
  public C() {
    &hellip;
  }
  &hellip;
}
      </programlisting>
    </sect1>
    
    <sect1 id="borrowed-and-effects">
      <title>Borrowed References and Method Effects</title>
      
      <para>Another reason to declare method effects is to support
      <varname>borrowed</varname> references. Here we first introduce
      <varname>borrowed</varname> parameters, and then describe how
      effects are used to support their assurance.</para>
      
      <sect2 id="borrowed-params">
        <title>Borrowed Parameters</title>
        
        <para>When an object is passed as a parameter to a method, an
        alias to that object is created.  Thus, if strictly enforced, a
        unique field can never be passed as a parameter to a method,
        even as the receiver!  But if a method is known to not create
        any additional aliases to the object, then a unique field may
        safely be passed as a parameter because it is guaranteed that
        the method will restore the uniqueness of the field.  However,
        the method is not allowed to directly or indirectly make use of
        the unique field used as the parameter because the field is
        <emphasis>not</emphasis> unique within the dynamic scope of the
        method.  A parameter (including the receiver) is declared to be
        borrowed by annotating the parameter as
        <varname>@Borrowed</varname>.  We saw earlier that to declare
        that the receiver is borrowed we annotate the method/constructor
        with <varname>@Borrowed("this")</varname>.  Consider method
        <varname>C.copyInternalArray()</varname>:</para>
        
        <programlisting>
public class C {
  private Object[] myArray;
  &hellip;
  <emphasis>@Borrowed("this")</emphasis>
  public void copyInternalArray(<emphasis>@Borrowed</emphasis> Object[] array) {
    for (int i  = 0; i  &lt; array.length; i++) {
      array[i] = this.myArray[i];
    }
  }
}
        </programlisting>
        
        <para>Because the method declares that its receiver is borrowed
        it may be invoked on <varname>C</varname> objects referenced
        through <varname>@Unique</varname> fields.  It may also be
        passed references to arrays referenced by
        <varname>@Unique</varname> fields.  Here it is easy to see that
        no aliases to this or to array are created, but, in general,
        this is a property that is easily violated, and a separate set
        of analyses from those used to assure locking are used to assure
        that <varname>@Unique</varname> fields and
        <varname>@Borrowed</varname> variables are used
        correctly.</para>
       </sect2>
       
       <sect2 id="borrowed-with-method-effects">
         <title>Supporting Borrowed With Method Effects</title>
         
         <para>As explained above, when a method is passed the value of
         a unique field as the actual to a borrowed parameter, the
         method is not allowed to access the unique field.  Analysis
         looks to the effects of the methods to determine if the method
         could possibly read the forbidden field.  Thus, if a method has
         borrowed parameters it is usually necessary to declare the
         methods effects as well.</para>
         
         <para>Consider the class <varname>Var</varname>:</para>
         
         <programlisting>
class Var {
  private int value = 0;
  
  <emphasis>@Borrowed("this")</emphasis>
  public void set(int v) { value = v; }

  <emphasis>@Borrowed("this")</emphasis>
  public int get() { return v; } 
}
        </programlisting>
        
        <para>Its obvious that we can declare the receiver to be
        <varname>@Borrowed</varname> for the two methods.  If we never
        actually use a unique field as the receiver then we do not need
        to declare the effects of the methods:</para>
        
        <programlisting>
class VarClient {
  private Var v1 = new Var();
  private Var v2 = new Var();

  public void doStuff() {
    v1.set(1);
    v2.set(2);
    &hellip;
    v1.set(v2.get()+3); 
  } 
}
        </programlisting>
        
        <para>If instead field <varname>v1</varname> were annotated with
        <varname>@Unique</varname>, then analysis would need to know
        that it is not possible for <varname>set()</varname> to read the
        field <varname>v1</varname> when <varname>v1</varname> is used
        as the receiver.  Here it is obvious that it cannot, but in
        cases where the invoked method retrieves objects from
        collections or other global object pools, it is not so clear. 
        We must explicitly declare the effects of
        <varname>set()</varname> to allow the uniqueness analysis to
        assure the call (we also declare the effects of
        <varname>get()</varname> for completeness):</para>
        
        <programlisting>
class Var {
  private int value = 0;
  
  @Borrowed("this")
  <emphasis>@RegionEffects("writes this:Instance")</emphasis>
  public void set(int v) { value = v; }

  @Borrowed("this")
  <emphasis>@RegionEffects("reads this:Instance")</emphasis>
  public int get() { return v; } 
}
        </programlisting>
      </sect2>
    </sect1>
  </chapter>
</book>
