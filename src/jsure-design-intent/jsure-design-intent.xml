<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../lib/docbook-xml-4.5/docbookx.dtd">

<book id="guide-to-design-intent" lang="en-US">
  <title>JSure Annotation Guide</title>
  <bookinfo>
    <copyright>
      <year>2009</year>
      <holder>SureLogic, Inc.</holder>
    </copyright>
    <legalnotice>
      <para>The authors and publishers have taken care in the
      preparation of this documentation, but make no expressed or
      implied warranty of any kind and assume no responsibility for
      errors and omissions. No liability is assumed for incidental or
      consequential damages in connection with or arising out of the use
      of the information or programs herein.</para>
    </legalnotice>
    <pubdate>Version 2.3.0&mdash;October 2009</pubdate>
  </bookinfo>

  <preface id="preface">
    <title>Preface</title>
    <sect1>
      <title>Audience</title>
      <para>This document is intended for Java developers who want to
      use the JSure. We assume that the reader understands both the
      Java programming language and the use of Eclipse for Java
      development.</para>
    </sect1>
    <sect1>
      <title>Contact information</title>
      <para>For technical support or other questions, please
      contact:</para>
      <para><email>support@surelogic.com</email></para>
      <para>5808 Forbes Avenue, Pittsburgh, PA 15217-1602</para>
    </sect1>
  </preface>

  <part>
    <title>Tutorial</title>
  
    <chapter id="simple-lock-models">
      <title>Simple Lock Models</title>
      <sect1 id="basic-model">
        <title>The Basic Lock Model</title>
      
        <para>The canonical Java model whereby an object protects itself
        is declared by annotating a class with
        <classname>@RegionLock</classname>:<footnote><para>We use
        emphasis in the code to highlight interesting annotations or
        interesting segments of code.  Specifically, we are not placing
        emphasis on all annotations that occur within the displayed
        source code.</para></footnote>
      
          <programlisting>
<emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class C {
  protected int f;
  &hellip;
}
          </programlisting>
 
        This single class annotation does three things:

          <orderedlist>
            <listitem><para>Declares a new lock named
            <structfield>Lock</structfield>.  The lock name enables
            consistent reference to the lock object in other
            annotations.</para></listitem>

            <listitem><para>Identifies that lock with instances of the
            class (<parameter>this</parameter>).</para></listitem>

            <listitem><para>Protects all the fields in instances of the
            class (the <emphasis>region</emphasis>
            <structfield>Instance</structfield>).  Regions are
            described in more detail in <xref
            linkend="declaring-regions"/>; for now it is enough to know

              <itemizedlist> 
                <listitem><para>All classes have an
                <structfield>Instance</structfield>
                region.</para></listitem>

                <listitem><para>The region contains all the
                non-<code>static</code> fields of the
                class.</para></listitem>
              </itemizedlist>
            </para></listitem>
          </orderedlist>

        In other words, all accesses to instance variables, for example
        <structfield>f</structfield>, of objects of class
        <classname>C</classname> must be within blocks
        <code>synchronized</code> on the instance.</para>
      
        <para>The following two methods of class
        <classname>C</classname> would assure

          <programlisting>
  public synchronized set(final int value) {
    this.f = value;
  }
  public int get() {
    synchronized (this) {
      return this.f;
    }
  }
         </programlisting>

        The following method of <classname>C</classname>, however, would
        not because although the method correctly protects the read of
        the field <structfield>f</structfield> of the object referenced
        by <parameter>other</parameter>, it does not protect the write
        to the field <structfield>f</structfield> of the object
        referenced by <parameter>this</parameter>:

          <programlisting>
  public void copy(final C other) {
    synchronized (other) {
      this.f = other.f;
    }
  }
          </programlisting>
        </para>
      </sect1>
    
      <sect1 id="extended-model1">
        <title>Extending the Model: Caller Locking</title>
      
        <para>A frequent exception to the basic lock model is the
        expectation by a method implementation that it is the
        responsibility of the caller of the method to acquire the lock.
        Analysis can assure this expectation if it is declared using the
        <classname>@RequiresLock</classname> method annotation:
      
          <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  private int f;

  <emphasis>@RequiresLock("Lock")</emphasis>
  public void m() { &hellip; }
  &hellip;
}
          </programlisting>
      
        When analyzing the implementation of method
        <function>C.m()</function>, analysis assumes that lock
        <structfield>Lock</structfield> is held.  When analyzing the
        callsite of the method, however, analysis requires that the
        calling context hold the lock object identified with
        <structfield>Lock</structfield>.  The method implementations
        <function>C.m()</function> and <function>C.calls_m()</function>,
        below, are thus both correct:

          <programlisting>
  <emphasis>@RequiresLock("Lock")</emphasis>
  public void m() {
    this.f = 0;
  }
  
  protected synchronized void calls_m() {
    this.m();
  }
          </programlisting>
        </para>
      
        <para>The method implementation of
        <function>Other.bad()</function> is, however, erroneous because
        it does not acquire the lock on the object referenced by
        <parameter>cObject</parameter>:
      
          <programlisting>
public class Other {
  &hellip;
  public bad(final C cObject) {
    cObject.m(); // bad callsite!
  }
} 
          </programlisting>
        </para>
      </sect1>
    
      <sect1 id="extended-model2">
        <title>Extending the Model: Aggregating Arrays and Other
        Objects</title>
      
        <para>An array in Java is a separate object from the object
        whose field refers to the array. Protecting an array-typed field
        thus protects <emphasis>the reference to the array
        only</emphasis>. It is not sufficient to extend the protection
        to the elements of the array: we also need to know that the
        array object is accessible through that field only. If the array
        could be referenced through other fields, then it would still
        be possible to access it concurrently because the locking model
        could be bypassed by accessing the array through a different
        field.</para>

        <para>Much of the time, however, it is not intended that an
        array is aliased; in these cases, the array can be incorporated
        into the state of the object that references it.  We call this
        <emphasis>aggregating state</emphasis>. An array is aggregated
        into the object that references it by adding a pair of
        annotations to the field that references the array:
      
          <programlisting>
<emphasis>@Unique</emphasis>
<emphasis>@Aggregate("Instance into Instance")</emphasis>
private Object[] myArray;
          </programlisting>
      
        This does two things:

          <orderedlist>
            <listitem><para>Declares the programmer’s intent that the
            field is the only field that references the array object it
            references.  A separate analyses is used to assure that a
            <classname>@Unique</classname> field is never aliased.  A
            new expression always creates an unaliased object, so it is
            always safe to assign the results of a new expression to a
            <classname>@Unique</classname> field.</para></listitem>
  
            <listitem><para>Extends the state of the referencing object
            to include the elements of the array (recall that the
            <structfield>Instance</structfield> region is the
            non-<code>static</code> state of an object).  State
            aggregation is not automatically transitive; thus if the
            array elements are objects, those objects are not
            aggregated, only the references to them.</para></listitem>
          </orderedlist>
        </para>
      
        <para>In the example below, the constructor
        <function>Buffer(Object[])</function> does not assure because it
        assigns an array to field buf that might be aliased, conflicting
        with the <classname>@Unique</classname> annotation on the field.
        The assignment to buf in the constructor
        <function>Buffer(int)</function> assures because it assigns a
        fresh array to the field.  The lock
        <structfield>Lock</structfield> does not need to be held to
        access the field <structfield>buf</structfield> because it is
        <code>final</code>. The implementation of
        <function>copyContents()</function> does not assure because even
        though <structfield>Lock</structfield> does not need to be held
        to access the field <structfield>buf</structfield> or the field
        <structfield>length</structfield>,
        <structfield>Lock</structfield> must be held to access the
        contents of the array referenced by
        <structfield>buf</structfield>.  Analysis knows that the method
        <function>System.arraycopy()</function> reads from the
        <structfield>Instance</structfield> region of its first
        parameter, and thus via aggregation, reads from the
        <structfield>Instance</structfield> region of the
        <classname>Buffer</classname> object.  (This analysis is
        informed by effects analysis and annotations, described in <xref
        linkend="method-effects"/>.)</para>
      
        <programlisting>
<emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class Buffer {
  <emphasis>@Unique</emphasis>
  <emphasis>@Aggregate("Instance into Instance")</emphasis>
  private final Object[] buf;
  &hellip;
  public Buffer(int size) {
    this.buf = new Object[size]; // good!
  }
  &hellip;
  public Buffer(Object[] newBuffer) {
    this.buf = newBuffer; // bad!
  }

  public Object[] copyContents() {
    final Object[] copy = new Object[this.buf.length];
    System.arraycopy(this.buf, 0, copy, 0, this.buf.length);
    return copy;
  }
}
        </programlisting>
      
        <para>Aggregation applies not only to arrays, but to objects in
        general.  So any object-typed field can be declared
        <classname>@Unique</classname> and can then have its state
        aggregated into the state of its referring object. </para>
      </sect1>
    
      <sect1 id="constructors">
        <title>Constructors</title>
      
        <para>Constructors cannot be declared <code>synchronized</code>
        in Java, but our assurance requires that fields protected by a
        lock be accessed only when that lock is held.  So how do we keep
        assurance from failing when analyzing a constructor?  We rely on
        the fact that during object construction, an object is almost
        always accessed by a single thread only: the thread that invoked
        the constructor. When this is the case, we can proceed as if the
        locks for the object’s state are already held. The programmer
        can declare this <emphasis>single threaded intent</emphasis> by
        annotating the constructor:
      
          <programlisting>
<emphasis>@SingleThreaded</emphasis>
<emphasis>@Borrowed("this")</emphasis>
public C(&hellip;) { &hellip; }
          </programlisting>
        </para>
      
        <para>One way that analysis can assure the single-threadedness
        of a constructor is to leverage the assurance that the
        constructor <emphasis>borrows</emphasis> the constructed
        object&mdash;that is, that it does not create an alias to it.
        (The <classname>@Borrowed("this")</classname> annotation is further
        described below.) In particular, when analysis knows that the
        constructor does not create such an alias, it also knows that it
        is impossible for another thread to obtain a reference to the
        object under construction during the constructor’s
        execution.</para>
      
        <para>Annotating a constructor as being
        <classname>@SingleThreaded</classname> requires that the
        super-constructor it invokes is also
        <classname>@SingleThreaded</classname>.</para>

        <sect2 id="field-initialization">
          <title>Field Initialization and Implicit Constructors</title>
        
          <para>Field initializers are part of the object construction
          process, and fields that have initializers are considered to
          be written to.  Instance initializer blocks are also part of
          the object construction process and need to be assured
          accordingly. This can be become problematic when a class does
          not have an explicit constructor:
        
            <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  private int f = 1;
  private int g;
  {
    g = 2;
  }

  public synchronized int getF() {
    return f;
  }
  
  public synchronized void incG() {
    g += 1;
  }
}
            </programlisting>
        
          Lock assurance will not assure the correct use of
          <structfield>Lock</structfield> because the accesses to fields
          <structfield>f</structfield> and <structfield>g</structfield>
          during construction are not protected.  One way to fix this is
          to make the constructor explicit and annotate it:
        
            <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  &hellip;
  <emphasis>@SingleThreaded</emphasis>
  <emphasis>@Borrowed("this")</emphasis>
  public C() {}
  &hellip;
}
            </programlisting>
          </para>
        
          <para>Alternatively, if it is undesirable to insert the
          constructor explicitly, the constructor can still be
          annotated using a <emphasis>scoped promise</emphasis>.
          These are described in more detail below in <xref
          linkend="scoped-promises"/>, but for the case of annotating
          an implicit constructor, we would annotate the class as
          follows:
        
            <programlisting>
@RegionLock("Lock is this protects Instance")
<emphasis>@Promises({</emphasis>
  <emphasis>@Promise("@SingleThreaded for new()"),</emphasis>
  <emphasis>@Promise("@Borrowed(this) for new()")})</emphasis>
public class C {
  &hellip;
}
            </programlisting>
          </para>
        </sect2>
      </sect1>
    
      <sect1 id="self-protected-objects">
        <title>Self-Protected Objects</title>
      
        <para>Region aggregation, described above, is one technique that
        can be used to deal with the fact that fields
        <emphasis>reference</emphasis> objects.  But it is not always
        possible to use region aggregation to simplify reasoning about
        protected state because a field may be aliased.  In such cases,
        the tool may produce warnings that a reference of the form
        <code>e.f.g</code>, where <structfield>f</structfield> is field
        protected by a lock, is a “possibly unsafe reference to
        protected shared state.”  The message is meant to remind the
        programmer that although the field <structfield>f</structfield>
        is protected by a lock, this lock does not also protect the
        field <structfield>g</structfield> of the referenced object. 
        (If field <structfield>f</structfield> is of class
        <classname>C</classname> and class <classname>C</classname>
        declares that <structfield>g</structfield> is protected by a
        lock then this warning is not produced: the tool instead
        attempts to assure that the appropriate lock for
        <structfield>g</structfield> is held.)  There are situations
        where invoking a method via <code>e.f.m()</code> will also
        produce the above warning.</para>
      
        <para>Region aggregation and lock declaration (as described
        above) can be used to suppress these warnings.  In general, we
        can suppress this warning for a field
        <structfield>f</structfield> that references objects of class
        <classname>C</classname> by annotating class
        <classname>C</classname> with
        <classname>@SelfProtected</classname>. This
        <emphasis>unchecked</emphasis> annotation declares that
        instances of the class/interface are meant to be “thread safe.”
        Exactly what is meant by this is presently unspecified; the
        annotation is intended to encompass non&ndash;lock-based
        protections schemes such as single-threadedness and
        immutability.</para>
      
        <important>
          <para>No analysis is performed on classes declared to be
          self-protected to assure that the implementation is thread
          safe.</para>
        </important>
      
        <para>As an example, let us consider the simple rational numbers
        class below:

          <programlisting>
public class Rational {
  private final int numerator;
  private final int denominator;

  public Rational(int n, int d) { 
    numerator = n; 
    denominator = d; 
  }

  public int getNumerator() { return n; }
  public int getDenominator() { return d; } 
}
          </programlisting>
      
        Suppose we have a client class that has a lock-protected
        reference to a <classname>Rational</classname> object:
      
          <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  &hellip;
  private Rational r;

  public synchronized doStuff() {
    int n = r.getNumerator();
    &hellip;
  }
}
          </programlisting>
        </para>
      
        <para>JSure is going to generate a warning attached to call
        <code>r.getNumerator()</code> that <computeroutput>Receiver r
        may be a shared unprotected object</computeroutput>.  That is,
        we may be doing something unsafe: accessing the state of the
        rational object in multiple threads without protection.  But in
        this case, we know that <classname>Rational</classname> objects
        are immutable, and thus thread safe, so we can suppress this
        warning by annotating the <classname>Rational</classname> class:
      
          <programlisting>
<emphasis>@SelfProtected</emphasis>
public class Rational {
  &hellip;
}
          </programlisting>
        </para>
      </sect1>
    </chapter>
  
    <chapter id="advanced-locks">
      <title>Advanced Lock Models</title>
    
      <sect1 id="regions-and-locks">
        <title>Regions and Locks</title>
      
        <para>The lock annotation <classname>@RegionLock</classname>
        actually associates a lock with a region.  A
        <emphasis>region</emphasis> is a named, hierarchical abstraction
        of state.  All fields are regions, and thus a region is a named,
        extensible set of fields. Using annotations, the programmer can
        declare new abstract regions as members of a class, and then
        associate different locks with different regions.  The state of
        an object may thus be partitioned into multiple abstract
        regions, each protected by a different lock, enabling concurrent
        access to different segments of the object’s state.</para>

        <sect2 id="declaring-regions">
          <title>Declaring New Regions</title>
        
          <para>New regions are declared by annotating a class with
        
            <synopsis>
@Region("<replaceable>visibility</replaceable> <replaceable>Region</replaceable> extends <replaceable>Parent</replaceable>")
            </synopsis>
        
          which declares a new region <replaceable>Region</replaceable>
          which is a subregion of <replaceable>Parent</replaceable>.  A
          region may be declared to be <code>static</code>, and may have
          any of the standard Java visibility modifiers (or none).  A
          <code>static</code> region must extend another
          <code>static</code> region; non-<code>static</code> regions
          may extend <code>static</code> regions.  If no parent region
          is specified, <code>Instance</code> is used for
          non-<code>static</code> regions; the root region&mdash;the
          <code>static</code> region
          <structfield>All</structfield>&mdash;is used for
          <code>static</code> regions.  Java only allows a single
          annotation of each type to be used at time, so to declare more
          than one region on a class, the
          <classname>@Regions</classname> annotation is used:
        
            <programlisting>
<emphasis>@Regions</emphasis>({
  // region with default visibility, extends Instance
  @Region("region1"),
  // static private region, extends All
  @Region("private static region2"),
  // public instance region
  @Region("public region3 extends region2")
})
            </programlisting>
          </para>
        
          <para>Unless otherwise specified, a <code>static</code> field
          is in the region <structfield>All</structfield>, and a
          non-<code>static</code> field is in the region
          <structfield>Instance</structfield>.  To place a field in a
          user-declared region, the <classname>@InRegion</classname>
          annotation is used:
        
            <programlisting>
@Region("protected NewRegion")
public class C {
  <emphasis>@InRegion("NewRegion")</emphasis>
  private int f;
  &hellip;
}
            </programlisting>
          </para>
        
          <para>As with abstract regions, a <code>static</code> field
          may only be placed into a <code>static</code> region. 
          Non-<code>static</code> fields may be placed into either
          <code>static</code> or non-<code>static</code> regions.</para>
        </sect2>
      
        <sect2 id="locks-with-regions">
          <title>Associating Locks with Regions</title>
        
          <para>The general form of the <classname>@RegionLock</classname> annotation is
        
            <synopsis>
@RegionLock("<replaceable>LockName</replaceable> is <replaceable>Lock</replaceable> protects <replaceable>Region</replaceable>")
            </synopsis>
        
          where <replaceable>LockName</replaceable> is a
          programmer-declared name for the lock,
          <replaceable>Lock</replaceable> is a reference to the lock
          object, and <replaceable>Region</replaceable> is the name of a
          region.  More specifically, <replaceable>Lock</replaceable>
          must be one of the following:
          
            <itemizedlist>
              <listitem><parameter>this</parameter></listitem>

              <listitem>A field declared in the class being annotated or
              an ancestor of the class being annotated that is visible
              within the class, for example, a protected field from an
              ancestor.</listitem>

              <listitem><structfield>class</structfield></listitem>

              <listitem>A field of an outer class.</listitem>              
            </itemizedlist>
          </para>
           
          <para>When <replaceable>Lock</replaceable> is
          <parameter>this</parameter>, the object itself is acquired to
          protect the state.  When <replaceable>Lock</replaceable> is a
          field, the field must refer to an object.  The field must be
          <code>final</code>: otherwise the lock object referenced by
          the field could change.  The field may be <code>static</code>
          or instance.  When <replaceable>Lock</replaceable> is
          <structfield>class</structfield>, the unique
          <classname>Class</classname> object referenced by the
          <code>static</code> pseudo-field
          <structfield>class</structfield> must be acquired.  (This is
          the object that is locked by <code>static synchronized</code>
          methods.)</para>

          <para>If a class is declared inside class
          <classname>Outer</classname>, and wants to declare that the
          field <structfield>f</structfield> of the
          <classname>Outer</classname> instance that is the container
          for the inner class's instance protects a region of the inner
          class, then the lock reference is given by
          <code>Outer.this.f</code>.  Although the tool supports
          declaring locks that are the fields of outer classes, it is
          not presently possible to assure their correct use.  This is
          because of deficiencies in both our internal representation
          and with Java syntax. Given a variable <varname>v</varname>
          that refers to an instance of a non-<code>static</code> inner
          class, there is no syntactic expression that evaluates to the
          “outer” object of that instance, that is, the object
          referenced by <varname>o</varname> in the expression
          <code>o.new Inner()</code>.  We allow the declaration of such
          locks, even though they cannot be assured, because we have
          encountered them in real code and it is nice to be able to
          document the design intent.</para>
          
          <para>A region may only be associated with a lock declared in a
          class <classname>C</classname> if the region does not contain any
          fields from superclasses of <classname>C</classname>.  This is
          trivially true if the region is declared in
          <classname>C</classname>.  The region may have abstract sub-regions,
          but they also cannot contain any fields.  Specifically, the
          region (and any of its subregions) cannot contain any fields,
          when considered from the point of view of the class in which the
          lock declaration appears.  (Indeed, otherwise you could never
          associate a lock with a region.)  This restriction exists to
          prevent unsoundness.  Suppose class <classname>C</classname>
          declares a region <structfield>R</structfield> and populates it with
          field <structfield>f</structfield>.  Suppose <classname>D</classname>
          extends <classname>C</classname>, adds field <structfield>g</structfield> to
          region <structfield>R</structfield>, and also associates
          <structfield>R</structfield> with a lock.  The problem is, in contexts
          where a <classname>D</classname> object is viewed as a
          <classname>C</classname>, such as when a <classname>D</classname> object
          is passed a method with a <classname>C</classname> parameter,
          analysis cannot enforce <classname>D</classname>'s locking policy. 
          Thus, fields in <structfield>R</structfield> that should be protected
          might not be, and analysis would not complain.</para>
            
          <para>We allow the protection of an empty region to be delayed
          because no state can be accessed through that region by
          “unprotected” superclasses.  Any actual code that accesses state
          in that region must access the region through a subclass that
          does know about the protection, and therefore analysis can
          enforce the protection.</para>
            
          <para>A <code>static</code> region must be protected by a
          <code>static</code> field or by
          <structfield>class</structfield>.</para>
  
          <para>A region may be associated with a lock only if none of its
          ancestors are associated with a lock.  This prevents a region
          from being protected by multiple locks.</para>
          
          <sect3 id="intrinsic-vs-juc">
            <title>Intrinsic or <package>java.util.concurrent</package> Locks</title>
            
            <para>JSure understands the semantics of both intrinsic
            Java locks acquired using the <code>synchronized</code>
            block and <package>java.util.concurrent</package> locks,
            including <classname>ReadWriteLock</classname>.  JSure
            determines which semantics to enforce based on the object
            referenced by the <replaceable>Lock</replaceable> portion of
            each <classname>@RegionLock</classname> annotation.  There are 
            three cases: 
            
              <orderedlist>
                <listitem>The class of the referenced lock descends from
                <classname>java.util.concurrent.locks.Lock</classname>.</listitem>

                <listitem>The class of the referenced lock descends from
                <classname>java.util.concurrent.locks.ReadWriteLock</classname>.</listitem>

                <listitem>The class of the referenced lock is any other
                class.</listitem>
              </orderedlist>
            </para>
            
            <para>If the class of the lock is not
            <classname>Lock</classname> or
            <classname>ReadWriteLock</classname>, then JSure considers
            the lock to be an intrinsic lock.  JSure considers the lock
            to be acquired when it is referenced in a
            <code>sychronized</code> block, and to be released at the
            end of the block.</para>
            
            <para>If the class of the lock object descends from
            <classname>Lock</classname>, then JSure understands that the
            lock is acquired by calling one of
            <function>lock</function>,
            <function>lockInterruptibly</function>, or
            <function>tryLock</function>, and released by calling
            <function>unlock</function>.  JSure checks that each lock acquisition
            must have a subsequent lock release, and that each lock release has a prior
            lock acquisition.  JSure does not specifically enforce the pattern
            
              <programlisting>  myLock.lock();
  try {
    // do stuff
  } finally {
    myLock.unlock();
  }</programlisting>
            
            but, in practice, this pattern must be used to satisfy
            the analysis due to the bidirectional matching of lock
            acquisitions and releases.</para>

            <para>If the class of the lock object descends from
            <classname>ReadWriteLock</classname> then JSure understands
            that writes to the protected region require the write lock
            to be held, and that reads from the protected region require
            either the read or the write lock to be held.  The write
            lock is retrieved using the method
            <function>writeLock</function> and the read lock is
            retrieved using the method <function>readLock</function>.  For example, JSure 
            finds that the following class is consistent with its annotations:
            
              <programlisting>@RegionLock("L is lock protects f")
public class C {
  private final ReadWriteLock lock = new ReentrantReadWriteLock();
  private int f;
  
  public void set(final int v) {
    lock.writeLock().lock();
    try {
      f = v;
    } finally {
      lock.writeLock().unlock();
    }
  }
  
  public int get() {
    lock.readLock().lock();
    try {
      return f;
    } finally {
      lock.readLock().unlock();
    }
  }
}</programlisting>
            </para>

            <para>JSure recognizes a common shorthand used with
            <classname>ReadWriteLocks</classname>: the caching of the
            individual read and write locks in additional
            <code>final</code> fields of the class that declares the 
            <code>ReadWriteLock</code>.  For example
            
              <programlisting>@RegionLock("L is lock protects f")
public class CC {
  private final ReadWriteLock lock = new ReentrantReadWriteLock();
  private final Lock read = lock.readLock();
  private final Lock write = lock.writeLock();
  private int f;
  
  public void set(final int v) {
    write.lock();
    try {
      f = v;
    } finally {
      write.unlock();
    }
  }
  
  public int get() {
    read.lock();
    try {
      return f;
    } finally {
      read.unlock();
    }
  }
}</programlisting>

            This works with both <code>static</code> and instance locks.  If the original lock
            field is <code>static</code>, the cache fields must also be <code>static</code>. 
            </para>
          </sect3>
        </sect2>
        
        <sect2 id="multiple-locks">
          <title>Declaring Multiple Locks</title>
          
          <para>Multiple locks are declared as members of a class my using
          the <classname>@RegionLocks</classname> annotation:</para>
          
          <programlisting>
@Regions({
  @Region("public Location"),
  @Region("public Appearance")
})
<emphasis>@RegionLocks({</emphasis>
  <emphasis>@RegionLock("LocationLock is this protects Location"),</emphasis>
  <emphasis>@RegionLock("AppearanceLock is appLock protects Appearance")</emphasis>
<emphasis>})</emphasis>
public class Sprite {
  protected static Object appLock = new Object();
  &hellip;
}
          </programlisting>
        </sect2>
      </sect1>
      
      <sect1 id="returning-locks">
        <title>Returning Locks</title>
        
        <para>A method may be declared to return a particular lock using
        the <classname>@ReturnsLock</classname> annotation.  This allows an
        implementation to provide access to a lock object without
        revealing how that lock is “implemented.”  That is, the identity
        of the field that refers to the lock is kept hidden by the
        implementation, although the lock object is made accessible to
        clients.  The <classname>@ReturnsLock</classname> annotation is fully
        checked: it is checked that the method actually returns the object
        representing the lock it says it returns.  The following code
        fragment shows an example use of the
        <classname>@ReturnsLock</classname> annotation.</para>
        
        <programlisting>
@RegionLock("DataLock is lock protects DataRegion")
@Region("protected DataRegion")
public class C {
  // NOTE: field is private
  private final Object lock = new Object();

  <emphasis>@ReturnsLock("DataLock")</emphasis>
  protected Object getDataLock() {
    return lock;
  }
  &hellip;
  public void doSomething() {
    synchronized (<emphasis>getDataLock()</emphasis>) {
      // Access DataRegion
    }
  }
}
        </programlisting>
  
        <para>An example of this sort of thing in production code is the
        method <function>getTreeLock()</function> in the JDK class
        <classname>java.awt.Container</classname>.</para>
      </sect1>
      
      <sect1 id="policy-locks">
        <title>Policy Locks</title>
        
          <para>Sometimes there is no obvious state to associate with a
          lock.  That is, a lock is being used to enforce a higher-level
          invariant that requires a section of code to execute atomically
          with respect to some other section of code.  We call locks used
          for such a purpose <emphasis>policy locks</emphasis>.  They can
          be declared using the class annotation
          
            <synopsis>
@PolicyLock("<replaceable>LockName</replaceable> is <replaceable>Lock</replaceable>")
            </synopsis>
          
          This annotation is basically the same as the
          <classname>@RegionLock</classname> annotation except that it does
          not associate the lock with any particular region of state.  The
          tool does not provide any assurance about the uses of policy
          locks.  The annotation is primarily used to document the intent
          behind the lock, and to suppress tool warnings about a
          particular lock object being an unknown lock.</para>
          
          <para>One common use for policy locks is to enforce an
          "initialize once" invariant.  Consider this example from
          <classname>java.util.logging.Logger</classname>:
          
            <programlisting>
<emphasis>@PolicyLock("InitLock is class")</emphasis>
public class Logger {
  &hellip;
  public static synchronized Logger getLogger(String name) { 
    LogManager manager = LogManager.getLogManager(); 
    Logger result = manager.getLogger(name);
   if (result == null) {
     result = new Logger(name, null); 
      manager.addLogger(result);
     result = manager.getLogger(name); 
    }
   return result;
  }
}
          </programlisting>
        </para>
        
        <para>First, note the <code>static</code> method does not
        change any state directly; it is difficult so say what state the
        lock <code>Logger.class</code> is protecting.  This is
        because the lock is ensuring that the method
        <function>getLogger</function> executes atomically with respect to
        itself.  If two threads were allowed to simultaneously execute the
        method it would be possible to create two new
        <classname>Logger</classname> objects with the same name, but only one
        of them would be registered in the global log registry.  This
        would cause problems later on during the use of the loggers.  The
        synchronization ensures that only one <classname>Logger</classname>
        object is ever created for any given name.</para>
      </sect1>
    </chapter>
      
    <chapter id="method-effects">
      <title>Method Effects</title>
        
      <para>Regions provide an abstract way to name the state of an
      object. The effects of a method&mdash;the state read and written
      during the execution of that method&mdash;may be expressed in terms
      of regions. Effects are useful when determining whether code can be
      reordered by a refactoring, and are also necessary to support the
      analyses that assure <classname>@Unique</classname> and
      <classname>@RegionLock</classname> annotations.</para>
  
      <sect1 id="declaring-effects">
        <title>Declaring Effects</title>
  
        <para>The effects of a constructor or method are declared using
        the <classname>@RegionEffects</classname> annotation:
        
          <synopsis>
@RegionEffects("reads <replaceable>readTarget<subscript>1</subscript></replaceable>, &hellip;, <replaceable>readTarget<subscript>N</subscript></replaceable>;
    writes <replaceable>writeTarget<subscript>1</subscript></replaceable>, &hellip;, <replaceable>writeTarget<subscript>M</subscript></replaceable>")
          </synopsis>
        
        Specifically, the annotation contains reads and write
        clauses that each have a list of one or more
        <emphasis>targets</emphasis>.  The <code>reads</code> clause
        describes the state that may be read by the method/constructor;
        the <code>writes</code> clause describes the state that may
        be <emphasis>read or written</emphasis> by the method/constructor.
         Because writing includes reading, there is no need to list a
        target in the reads clause if its state is already described in
        the <code>writes</code> clause.</para>
  
        <para>Both the <code>reads</code> and the
        <code>writes</code> clauses are optional: to indicate that
        there are no effects use
        <code>@RegionEffects("none")</code>.</para>
  
        <para>A target is an extrinsic syntactic mechanism to name
        references to regions, and can be one of
  
          <itemizedlist>
            <listitem>
              <formalpara>
                <title><replaceable>Region</replaceable> or
                <code>this:<replaceable>Region</replaceable></code></title>

                <para><replaceable>Region</replaceable> is a region of
                the class containing the method.  The method affects the
                named region of the receiver
                object.</para>
              </formalpara>
            </listitem>
          
            <listitem>
              <formalpara>
                <title><code><replaceable>param</replaceable>:<replaceable>Region</replaceable></code></title>
                
                <para><replaceable>param</replaceable> is a parameter of
                the method that references an object.
                <replaceable>Region</replaceable> is a region of the
                class of <replaceable>param</replaceable>'s type.  The
                method affects the named region of the object referenced
                by <replaceable>param</replaceable> <emphasis>at the
                start of the method's execution</emphasis>.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title><code><replaceable>pkg.C</replaceable>.this:<replaceable>Region</replaceable></code></title>
                
                <para><replaceable>pkg.C</replaceable> is an “outer
                class” of the class that contains the annotated method. 
                That is, the method being annotated is in class
                <replaceable>D</replaceable>, and
                <replaceable>D</replaceable> is an inner class of
                <replaceable>C</replaceable>.
                <replaceable>Region</replaceable> is a region of class
                <replaceable>pkg.C</replaceable>.  The method affects
                the named region of the given outer class
                receiver.</para>
              </formalpara>
            </listitem>
            
            <listitem>
              <formalpara>
                <title><code>any(<replaceable>pkg.C</replaceable>):<replaceable>Region</replaceable></code></title>
                
                <para><replaceable>pkg.C</replaceable> is a class name
                and <replaceable>Region</replaceable> is a region of
                <replaceable>pkg.C</replaceable>.  This target indicates
                that the method affects the given region of any object
                of class <replaceable>pkg.C</replaceable>.</para>
              </formalpara>
            </listitem>
          
            <listitem>
              <formalpara>
                <title><code><replaceable>pkg.C</replaceable>:<replaceable>Region</replaceable></code></title>
                
                <para><replaceable>Region</replaceable> is a
                <code>static</code> region of class
                <replaceable>pkg.C</replaceable>.  The method affects
                the given <code>static</code> region.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </para>
        
        <para>Assurance checks that the actual effects of the method
        implementation are no greater than its declared effects.  There
        are several fine points to this:
        
          <itemizedlist>
            <listitem><para>Uses of <code>final</code> fields produce no
            effects.</para></listitem>
  
            <listitem><para>Effects on local variables are not visible
            outside of a method/constructor.</para></listitem>
  
            <listitem><para>Effects on objects created within a method are
            not visible outside of a method.</para></listitem>
            
            <listitem><para>Constructors do not have to report effects on
            the <structfield>Instance</structfield> region of the newly
            constructed object.</para></listitem>
  
            <listitem><para>Region aggregation (described below) is taken
            into account.</para></listitem>
          </itemizedlist>
        </para>
        
        <para>Here is a simple "variable" class with effects
        annotations:
        
          <programlisting>
@Region("public Value")
public class Var {
  @InRegion("Value")
  private int value;

  <emphasis>@RegionEffects("none")</emphasis>
  public Var(int v) {
    value = v;
  }

  <emphasis>@RegionEffects("reads Value")</emphasis>
  public int getValue() {
    return value;
  }

  <emphasis>@RegionEffects("writes Value")</emphasis>
  public void setValue(int v) {
    value = v;
  }
}
          </programlisting>
        </para>
      </sect1>
      
      <sect1 id="effects-and-single-threaded">
        <title>Effects and Single-Threaded Constructors</title>
        
        <para>A <classname>@SingleThreaded</classname> constructor may also be
        assured by checking whether the declared write effects of the
        constructor are included in the effect
        <code>@RegionEffect("writes Instance")</code>.  The
        constructor must also be annotated with a declaration that it does
        not start any threads: <code>@Starts("nothing")</code>. 
        Such a constructor cannot pass  a reference to the new object to a
        preexisting thread because it does not write to any objects that
        existed prior to the invocation of the constructor.  It can write
        a reference to the new object to other objects created during
        execution of the constructor, but because it cannot start any
        threads, such a reference cannot be read by another thread.</para>
        
        <para>Here is an example of typical usage, which, for example, was
        used to assure much of Doug Lea's
        <application>util.concurrent</application> library (for which
        <code>@Borrowed("this")</code> could not be used because of
        aliasing of <parameter>this</parameter> into a
        <code>private</code> field):
        
          <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  <emphasis>@SingleThreaded</emphasis>
  <emphasis>@RegionEffects("writes nothing")</emphasis>
  <emphasis>@Starts("nothing")</emphasis>
  public C() {
    &hellip;
  }
  &hellip;
}
          </programlisting>
        </para>
      </sect1>
      
      <sect1 id="borrowed-and-effects">
        <title>Borrowed References and Method Effects</title>
        
        <para>Another reason to declare method effects is to support
        <classname>@Borrowed</classname> references. Here we first introduce
        <classname>@Borrowed</classname> parameters, and then describe how
        effects are used to support their assurance.</para>
        
        <sect2 id="borrowed-params">
          <title>Borrowed Parameters</title>
          
          <para>When an object is passed as a parameter to a method, an
          alias to that object is created.  Thus, if strictly enforced, a
          unique field can never be passed as a parameter to a method,
          even as the receiver!  But if a method is known to not create
          any additional aliases to the object, then a unique field may
          safely be passed as a parameter because it is guaranteed that
          the method will restore the uniqueness of the field.  However,
          the method is not allowed to directly or indirectly make use of
          the unique field used as the parameter because the field is
          <emphasis>not</emphasis> unique within the dynamic scope of the
          method.  A parameter (including the receiver) is declared to be
          borrowed by annotating the parameter as
          <classname>@Borrowed</classname>.  We saw earlier that to declare
          that the receiver is borrowed, we annotate the method/constructor
          with <code>@Borrowed("this")</code>.</para>
          
          <para>Consider method <function>C.copyInternalArray()</function>:
          
            <programlisting>
public class C {
  private Object[] myArray;
  &hellip;
  <emphasis>@Borrowed("this")</emphasis>
  public void copyInternalArray(<emphasis>@Borrowed</emphasis> Object[] array) {
    for (int i  = 0; i  &lt; array.length; i++) {
      array[i] = this.myArray[i];
    }
  }
}
            </programlisting>
          
          Because the method declares that its receiver is borrowed,
          it may be invoked on <classname>C</classname> objects referenced
          through <classname>@Unique</classname> fields.  It may also be
          passed references to arrays referenced by
          <classname>@Unique</classname> fields.  Here it is easy to see that
          no aliases to this or to array are created, but, in general,
          this is a property that is easily violated, and a separate set
          of analyses from those used to assure locking are used to assure
          that <classname>@Unique</classname> fields and
          <classname>@Borrowed</classname> variables are used
          correctly.</para>
         </sect2>
         
         <sect2 id="borrowed-with-method-effects">
           <title>Supporting Borrowed With Method Effects</title>
           
           <para>As explained above, when a method is passed, the value of
           a unique field as the actual to a borrowed parameter, the
           method is not allowed to access the unique field.  Analysis
           looks to the effects of the methods to determine if the method
           could possibly read the forbidden field.  Thus, if a method has
           borrowed parameters, it is usually necessary to declare the
           methods effects as well.</para>
           
           <para>Consider the class <classname>Var</classname>:
           
             <programlisting>
class Var {
  private int value = 0;
  
  <emphasis>@Borrowed("this")</emphasis>
  public void set(int v) { value = v; }

  <emphasis>@Borrowed("this")</emphasis>
  public int get() { return v; } 
}
            </programlisting>
          
          It's obvious that we can declare the receiver to be
          borrowed for the two methods.  If we never
          actually use a unique field as the receiver, then we do not need
          to declare the effects of the methods:
          
            <programlisting>
class VarClient {
  private Var v1 = new Var();
  private Var v2 = new Var();

  public void doStuff() {
    v1.set(1);
    v2.set(2);
    &hellip;
    v1.set(v2.get()+3); 
  } 
}
            </programlisting>
          </para>
          
          <para>If instead field <structfield>v1</structfield> were annotated with
          <classname>@Unique</classname>, then analysis would need to know
          that it is not possible for <function>set()</function> to read the
          field <structfield>v1</structfield> when <structfield>v1</structfield> is used
          as the receiver.  Here it is obvious that it cannot, but in
          cases where the invoked method retrieves objects from
          collections or other global object pools, it is not so clear. 
          We must explicitly declare the effects of
          <function>set()</function> to allow the uniqueness analysis to
          assure the call (we also declare the effects of
          <function>get()</function> for completeness):
          
            <programlisting>
class Var {
  private int value = 0;
  
  @Borrowed("this")
  <emphasis>@RegionEffects("writes this:Instance")</emphasis>
  public void set(int v) { value = v; }

  @Borrowed("this")
  <emphasis>@RegionEffects("reads this:Instance")</emphasis>
  public int get() { return v; } 
}
            </programlisting>
          </para>
        </sect2>
      </sect1>
    </chapter>

    <chapter id="scoped-promises">
      <title>Scoped Promises</title>
      <para>Scoped promises are promises that act on other promises
      within a static scope of code. Two types of scoped promises are
      supported by the tool: <emphasis>@Promise</emphasis> to avoid
      tedious user annotation and <emphasis>@Assume</emphasis> to
      support team modeling.</para>

      <note>
	<para>Scoped promises are still experimental in JSure, however,
	it is possible to use <emphasis>@Promise</emphasis> in your
	models. We will not describe <emphasis>@Assume</emphasis> any
	further.
	</para>
      </note>

      <para>The simplest example of the use of
      <emphasis>@Promise</emphasis> is to change the default for a
      class. So instead of writing</para>

<programlisting>
class Example {
  private int value = 0;
  
  @Borrowed("this")
  public void set(int v) { value = v; }

  @Borrowed("this")
  public int get() { return v; } 
}
</programlisting>

<para>you would write</para>

<programlisting>
@Promise("@Borrowed(this)")
class Example {
  private int value = 0;
  
  public void set(int v) { value = v; }

  public int get() { return v; } 
}
</programlisting>

<para>Notice that the <emphasis>payload</emphasis> promise within the
scoped promise has the same syntax as the original annotation except
that the quotation marks are removed. So
<emphasis>@Borrowed("this")</emphasis> is changed to
<emphasis>@Borrowed(this)</emphasis> when used as the payload for a
scoped promise.</para>

<para>In the form shown in the example above
<emphasis>@Promise</emphasis> places the payload promise on every
declaration in the class where the payload promise makes sense. In the
example above, this is all methods and constructors within the Example
class. It is possible to be more specific by providing an explicit
target.</para>

<programlisting>
@Promises({
  @Promise("@SingleThreaded for new(**)"),
  @Promise("@Borrowed(this) for new(**)"),
  @Promise("@Borrowed(this) for get*(**)"),
})
class Example2 {
  ...
}
</programlisting>

<para>In the example above a <emphasis>@SingleThreaded</emphasis> and
<emphasis>@Borrowed("this")</emphasis> annotation are placed on all
the constructors in the Example2 class using the explicit target
<emphasis>new(**)</emphasis>. A <emphasis>@Borrowed("this")</emphasis>
annotation is placed on all methods within the Example2 class that
have names that start with "get" (e.g.,
<emphasis>getValue()</emphasis>) and have any number of parameters of
any type.</para>

    </chapter>
  </part>
  
  <part id="scrubbing">
    <title>Annotation Syntax and Consistency</title>
    
    <chapter id="region-annotations">
      <title>Region Annotations</title>
      
      <sect1 id="region-declaration">
        <title>Region Declaration</title>
        
        <para>A new <emphasis>abstract</emphasis> region is declared using the annotation
        
          <synopsis>
@Region("<optional><co id="region.decl.viz"/><replaceable>visibility</replaceable></optional> <optional>static</optional> <co id="region.decl.name"/><replaceable>Region</replaceable> <optional>extends <co id="region.decl.parent"/><replaceable>Parent</replaceable></optional>")
          </synopsis>

          <calloutlist>
            <callout arearefs="region.decl.viz"><para>A standard Java
            visibility modifier (<code>public</code>,
            <code>protected</code>, <code>private</code>). It may be
            omitted to declare Java "default"
            visibility.</para></callout>

            <callout arearefs="region.decl.name"><para>The name of the
            new region.</para></callout>

            <callout arearefs="region.decl.parent"><para>The name of the
            region's parent.  If omitted, the parent for
            non-<code>static</code> regions is
            <structfield>Instance</structfield>,
            <structfield>All</structfield> for <code>static</code>
            regions.</para></callout>
          </calloutlist>
        </para>
        
        <para>Regular Java fields are also considered to be regions, and
        thus a field declaration is also a <emphasis>concrete</emphasis>
        region declaration, possibly augmented by an
        <classname>@InRegion</classname> annotation.</para>
        
        <sect2 id="region.decl.constraints">
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The name of a region must be unique within the
                declaration of the class being annotated</title>

                <para>This includes the names of any fields declared in
                the class because fields are region declarations. See
                also <xref linkend="region.hiding"/>.</para>
              </formalpara>
            </listitem>
            
            <listitem>
              <formalpara>
                <title>The region's parent region must exist in the
                class</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The region's parent region must be accessible</title>

                <para>To preserve abstraction it is not appropriate to
                refer to <code>private</code> regions from a superclass.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The region's parent cannot be <code>final</code> or <code>volatile</code></title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The region cannot be more visible than its parent</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>A <code>static</code> region cannot extend a
                non-<code>static</code> region</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>Regions must form a tree</title>

                <para>There cannot be a cycle in the region ancestor
                relationship.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
        
        <sect2 id="region.hiding">
          <title>Region Hiding</title>
          
          <para>Regions/fields may be hidden. That is, if class <classname>C</classname>
          declares a region <structfield>R</structfield>, then a
          subclass <classname>D</classname> may also declare a
          region <structfield>R</structfield> that is distinct from the original.
          In the context of
          <classname>D</classname> and its descendants, <structfield>R</structfield>
          refers to the region declared in <classname>D</classname>,
          unless, of course, it is hidden yet again.</para>
          
          <warning>
            <para>Although Java allows hidden fields to be accessed via type
            casting, e.g., <code>((Super) this)).field</code>, JSure annotations do
            not currently provide a similar capability.  So once a region
            is hidden, it is impossible to refer to the hidden region
            from within a JSure annotation.  This is problematic for effects
            annotations or for creating a subregion of a hidden region.</para>
          </warning>
          
          <para>Consider the three classes <classname>Super</classname>,
          <classname>Duper</classname>, and
          <classname>Blooper</classname>:
          
            <programlisting>
<emphasis>@Region("public R")</emphasis>
@RegionLock("L is superLock protects R")
public class Super {
  public final Object superLock = new Object();
  
  @InRegion("R")
  <emphasis>public int field;</emphasis>
  
  public void bad() {
    field = 1; // Needs L
  }
}

<emphasis>@Region("public R")</emphasis>
@RegionLock("LL is duperLock protects R")
public class Duper extends Super {
  public final Object duperLock = new Object();
  
  @InRegion("R")
  <emphasis>public int field;</emphasis>
  
  public void worse() {
    ((Super) this).field = 2; // Needs L
    field = 1; // Needs LL
  }
} 

<emphasis>@Region("public R")</emphasis>
@RegionLock("LLL is blooperLock protects R")
public class Blooper extends Duper {
  public final Object blooperLock = new Object();
  
  @InRegion("R")
  <emphasis>public int field;</emphasis>
  
  public void worst() {
    ((Super) this).field = 2; // Needs L
    ((Duper) this).field = 3; // Needs LL
    field = 1; // Needs LLL
  }
}
            </programlisting>
            
          Objects of class <classname>Blooper</classname> have three
          fields, all of them named <structfield>field</structfield>,
          and each field is in a distinct region named
          <structfield>R</structfield> associated with a distinct lock.
          Although the lock analysis understands this scenario, if we wanted
          to annotate the effects of method <code>Blooper.worst()</code>, the most
          specific annotation we could use is <code>@RegionEffects("writes Instance")</code>
          because we cannot refer to the regions <structfield>R</structfield> declared in 
          ancestor classes <classname>Super</classname> and <classname>Duper</classname>
          from annotations in class <classname>Blooper</classname>.</para>
          
        </sect2>
      </sect1>
      
      <sect1 id="field.as.region">
        <title>Fields as Regions</title>
        
        <para>A field is placed into a non-default region using the annotation
        
          <synopsis>
@InRegion("<co id="inregion.parent"/><replaceable>Parent</replaceable>")
          </synopsis>
          
          <calloutlist>
            <callout arearefs="inregion.parent"><para>The name of the
            region that field extends.</para></callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>

          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The field cannot be <code>final</code></title>
                
                <para>Fields that are <code>final</code> do not represent mutable
                state and are thus outside of the region model.</para>
              </formalpara>
            </listitem>
            
            <listitem>
              <formalpara>
                <title>The region's parent region must exist in the
                class</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The region's parent region must be accessible</title>

                <para>To preserve abstraction it is not appropriate to
                refer to <code>private</code> regions from a superclass.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The region's parent cannot be <code>final</code> or <code>volatile</code></title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The region cannot be more visible than its parent</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>A <code>static</code> region cannot extend a
                non-<code>static</code> region</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>Regions must form a tree</title>

                <para>There cannot be a cycle in the region ancestor
                relationship.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Region Aggregation</title>
        
        <para>When a field refers to a <classname>@Unique</classname>
        reference, the regions of the referenced object must be
        aggregated into the regions of the referring object. This
        effectively allows the referenced object to be treated as part
        of the referring object. This is achieved using the field
        annotation

          <synopsis>
@Aggregate("<co id="agg.src.region"/><replaceable>R<subscript>1</subscript></replaceable> into <co id="agg.dest.region"/><replaceable>Q<subscript>1</subscript></replaceable>, &hellip; <replaceable>R<subscript>n</subscript></replaceable> into <replaceable>Q<subscript>n</subscript></replaceable>")<co id="agg.n"/>
          </synopsis>
          
          <calloutlist>
            <callout
            arearefs="agg.src.region"><para><replaceable>R<subscript>i</subscript></replaceable> are regions of the annotated
            field's class.</para></callout>

            <callout
            arearefs="agg.dest.region"><para><replaceable>Q<subscript>i</subscript></replaceable> are regions of the class
            that declares the field.</para></callout>

            <callout arearefs="agg.n"><para><replaceable>n</replaceable>
            &ge; 1.</para></callout>
          </calloutlist>

          <para>The flexibility of the aggregation depends on whether
          the annotated field is or is not <code>final</code>:
          
            <itemizedlist>
              <listitem><para>When the field is not <code>final</code>,
              all the regions of the referenced object must be mapped
              into regions of the object that contain the field. 
              Generally, in this case, the best thing to do is to map
              the <structfield>Instance</structfield> region of the
              referenced object into the field itself, for example,
        
                <programlisting>
@Aggregate("Instance into record")
protected PersonRecord record;
                </programlisting>
              </para></listitem>

              <listitem><para>When the field is <code>final</code>, the
              regions of the referenced object may be mapped more
              freely, as long as they respect the region
              hierarchy.</para></listitem>
            </itemizedlist>
          </para>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <para>An <classname>@Aggregate</classname> annotation on a
          field <structfield>field</structfield> with class type
          <classname>D</classname> declared in a class
          <classname>C</classname> is subject to the following
          constraints:
            <itemizedlist>
              <listitem>
                <formalpara>
                  <title>The field <structfield>field</structfield> must
                  also be annotated with
                  <classname>@Unique</classname></title>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>The type <classname>D</classname> must be a non-primitive type</title>
                  
                  <para>Practically, these is guaranteed by the first
                  rule, because <classname>@Unique</classname> is only applicable to fields
                  with a non-primitive type.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title><replaceable>R<subscript>i</subscript></replaceable>
                  must be a non-<code>static</code> region
                  from class <classname>D</classname></title>
                  
                  <para>If <classname>D</classname> is an array, that is
                  <classname>D</classname> &equiv;
                  <classname>T[]&hellip;[]</classname>, then we treat
                  <classname>D</classname> as if it is the class
                  <classname>java.lang.Array</classname>.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>Each
                  <replaceable>R<subscript>i</subscript></replaceable>
                  must be unique</title>
                  
                  <para>A region cannot be aggregated more than once.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>If <structfield>field</structfield> is not
                  <code>final</code> then
                  <structfield>field</structfield> must be a subregion
                  of or equal to each
                  <replaceable>Q<subscript>i</subscript></replaceable></title>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title><replaceable>Q<subscript>i</subscript></replaceable> cannot be <code>final</code> or <code>volatile</code></title>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>If <structfield>field</structfield> is
                  <code>final</code> and <code>static</code> then all regions
                  <replaceable>Q<subscript>i</subscript></replaceable>
                  must be <code>static</code></title>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>Each
                  <replaceable>R<subscript>i</subscript></replaceable>
                  must be accessible in the context of class
                  <classname>C</classname></title>

                  <para>It violates abstraction to refer to
                  <code>private</code> regions of the referenced
                  object.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>Each
                  <replaceable>Q<subscript>i</subscript></replaceable>
                  must be accessible in the context of class
                  <classname>C</classname></title>

                  <para>It violates abstraction to refer to
                  <code>private</code> regions of <classname>D</classname>'s ancestors.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>All instance regions of
                  <classname>D</classname> must be mapped into a region
                  of <classname>C</classname></title>

                  <para>Practically, speaking, this requirement means
                  that the <structfield>Instance</structfield> of
                  <classname>D</classname> must be explicitly aggregated
                  into a region of <classname>C</classname>.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title>Aggregation must respect the region
                  hierarchy</title>

                  <para>Formally, if the annotation maps
                  <replaceable>R<subscript>i</subscript></replaceable>
                  into
                  <replaceable>Q<subscript>i</subscript></replaceable>
                  and
                  <replaceable>R<subscript>j</subscript></replaceable>
                  into
                  <replaceable>Q<subscript>j</subscript></replaceable>,
                  and
                  <replaceable>R<subscript>i</subscript></replaceable>
                  is a subregion of
                  <replaceable>R<subscript>j</subscript></replaceable>,
                  then
                  <replaceable>Q<subscript>i</subscript></replaceable>
                  <emphasis>must</emphasis> be a subregion of
                  <replaceable>Q<subscript>j</subscript></replaceable>.</para>
                </formalpara>
              </listitem>
            </itemizedlist>
          </para>
        </sect2>
      </sect1>
      
      <sect1>
        <title>MapFields</title>
        
        <para>To do&hellip;</para>
      </sect1>
    </chapter>
    
    <chapter id="effect-annotations">
      <title>Region Effect Annotations</title>
      
      <para>The effects a method may have on the state of the program
      are declared using a single annotation
      <classname>@RegionEffects</classname>.  The syntax and constraints
      for this annotation are described below.  Effects declarations are
      effectively lists of <emphasis>targets</emphasis>. In Java, the handle on an object is
      a reference. Therefore, it is not possible to name a region of a
      particular object, only to name a region of the object referenced
      by a particular expression. Targets, are an extrinsic syntactic
      mechanism to name references to regions. Targets have several
      syntactic forms due to the different way that state may be
      identified.  The syntax and constraint for these different forms are 
      described below.</para>
      
      <para>All targets contain a reference to a region name. <emphasis
      id="preserve.abstraction">Access to this region must preserve
      abstraction.</emphasis>  This requires two things:

        <itemizedlist>
          <listitem>
            <formalpara>
              <title> The region must be accessible to the method being annotated</title>
              
              <para>If the method cannot use the region, it has no
              business naming it in an annotation.</para>
            </formalpara>
          </listitem>

          <listitem>
            <formalpara>
              <title>The region must be accessible to all potential
              callers of the method.</title>
              
              <para>It's not fair, for example, to expose the existence
              of <code>private</code> regions to contexts that wouldn't
              normally be able to access them.</para>
            </formalpara>
          </listitem>
        </itemizedlist>
      </para>
      
      <para>In general, the second point is satisfied by only allowing a
      method to name a region in a target based on the visibility of the
      method and the visibility of the region:
      
        <informaltable>
          <tgroup align="center" cols="6">
            <colspec colnum="1" colname="c1"/>
            <colspec colnum="2" align="right" colname="c2"/>
            <colspec colnum="3" colname="c3"/>
            <colspec colnum="6" colname="c6"/>
            <thead>
              <row>
                <entry namest="c1" nameend="c2" morerows="1"></entry>
                <entry namest="c3" nameend="c6">Region Visibility</entry>
              </row>
              <row>
                <entry namest="c3"><code>private</code></entry>
                <entry>default</entry>
                <entry><code>protected</code></entry>
                <entry><code>public</code></entry>
              </row>
            </thead>
            
            <tbody>
              <row>
                <entry morerows="3" valign="middle" rotate="1"><emphasis role="strong">Method Visibility</emphasis></entry>
                <entry><emphasis role="strong"><code>private</code></emphasis></entry>
                <entry>Yes</entry>
                <entry>Yes</entry>
                <entry morerows="2" valign="middle"><co id="protected.special.case"/></entry>
                <entry>Yes</entry>
              </row>
            
              <row>
                <entry><emphasis role="strong">default</emphasis></entry>
                <entry>No</entry>
                <entry>Yes</entry>
                <!-- protected case -->
                <entry>Yes</entry>
              </row>
            
              <row>
                <entry><emphasis role="strong"><code>protected</code></emphasis></entry>
                <entry>No</entry>
                <entry>No</entry>
                <!-- protected case -->
                <entry>Yes</entry>
              </row>
             
              <row>
                <entry><emphasis role="strong"><code>public</code></emphasis></entry>
                <entry>No</entry>
                <entry>No</entry>
                <entry>No</entry>
                <entry>Yes</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        
        <calloutlist>
          <callout arearefs="protected.special.case">
            <para>The region may be used <emphasis>unless</emphasis> the
            region is declared in a superclass <classname>S</classname>
            of the class <classname>C</classname> that contains the
            method being annotated and <classname>S</classname> is not
            in the same package as <classname>C</classname>.</para>
          </callout>
        </calloutlist>
      </para>
      
      <sect1>
        <title>Region Effect Declaration</title>
        
        <para>A method's effects on the state of the program are declared using
        the annotation
        
          <synopsis>
@RegionEffects("reads <optional><co id="read.targets"/><replaceable>readTarget<subscript>1</subscript></replaceable>, &hellip;, <replaceable>readTarget<subscript>n</subscript></replaceable></optional>
    <optional>; writes <co id="write.targets"/><replaceable>writeTarget<subscript>1</subscript></replaceable>, &hellip;, <replaceable>writeTarget<subscript>m</subscript></replaceable></optional>")        
          </synopsis>

          <calloutlist>
            <callout arearefs="read.targets">
              <para><replaceable>readTarget<subscript>i</subscript></replaceable> are targets;
              <replaceable>n</replaceable> &ge; 1.</para>
            </callout>
            <callout arearefs="write.targets">
              <para><replaceable>writeTarget<subscript>j</subscript></replaceable> are targets;
              <replaceable>m</replaceable>
              &ge; 1.</para>
            </callout>
          </calloutlist>

        The order of the <code>reads</code> and <code>writes</code>
        clauses does not matter. If there are no read or write effects,
        the respective clause may be omitted. If the method has no
        effects the appropriate annotation is

          <synopsis>
@RegionEffects("none")
          </synopsis>
        </para>
        
        <para>Thus the following are all legal effects annotations
        (assuming that their targets are legal):

          <simplelist>
            <member><code>@RegionEffects("none")</code></member>
            <member><code>@RegionEffects("reads this:Instance; writes p:Instance")</code></member>
            <member><code>@RegionEffects("writes this:Color, this:Location; reads this:Size")</code></member>
            <member><code>@RegionEffects("writes Instance")</code></member>
            <member><code>@RegionEffects("reads Instance")</code></member>
          </simplelist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The targets
                <replaceable>readTarget<subscript>i</subscript></replaceable> and
                <replaceable>writeTarget<subscript>i</subscript></replaceable>
                must be legal.</title>
                
                <para>The rules for legal targets are enumerated in the
                following subsections.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Instance Targets</title>
        
        <para>An instance target has one of the following forms:</para>
        
        <informaltable>
          <tgroup align="left" cols="2">
            <thead>
              <row align="center">
                <entry>Syntax</entry>
                <entry>Constraints</entry>
              </row>
            </thead>
          
            <tbody>
              <row>
                <entry>
                  <synopsis>
this:<co id="instance.target.reg1"/><replaceable>region_name</replaceable>
                  </synopsis>
                  <calloutlist>
                    <callout arearefs="instance.target.reg1">
                      <para>The name of a region.</para>
                    </callout>
                  </calloutlist>
                </entry>
              
                <entry>
                  <itemizedlist>
                    <listitem>
                      <formalpara>
                        <title>The target must <link
                        linkend="preserve.abstraction">preserve
                        abstraction</link></title>
                      </formalpara>
                    </listitem>
                    <listitem>
                      <formalpara>
                        <title>The annotation must be on a non-<code>static</code> method</title>
                      
                        <para>Methods that are <code>static</code> don't
                        have a receiver. Constructors mask their effects
                        on the receiver, so there is no point in
                        declaring them</para>
                      </formalpara>
                    </listitem>
                    <listitem>
                      <formalpara>
                        <title>The region identified by <replaceable>region_name</replaceable> must a
                        non-<code>static</code> region that exists in the type of the
                        method receiver</title>
                      </formalpara>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>

              <row>
                <entry>
                  <synopsis>
<co id="instance.target.param"/><replaceable>parameter_name</replaceable>:<co id="instance.target.reg2"/><replaceable>region_name</replaceable>
                  </synopsis>
                  <calloutlist>
                    <callout arearefs="instance.target.param">
                      <para>The name of a method/constructor parameter.</para>
                    </callout>
                    <callout arearefs="instance.target.reg2">
                      <para>The name of a region.</para>
                    </callout>
                  </calloutlist>
                </entry>
              
                <entry>
                  <itemizedlist>
                    <listitem>
                      <formalpara>
                        <title>The target must <link
                        linkend="preserve.abstraction">preserve
                        abstraction</link></title>
                      </formalpara>
                    </listitem>
                    <listitem>
                      <formalpara>
                        <title>The parameter <replaceable>parameter_name</replaceable> must be a
                        parameter of the annotated method/constructor
                        and be of a non-primitive type</title>
                      </formalpara>
                    </listitem>
                    <listitem>
                      <formalpara>
                        <title>The region identified by <replaceable>region_name</replaceable> must
                        a non-<code>static</code> region that exists in the type of
                        the parameter <replaceable>parameter_name</replaceable></title>
                      </formalpara>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>

              <row>
                <entry>
                  <synopsis>
<co id="instance.target.type"/><replaceable>type_name</replaceable>.this:<co id="instance.target.reg3"/><replaceable>region_name</replaceable>
                  </synopsis>
                  <calloutlist>
                    <callout arearefs="instance.target.type">
                      <para>The name of a class.</para>
                    </callout>
                    <callout arearefs="instance.target.reg3">
                      <para>The name of a region.</para>
                    </callout>
                  </calloutlist>
                </entry>
              
                <entry>
                  <itemizedlist>
                    <listitem>
                      <formalpara>
                        <title>The target must <link
                        linkend="preserve.abstraction">preserve
                        abstraction</link></title>
                      </formalpara>
                    </listitem>
                    <listitem>
                      <formalpara>
                        <title>The method/constructor being annotated
                        must be in a non-<code>static</code> inner class</title>
                        
                        <para>If a nested class is <code>static</code>
                        then it doesn't have an outer receiver. (A
                        <code>static</code> method may never refer to a
                        qualified receiver because they must always be
                        inside of <code>static</code> nested
                        class.)</para>
                      </formalpara>
                    </listitem>
                    <listitem>
                      <formalpara>
                        <title>The class named by <code>type_name</code>
                        must exist and be a lexically enclosing
                        class<footnote><para>A class
                        <replaceable>O</replaceable> is the zeroth
                        lexically enclosing class of itself.  A class
                        <replaceable>O</replaceable> is the
                        <replaceable>n</replaceable><superscript>th</superscript>
                        lexically enclosing class of a
                        class <replaceable>C</replaceable> if it is the
                        immediately enclosing class of the
                        (<replaceable>n</replaceable>-1)<superscript>st</superscript>
                        lexically enclosing class of
                        <replaceable>C</replaceable>.  (<ulink url="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.1.3"><citetitle pubwork="book">The Java Language Specification, 3<superscript>rd</superscript> Edition</citetitle>
                        &sect;8.1.3</ulink>)</para></footnote> of the class that
                        contains the method/constructor being
                        annotated.</title>
                      </formalpara>
                    </listitem>
                    <listitem>
                      <formalpara>
                        <title>The region identified by
                        <replaceable>region_name</replaceable> must a
                        non-<code>static</code> region that exists in
                        <replaceable>type_name</replaceable></title>
                      </formalpara>
                    </listitem>
                  </itemizedlist>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>        
      </sect1>
      
      <sect1>
        <title>Any-Instance Target</title>
        
        <para>An any-instance target has the form
        
          <synopsis>
any(<co id="any.instance.type"/><replaceable>type_name</replaceable>):<co id="any.instance.region"/><replaceable>region_name</replaceable>
          </synopsis>
          
          <calloutlist>
            <callout arearefs="any.instance.type">
              <para>The name of a class or interface.</para>
            </callout>
            <callout arearefs="any.instance.region">
              <para>The name of a region.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The target must <link linkend="preserve.abstraction">preserve
                abstraction</link></title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The class/interface identified by
                <replaceable>type_name</replaceable> must exist</title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The region identified by
                <replaceable>region_name</replaceable> must a
                non-<code>static</code> region that exists in
                <replaceable>type_name</replaceable></title>
                
                <para>There is no point in the region being <code>static</code>: in
                that case a <link linkend="class.target">class target</link> can be used.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1 id="class.target">
        <title>Class Target</title>
        
        <para>An any-instance target has the form
        
          <synopsis>
<co id="class.instance.type"/><replaceable>type_name</replaceable>:<co id="class.instance.region"/><replaceable>region_name</replaceable>
          </synopsis>
          
          <calloutlist>
            <callout arearefs="class.instance.type">
              <para>The name of a class or interface.</para>
            </callout>
            <callout arearefs="class.instance.region">
              <para>The name of a region.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The target must <link linkend="preserve.abstraction">preserve
                abstraction</link></title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The class/interface identified by
                <replaceable>type_name</replaceable> must exist</title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The region identified by
                <replaceable>region_name</replaceable> must a
                <code>static</code> region that exists in
                <replaceable>type_name</replaceable></title>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1 id="implicit.target">
        <title>Implicitly Qualified Target</title>
        
        <para>A target may also have the simple form
        
          <synopsis>
<co id="implicit.region"/><replaceable>region_name</replaceable>
          </synopsis>
          
          <calloutlist>
            <callout arearefs="implicit.region">
              <para>The name of a region.</para>
            </callout>
          </calloutlist>
          
        This is shorthand for either an instance target, <code>this:<replaceable>region_name</replaceable></code>,
        or a class target <code><replaceable>type_name</replaceable>:<replaceable>region_name</replaceable></code>, where
        <replaceable>type_name</replaceable> is the class in which <replaceable>region_name</replaceable> is
        declared, depending on whether the region named by <replaceable>region_name</replaceable>
        is an instance or a static region, respectively.
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The target must <link linkend="preserve.abstraction">preserve
                abstraction</link></title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>If named region is non-<code>static</code>, then the annotation must
                be on a non-<code>static</code> method</title>
                   
                <para>Methods that are <code>static</code> don't have a
                receiver. Constructors mask their effects on the
                receiver, so there is no point in declaring them</para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The region identified by
                <replaceable>region_name</replaceable> must be declared in the annotated class
                or one of its ancestors.</title>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
    </chapter>
    
    <chapter id="lock-annotations">
      <title>Lock Annotations</title>
      
      <sect1>
        <title>Region Lock Declaration</title>
        
        <para>Region lock declarations have the form
          <synopsis>
@RegionLock("<co id="reg.lock.name"/><replaceable>lock</replaceable> is <co id="reg.lock.field"/><replaceable>field</replaceable> protects <co id="reg.lock.region"/><replaceable>region</replaceable>")          
          </synopsis>
          
          <calloutlist>
            <callout arearefs="reg.lock.name">
              <para>The name of the lock or <emphasis>lock id</emphasis>.</para>
            </callout>
            <callout arearefs="reg.lock.field">
              <para>The <emphasis>lock field</emphasis>: the name of a
              field, <structfield>class</structfield>,
              <parameter>this</parameter>, or a qualified
              <parameter>this</parameter> expression
              (<parameter><replaceable>class_name</replaceable>.this</parameter>).</para>
            </callout>
            <callout arearefs="reg.lock.region">
              <para>The name of a region.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2 id="lock.id.constraints">
          <title>Lock Id Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The lock id must be unique within the class and
                its ancestors</title>
                
                <para>That is, a class cannot declare a lock
                that has the same id as a lock declared in an ancestor.
                This simplifies things by eliminating name hiding.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
        
        <sect2 id="lock.field.constraints">
          <title>Lock Field Constraints</title>

          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The lock field must exist</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>If <replaceable>field</replaceable> is non-<code>static</code>, it must be
                from the class being annotated or one of its ancestors</title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The lock field must be <code>final</code></title>
                
                <para>Otherwise the object referenced by the field could
                be changed and then JSure will not be able to guarantee
                that all <code>synchronized</code> statements that use
                that field are locking the same object.
                <parameter>this</parameter> and
                <structfield>class</structfield> are implicitly
                <code>final</code>.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The type of the lock field must not be primitive</title>
                
                <para>Java does not allow primitive types to be used in
                <code>synchronized</code> statements.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
        
        <sect2>
          <title>Region Constraints</title>

          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The region must exist</title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The region must not be associated with any other
                locks in the same class or its ancestors</title>
                
                <para>Mutual exclusion cannot be guaranteed if multiple
                locks protect the same region. For
                non-<code>static</code> regions, this means there cannot
                be an ancestor class <classname>S</classname>, where
                <classname>S</classname> could be the class containing
                the annotation in question, that also associates a lock
                with the region. For <code>static</code> regions, it
                means the class that declares the region cannot
                associate more than one lock with it. (A rule below
                requires that a <code>static</code> region can only be
                associated with a lock by the class that declares the
                region.)</para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>A <code>static</code> region must be protected by
                a <code>static</code> lock field, or
                <structfield>class</structfield></title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>A non-<code>static</code> region must be
                protected by a non-<code>static</code> lock field, or
                <parameter>this</parameter> or a qualified
                <parameter>this</parameter> expression</title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>If the region is <code>static</code>, it must be
                declared in the same class as the lock
                declaration</title>
                
                <para>It's not fair to impose locking constraints on a
                class from another class.</para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The lock field must be at least as visible as the region</title>

                <para>Otherwise, you have severely limited the
                usefulness of the region, because it won't be usable
                outside of the scope of the lock field. The field itself
                need not be declared to have the necessary visibility.
                The visibility of a lock field can be modified through
                the use of methods that are annotated with
                <classname>@ReturnsLock</classname>. So a
                <code>private</code> field can be used to protect a
                <code>protected</code> region as long as there is a
                <code>protected</code> (or <code>public</code>) method
                in the class that is declared to return the lock.</para>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>If the region is inherited (not declared in the
                annotated class), it must not contain any fields</title>
                
                <para>It may have subregions, but those subregions
                cannot contain fields. This is necessary to prevent
                upcasting from being used to compromise lock
                policies.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>

      <sect1>
        <title>Policy Lock Declaration</title>
        
        <para>Policy lock declarations have the form
          <synopsis>
@RegionLock("<co id="policy.lock.name"/><replaceable>lock</replaceable> is <co id="policy.lock.field"/><replaceable>field</replaceable>")          
          </synopsis>
          
          <calloutlist>
            <callout arearefs="policy.lock.name">
              <para>The name of the lock or <emphasis>lock id</emphasis>.</para>
            </callout>
            <callout arearefs="policy.lock.field">
              <para>The <emphasis>lock field</emphasis>: the name of a
              field, <structfield>class</structfield>,
              <parameter>this</parameter>, or a qualified
              <parameter>this</parameter> expression
              (<parameter><replaceable>class_name</replaceable>.this</parameter>).</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <para>Policy lock declarations have the same <link
          linkend="lock.id.constraints">lock id</link> and <link
          linkend="lock.field.constraints">lock field</link> constraints
          as region lock declarations.</para>
        </sect2>
      </sect1>
      
      <sect1 id="lock.names">
        <title>Lock Names</title>
      
        <para><classname>@ReturnsLock</classname> and
        <classname>@RequiresLock</classname> annotations make use of
        <emphasis>lock names</emphasis>. Lock names have their own
        semantic constraints. A lock name identifies a lock in a
        particular object reference or class. It differs from a
        <emphasis>lock id</emphasis>: The lock id is the name of the
        lock as it is declared, while the lock name represents a
        particular instance of the lock.</para>
        
        <para>For <emphasis><code>static</code> locks</emphasis>
        (locks whose lock field is a <code>static</code> field or a
        class object), there is only one instance of the lock and its
        name is the lock id qualified by the name of the class in which
        it is declared.</para>
        
        <para>Otherwise we have an <emphasis>instance lock</emphasis> whose
        lock name is the lock id qualified by the name of a local
        variable (possibly <parameter>this</parameter>) that references the
        object that contains the lock.</para>
        
        <para>We differentiate between a <emphasis>raw</emphasis> lock name and a 
        <emphasis>decorated</emphasis> lock name.  This distinction is necessary
        because of the nature of read&ndash;write locks as implemented by
        <classname>ReadWriteLock</classname> in <package>java.util.concurrent</package>.
        A raw lock name refers to a declared lock, identified with an object referenced
        as a Java intrinsic lock, a <classname>java.util.concurrent.Lock</classname> object,
        or a <classname>java.util.concurrent.ReadWriteLock</classname> object.  In most cases
        a <classname>ReadWriteLock</classname> identified by a raw lock name is not useful
        because it cannot be acquired directly: the read or write lock must be identified.  
        This is the role of the decorated lock name, which is a raw lock name enhanced to 
        further identify either the read or write lock.</para>
                
        <sect2 id="naming.raw.locks">
          <title>Raw Lock Names</title>
          
          <para>A raw lock name must conform
          to the syntax and constraints shown in <xref linkend="lock.name.constraints"/>.
          </para>
          
          <table id="lock.name.constraints">
            <title>Syntax and Constraints for Naming Raw Locks</title>
            
            <tgroup align="left" cols="2">
              <thead>
                <row align="center">
                  <entry>Syntax</entry>
                  <entry>Constraints</entry>
                </row>
              </thead>
          
              <tbody>
                <row>
                  <entry>
                    <synopsis>
<co id="lockid1"/><replaceable>lock_id</replaceable><!--no break here--><footnote><para>This form is really a shorthand for either
                    <parameter>this</parameter><code>:</code><replaceable>lock_id</replaceable> or
                    <classname>fully.qualified.class.name</classname><code>:</code><replaceable>lock_id</replaceable> where
                    <classname>fully.qualified.class.name</classname> is
                    the name of the class containing the annotated method.
                     The ambiguity is resolved by checking whether
                    <replaceable>lock_id</replaceable> names a instance or
                    <code>static</code> lock, respectively.</para></footnote></synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lockid1">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title><replaceable>lock_id</replaceable> must
                          exist in the class containing the annotated
                          method</title>
                        </formalpara>
                      </listitem>
                      
                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          refer to a <code>static</code> lock if the
                          method is <code>static</code></title>

                          <para>Although, a non-<code>static</code> method
                          may refer to either a <code>static</code> or an instance
                          lock.</para>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>

                <row>
                  <entry>
                    <synopsis>
<co id="lock.name.param"/><replaceable>parameter_name</replaceable>:<co id="lockid2"/><replaceable>lock_id</replaceable>
                    </synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lock.name.param">
                        <para>The name of a method/constructor parameter,
                        including <parameter>this</parameter>.</para>
                      </callout>
                      <callout arearefs="lockid2">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title>The parameter
                          <replaceable>parameter_name</replaceable> must
                          be a <code>final</code> parameter of the annotated
                          method/constructor</title>
                        
                          <para>If the parameter isn't <code>final</code>
                          then the object referenced by the parameter can
                          change during execution of the method and the
                          named lock is not unique.  Note that
                          <parameter>this</parameter> <emphasis>is
                          not</emphasis> a parameter of
                          <code>static</code> methods.</para>
                        </formalpara>
                      </listitem>
  
                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          name an instance lock in the type of the parameter</title>
                        
                          <para>For clarity purposes we do not allow
                          <code>static</code> locks to be named through instances; it
                          only leads to confusion.</para>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>

                <row>
                  <entry>
                    <synopsis>
<co id="lock.name.fqclass1"/><replaceable>fully.qualified.class.name</replaceable>:<co id="lockid3"/><replaceable>lock_id</replaceable>
                    </synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lock.name.fqclass1">
                        <para>A fully qualified class name.</para>
                      </callout>
                      <callout arearefs="lockid3">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title>The named class
                          <replaceable>fully.qualified.class.name</replaceable>
                          must exist.</title>
                        </formalpara>
                      </listitem>

                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          name a <code>static</code> lock in the type <replaceable>fully.qualified.class.name</replaceable></title>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>

                <row>
                  <entry>
                    <synopsis>
<co id="lock.name.fqclass2"/><replaceable>fully.qualified.class.name</replaceable>.this:<co id="lockid4"/><replaceable>lock_id</replaceable>
                    </synopsis>
                  
                    <calloutlist>
                      <callout arearefs="lock.name.fqclass2">
                        <para>A fully qualified class name.</para>
                      </callout>
                      <callout arearefs="lockid4">
                        <para>A lock id.</para>
                      </callout>
                    </calloutlist>
                  </entry>
                
                  <entry>
                    <itemizedlist>
                      <listitem>
                        <formalpara>
                          <title>The qualified receiver
                          <replaceable>fully.qualified.class.name</replaceable>.this
                          must exist for the annotated method</title>
                        </formalpara>
                      </listitem>
  
                      <listitem>
                        <formalpara>
                          <title>The lock id <replaceable>lock_id</replaceable> must
                          name an instance lock in the type <replaceable>fully.qualified.class.name</replaceable></title>
                        </formalpara>
                      </listitem>
                    </itemizedlist>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </sect2>
        
        <sect2 id="naming.decorated.locks">
          <title>Decorated Lock Names</title>
          
          <para>The syntax and constraints for a decorated lock name are similar
          to those shown in <xref linkend="lock.name.constraints"/> with the following
          exceptions:
          
            <itemizedlist>
              <listitem>
                <formalpara>
                  <title><replaceable>lock_id</replaceable>
                    <emphasis>must</emphasis> refer to a lock whose lock
                    field refers to an object of type
                    <classname>java.util.concurrent.locks.ReadWriteLock</classname>
                  </title>
                
                  <para>Intrinsic locks and
                  <classname>java.util.concurrent.locks.Lock</classname>
                  objects do not have any sub components.</para>
                </formalpara>
              </listitem>
              
              <listitem>
                <formalpara>
                  <title><replaceable>lock_id</replaceable> must be followed
                    by either "<code>.readLock()</code>" or "<code>.writeLock()</code>"
                  </title>
                  
                  <para>This refers to the read lock or write lock component, respectively.</para>
                </formalpara>
              </listitem>
            </itemizedlist>
          </para>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Returns Lock</title>
        
        <para>A declaration that a method returns a particular lock has the form

          <synopsis>
@ReturnsLock("<co id="ret.lock.name"/><replaceable>raw_lock_name</replaceable>")
          </synopsis>
          
          <calloutlist>
            <callout arearefs="ret.lock.name">
              <para>A raw lock name.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The raw lock name <replaceable>raw_lock_name</replaceable> must be
                <link linkend="naming.raw.locks">well-formed</link></title>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Lock Preconditions</title>
        
        <para>Methods and constructors declare lock preconditions using

          <synopsis>
@RequiresLock("<co id="req.lock.name"/><replaceable>lock_name<subscript>1</subscript></replaceable>, &hellip;, <replaceable>lock_name<subscript>n</subscript></replaceable>")<co id="req.lock.n"/>
          </synopsis>
          
          <calloutlist>
            <callout arearefs="req.lock.name">
              <para><replaceable>lock_name<subscript>i</subscript></replaceable> are
              lock names.</para>
            </callout>
            <callout arearefs="req.lock.n">
              <para><replaceable>n</replaceable> &ge; 1.</para>
            </callout>
          </calloutlist>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>Each <replaceable>lock_name<subscript>i</subscript></replaceable>, which may be a raw or decorated lock name, must be
                <link linkend="lock.names">well-formed</link></title>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>If <replaceable>lock_name<subscript>i</subscript></replaceable>
                  is a raw lock name, then the <replaceable>lock_id</replaceable> <emphasis>cannot</emphasis> refer
                  to a lock whose lock field refers to an object of
                  type <classname>java.util.concurrent.locks.ReadWriteLock</classname>.</title>
                
                <para>It does not make sense to require a read&ndash;write lock object because that
                lock cannot be acquired.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>Constructors and <code>static</code> methods
                cannot require callers to hold locks on the receiver
                (<parameter>this</parameter>)</title>
                
                <para><code>static</code> methods don't have a receiver
                so this would be nonsense. For constructors, the
                receiver doesn't yet exist at the call site, so a caller
                could never acquire it before hand.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>If the lock is a non-<code>static</code> lock of the receiver,
                or is a <code>static</code> lock from the same class as the annotated
                method/constructor then it must be at least as visible as
                the method/constructor</title>
                
                <para>To be truly useful, the required lock should be
                visible at the <emphasis>call site</emphasis> of the
                method. This is not determinable in general when looking
                at the annotated method; it can only be determined by
                looking at the call sites. But these are two common
                cases that can be checked at the method
                declaration.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>A particular lock for a particular object can
                only be named once per method</title>
                
                <para>There is no advantage to naming a lock more than
                once; it probably represents an error on the part of the
                programmer.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
    </chapter>
    
    <chapter id="uniqueness-annotations">
      <title>Uniqueness Annotations</title>
      
      <sect1>
        <title>Uniqueness Declarations</title>
        
        <para>The same annotation, <classname>@Unique</classname>, is used to annotate
          <itemizedlist>
            <listitem><para>That a field reference is
            unaliased.</para></listitem>

            <listitem><para>That a method/constructor returns an
            unaliased reference.</para></listitem>

            <listitem><para>That a method/constructor parameter expects
            to be passed an unaliased.</para></listitem>
          </itemizedlist>
          
        The general form of the annotation is 
        
          <synopsis>
@Unique("<optional>this <optional>, return</optional></optional>")
          </synopsis>
          
        where the order of <code>this</code> and <code>return</code>
        doesn't matter. Fields and parameters are annotated without any
        argument to <classname>@Unique</classname>; in fact it is syntax
        error if the annotation is not
        <classname>@Unique("")</classname>:<footnote><para><classname>@Unique</classname>
        is syntactic sugar for
        <classname>@Unique("")</classname>.</para></footnote>
        
          <programlisting>
class C {
  <emphasis>@Unique</emphasis>
  List list;
  &hellip;
  public void method(final <emphasis>@Unique</emphasis> Object p) {
    &hellip;
  }
  &hellip;
}
          </programlisting>
        
        The receiver (<parameter>this</parameter>) is a special case because it is not explicitly
        declared.  To annotate that the receiver must be unaliased, the method itself must be
        annotated instead:
        
          <programlisting>
class C {
  &hellip;
  <emphasis>@Unique("this")</emphasis>
  public void needsUnaliasedReceiver(&hellip;) {
    &hellip;
  }
  &hellip;
}
          </programlisting>
          
        A method may be annotated to indicate that the return value is an unaliased 
        object.  A constructor may be annotated to indicate that the newly constructed
        object is not aliased. Both these cases share the same annotation:
        
          <programlisting>
class C {
  <emphasis>@Unique("return")</emphasis>
  public C(&hellip;) {
    &hellip;
  }
  
  <emphasis>@Unique("return")</emphasis>
  public Object method(&hellip;) {
    &hellip;
  }
  &hellip;
}
          </programlisting>
          
        If a method both requires an unaliased receiver and guarantees
        an unaliased return value, the appropriate annotation is
        <classname>@Unique("this, return")</classname> or
        <classname>@Unique("return, this")</classname>.</para>
        
        <sect2>
          <title>Field Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The field must have a non-primitive type</title>
              </formalpara>
            </listitem>
            <listitem>
              <formalpara>
                <title>The field must also have an <classname>@Aggregate</classname> annotation</title>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
        
        <sect2>
          <title>Parameter Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The parameter must have a non-primitive type</title>
                
                <para>This is trivially satisfied when the the receiver is unique.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
        
        <sect2>
          <title>Return Value Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The return value must have a non-primitive type</title>
                
                <para>This is trivially satisfied when annotating a constructor return value.</para>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Non-Uniqueness Declaration</title>
        
        <para>Uniqueness on parameters is <emphasis>contravariant</emphasis>, meaning that
        the constraint may be relaxed when the method that contains the
        parameter is overridden. We cannot relax <classname>@Unique</classname> by simply not
        stating it because in that case the annotation inheritance
        system<footnote><para>Not yet implemented.</para></footnote> would cause the <classname>@Unique</classname> annotation to be applied anyway.
        So we must explicitly state that a parameter is not required to
        be unique using the annotation
        
          <synopsis>
@NotUnique("<optional>this</optional>")
          </synopsis>
        
        As with <classname>@Unique</classname>, this annotation is normally used on 
        parameter declarations, except in the special case of the receiver, where it is used
        on the method itself:
        
          <programlisting>
class C {
  @Unique("this")
  public void method1() {
    &hellip;
  }
  
  public void method2(@Unique Object p) {
    &hellip;
  }
}

class D extends C {
  <emphasis>@NotUnique("this")</emphasis>
  public void method1() {
    &hellip;
  }
  
  public void method2(<emphasis>@NotUnique</emphasis> Object p) {
    &hellip;
  }
}
          </programlisting>
        </para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The parameter must have a non-primitive type</title>
                
                <para>This is trivially satisfied when the the receiver is not unique.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The parameter must not also be explicitly annotated with <classname>@Unique</classname></title>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
      
      <sect1>
        <title>Borrowed Parameter Declarations</title>
        
        <para>A method can be constrained to not create aliases to
        a particular parameter using the annotation
        
          <synopsis>
@Borrowed("<optional>this</optional>")
          </synopsis>
          
        As with <classname>@Unique</classname> and <classname>@NotUnique</classname>, 
        the form <classname>@Borrowed</classname> is used when annotated an explicit
        parameter declaration, and the method annotation <classname>@Borrowed("this")</classname>
        is used when annotating the receiver.</para>
        
        <sect2>
          <title>Constraints</title>
          
          <itemizedlist>
            <listitem>
              <formalpara>
                <title>The parameter must have a non-primitive type</title>
                
                <para>This is trivially satisfied when the the receiver is borrowed.</para>
              </formalpara>
            </listitem>

            <listitem>
              <formalpara>
                <title>The parameter must not also be explicitly
                annotated with <classname>@Unique</classname></title>
              </formalpara>
            </listitem>
          </itemizedlist>
        </sect2>
      </sect1>
    </chapter>
  
    <appendix condition="isHTML">
      <title>SureLogic Annotation Types JavaDoc</title>
    
      <para>Please see the <ulink url="javadoc/index.html">generated JavaDoc pages</ulink> for
      more information.</para>
    </appendix>
  </part>
</book>
