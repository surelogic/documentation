<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book id="guide-to-design-intent" lang="en-US">
  <title>An Introduction to Declaring Design Intent with JSure</title>
  <bookinfo>
    <copyright>
      <year>2008</year>
      <holder>SureLogic, Inc.</holder>
    </copyright>
  </bookinfo>

  <chapter id="simple-lock-models">
    <title>Simple Lock Models</title>
    <sect1 id="basic-model">
      <title>The Basic Lock Model</title>
      
      <para>The canonical Java model whereby an object protects itself
      is declared by annotating a class with
      <varname>@RegionLock</varname>:<footnote><para>We use empahsis in
      the code to highlight interesting annotations or interesting
      segments of code.  Specifically, we are not placing emphasis on
      all annotations that occur within the displayed source
      code.</para></footnote></para>
      
      <programlisting>
<emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class C {
  protected int f;
  &hellip;
}
      </programlisting>

      <para>This single class annotation does three things:</para>

      <orderedlist>
	<listitem><para>Declares a new lock named
	<computeroutput>Lock</computeroutput>.  The lock name enables
	consistent reference to the lock object in other
	annotations.</para></listitem>

	<listitem><para>Identifies that lock with instances of the
	class
	(<computeroutput>this</computeroutput>).</para></listitem>

	<listitem><para>Protects all the fields in instances of the
	class (the <emphasis>region</emphasis>
	<computeroutput>Instance</computeroutput>) .  Regions are
	described in more detail in XXX; for now it is enough to
	know</para>

	  <itemizedlist>
	    <listitem><para>All classes have an
	    <computeroutput>Instance</computeroutput>
	    region.</para></listitem>

	    <listitem><para>The region contains all the
	    non-<computeroutput>static</computeroutput> fields of the
	    class.</para></listitem>
  	  </itemizedlist>
	</listitem>
      </orderedlist>

      <para>In other words, all accesses to instance variables, for
      example <varname>f</varname>, of objects of class
      <varname>C</varname> must be within blocks
      <varname>synchronized</varname> on the instance.  The following
      two methods of class <varname>C</varname> would assure</para>

      <programlisting>
  public synchronized set(final int value) {
    this.f = value;
  }
  public int get() {
    synchronized (this) {
      return this.f;
    }
  }
      </programlisting>

      <para>The following method of <varname>C</varname>, however,
      would not because although the method correctly protects the
      read of the field <varname>f</varname> of the object referenced
      by <varname>other</varname>, it does not protect the write to
      the field <varname>f</varname> of the object referenced by
      <varname>this</varname>:</para>

      <programlisting>
  public void copy(final C other) {
    synchronized (other) {
      this.f = other.f;
    }
  }
      </programlisting>
    </sect1>
    
    <sect1 id="extended-model1">
      <title>Extending the Model: Caller Locking</title>
      
	  <para>A frequent exception to the basic lock model is the
      expectation by a method implementation that it is the
      responsibility of the caller of the method to acquire the lock. 
      Analysis can assure this expectation if it is declared using the
      <varname>@RequiresLock</varname> method annotation:</para>
      
      <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  private int f;

  <emphasis>@RequiresLock("Lock")</emphasis>
  public void m() { &hellip; }
  &hellip;
}
      </programlisting>
      
      <para>When analyzing the implementation of method
      <varname>C.m()</varname>, analysis assumes that lock
      <varname>Lock</varname> is held.  When analyzing the callsite of
      the method, however, analysis requires that the calling context
      hold the lock object identified with <varname>Lock</varname>.  The
      method implementations <varname>C.m()</varname> and
      <varname>C.calls_m()</varname>, below, are thus both
      correct:</para>

	  <programlisting>
  <emphasis>@RequiresLock("Lock")</emphasis>
  public void m() {
    this.f = 0;
  }
  
  protected synchronized void calls_m() {
    this.m();
  }
      </programlisting>

      <para>The method implementation of <varname>Other.bad()</varname>
      is, however, erroneous because it does acquire the lock on the
      object referenced by <varname>cObject</varname>:</para>
      
      <programlisting>
public class Other {
  &hellip;
  public bad(final C cObject) {
    cObject.m(); // bad callsite!
  }
}
      </programlisting>
    </sect1>
    
    <sect1 id="extended-model2">
      <title>Extending the Model: Aggregating Arrays and Other
      Objects</title>
      
      <para>An array in Java is a separate object from the object whose
      field refers to the array. Protecting an array-typed field thus
      protects <emphasis>the reference to the array only</emphasis>. It
      is not sufficient to extend the protection to the elements of the
      array: we also need to know that the array object is accessible
      through that field only. If the array could be referenced by
      through other fields, then it would still be possible to access it
      concurrently because the locking model could be bypassed by
      accessing the array through a different field.</para>

      <para>Much of the time, however, it is not intended that an array
      is aliased; in these cases, the array can be incorporated into the
      state of the object that references it.  We call this
      <emphasis>aggregating state</emphasis>. An array is aggregated
      into the object that references it by adding a pair of annotations
      to the field that references the array:</para>
      
      <programlisting>
<emphasis>@Unique</emphasis>
<emphasis>@Aggregate("Instance into Instance")</emphasis>
private Object[] myArray;
      </programlisting>
      
      <para>This does two things:</para>

      <orderedlist>
        <listitem><para>Declares the programmer’s intent that the field
        is the only field that references the array object it
        references.  A separate analyses is used to assure that a
        <varname>@Unique</varname> field is never aliased.  A new
        expression always creates an unaliased object, so it is always
        safe to assign the results of a new expression to a
        <varname>@Unique</varname> field.</para></listitem>
      
        <listitem><para>Extends the state of the referencing object to
        include the elements of the array (recall that the
        <varname>Instance</varname> region is the
        non-<varname>static</varname> state of an object).  State
        aggregation is not automatically transitive; thus if the array
        elements are objects, those objects are not aggregated, only the
        references to them.</para></listitem>
      </orderedlist>
      
      <para>In the example below, the constructor
      <varname>Buffer(Object[])</varname> does not assure because it
      assigns an array to field buf that might be aliased, conflicting
      with the <varname>@Unique</varname> annotation on the field. The
      assignment to buf in the constructor
      <varname>Buffer(int)</varname> assures because it assigns a fresh
      array to the field.  The lock <varname>Lock</varname> does not
      need to be held to access the field <varname>buf</varname> because
      it is <varname>final</varname>. The implementation of
      <varname>copyContents()</varname> does not assure because even
      though <varname>Lock</varname> does not need to be held to access
      the field <varname>buf</varname> or the field
      <varname>length</varname>, <varname>Lock</varname> must be held to
      access the contents of the array referenced by
      <varname>buf</varname>.  Analysis knows that the method
      <varname>System.arraycopy()</varname> reads from the
      <varname>Instance</varname> region of its first parameter, and
      thus via aggregation, reads from the <varname>Instance</varname>
      region of the <varname>Buffer</varname> object.  (This analysis is
      informed by effects analysis and annotations, described in
      XXX.)</para>
      
      <programlisting>
<emphasis>@RegionLock("Lock is this protects Instance")</emphasis>
public class Buffer {
  <emphasis>@Unique</emphasis>
  <emphasis>@Aggregate("Instance into Instance")</emphasis>
  private final Object[] buf;
  &hellip;
  public Buffer(int size) {
    this.buf = new Object[size]; // good!
  }
  &hellip;
  public Buffer(Object[] newBuffer) {
    this.buf = newBuffer; // bad!
  }

  public Object[] copyContents() {
    final Object[] copy = new Object[this.buf.length];
    System.arraycopy(this.buf, 0, copy, 0, this.buf.length);
    return copy;
  }
}
      </programlisting>
      
      <para>Aggregation applies not only to arrays, but to objects in
      general.  So any object-typed field can be declared
      <varname>@Unique</varname> and can then have its state aggregated
      into the state of its referring object. </para>
    </sect1>
    
    <sect1 id="constructors">
      <title>Constructors</title>
      
      <para>Constructors cannot be declared
      <varname>synchronized</varname> in Java, but our assurance
      requires that fields protected by a lock be accessed only when
      that lock is held.  So how do we keep assurance from failing when
      analyzing a constructor?  We rely on the fact that during object
      construction, an object is almost always accessed by a single
      thread only: the thread that invoked the constructor. When this is
      the case, we can proceed as if the locks for the object’s state
      are already held. The programmer can declare this <emphasis>single
      threaded intent</emphasis> by annotating the constructor:</para>
      
      <programlisting>
<emphasis>@SingleThreaded</emphasis>
<emphasis>@Borrowed("this")</emphasis>
public C(&hellip;) { &hellip; }
      </programlisting>

      <para>One way that analysis can assure the single-threadedness of
      a constructor is to leverage the assurance that the constructor
      <emphasis>borrows</emphasis> the constructed object&mdash;that is,
      that it does not create an alias to it. (The
      <varname>@Borrowed</varname> annotation is further described
      below.) In particular, when analysis knows that the constructor
      does not create such an alias, it also knows that it is impossible
      for another thread to obtain a reference to the object under
      construction during the constructor’s execution.</para>
      
      <para>Annotating a constructor as being
      <varname>@SingleThreaded</varname> requires that the
      super-constructor it invokes is also
      <varname>@SingleThreaded</varname>.</para>

      <sect2 id="field-initialization">
        <title>Field Initialization and Implicit Constructors</title>
        
        <para>Field initializers are part of the object construction
        process, and fields that have initializers are considered to be
        written to.  Instance initializer blocks are also part of the
        object construction process and need to be assured accordingly. 
        This can be become problematic when a class does not have an
        explicit constructor:</para>
        
        <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  private int f = 1;
  private int g;
  
  {
    g = 2;
  }
  public synchronized int getF() {
    return f;
  }
  
  public synchronized void incG() {
    g += 1;
  }
}
        </programlisting>
        
        <para>Lock assurance will not assure the correct use of
        <varname>Lock</varname> because the accesses to fields
        <varname>f</varname> and <varname>g</varname> during
        construction are not protected.  One way to fix this is to make
        the constructor explicit and annotate it:</para>
        
        <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  &hellip;
  <emphasis>@SingleThreaded</emphasis>
  <emphasis>@Borrowed("this")</emphasis>
  public C() {}
  &hellip;
}
        </programlisting>
        
        <para>Alternatively, if it is undesirable to insert the
        constructor explicitly, the constructor can still be annotated
        using a <emphasis>scoped promise</emphasis>.  These are
        described in more detail below, but for the case of annotating
        an implicit constructor, we would annotate the class as follows:
        </para>
        
        <programlisting>
@RegionLock("Lock is this protects Instance")
<emphasis>@Promise({</emphasis>
  <emphasis>"'@SingleThreaded' for new()",</emphasis>
  <emphasis>"'@Borrowed this' for new()"})</emphasis>
public class C {
  &hellip;
}
        </programlisting>
      </sect2>
    </sect1>
    
    <sect1 id="self-protected-objects">
      <title>Self-Protected Objects</title>
      
      <para>Region aggregation, described above, is one technique that
      can be used to deal with the fact that fields
      <emphasis>reference</emphasis> objects.  But it is not always
      possible to use region aggregation to simplify reasoning about
      protected state because a field may be aliased.  In such cases,
      the tool may produce warnings that a reference of the form
      <varname>e.f.g</varname>, where <varname>f</varname> is field
      protected by a lock, is a “possibly unsafe reference to protected
      shared state.”  The message is meant to remind the programmer that
      although the field <varname>f</varname> is protected by a lock,
      this lock does not also protect the field <varname>g</varname> of
      the referenced object.  (If field <varname>f</varname> is of class
      <varname>C</varname> and class <varname>C</varname> declares that
      <varname>g</varname> is protected by a lock then this warning is
      not produced: the tool instead attempts to assure that the
      appropriate lock for <varname>g</varname> is held.)  There are
      situations where invoking a method via <varname>e.f.m()</varname>
      will also produce a the above warning.</para>
      
      <para>Region aggregation and lock declaration (as described above)
      can be used to suppress these warnings.  In general, we can
      suppress this warning for a field <varname>f</varname> that
      referneces objects of class <varname>C</varname> by annotating
      class <varname>C</varname> with <varname>@SelfProtected</varname>.
       This <emphasis>unchecked</emphasis> annotation declares that
      instances of the class/interface are meant to be “thread safe.” 
      Exactly what is meant by this is presently unspecified; the
      annotation is intended to encompass non&ndash;lock-based
      protections schemes such as single-threadedness and
      immutability.</para>
      
      <important>
        <para>No analysis is performed on classes declared to be
        self-protected to assure that the implementation is thread
        safe.</para>
      </important>
      
      <para>As an example, let's consider the simple rational numbers
      class below.</para>

      <programlisting>
public class Rational {
  private final int numerator;
  private final int denominator;

  public Rational(int n, int d) { 
    numerator = n; 
    denominator = d; 
  }

  public int getNumerator() { return n; }
  public int getDenominator() { return d; } 
}
      </programlisting>
      
      <para>Suppose we have a client class that has a lock-protected
      reference to a <varname>Rational</varname> object:</para>
      
      <programlisting>
@RegionLock("Lock is this protects Intance")
public class C {
  &hellip;
  private Rational r;

  public synchronized doStuff() {
    int n = r.getNumerator();  // (*)
    &hellip;
  }
}
      </programlisting>
      
      <para> JSure is going to generate a warning attached to call
      <varname>r.getNumerator()</varname> that “Receiver r may be a
      shared unprotected object.”  That is, we may be doing something
      unsafe: accessing the state of the rational object in multiple
      threads without protection.  But in this case, we know that
      <varname>Rational</varname> objects are immutable, and thus thread
      safe, so we can suppress this warning by annotating the
      <varname>Rational</varname> class:</para>
      
      <programlisting>
<emphasis>@SelfProtected</emphasis>
public class Rational {
  &hellip;
}
      </programlisting>
    </sect1>
  </chapter>
  
  <chapter id="advanced-locks">
    <title>Advanced Lock Models</title>
    
    <sect1 id="regions-and-locks">
      <title>Regions and Locks</title>
      
      <para>The lock annotation <varname>@RegionLock</varname> actually
      associates a lock with a region.  A <emphasis>region</emphasis> is
      a named, hierarchical abstraction of state.  All fields are
      regions, and thus a region is a named, extensible set of fields. 
      Using annotations, the programmer can declare new abstract regions
      as members of a class, and then associate different locks with
      different regions.  The state of an object may thus be partitioned
      into multiple abstract regions, each protected by a different
      lock, enabling concurrent access to different segments of the
      object’s state.</para>

      <sect2 id="declaring-regions">
        <title>Declaring New Regions</title>
        
        <para>New regions are declared by annotating a class with</para>
        
        <programlisting>
@Region("<replaceable>visibility</replaceable> <replaceable>Region</replaceable> extends <replaceable>Parent</replaceable>")
        </programlisting>
        
        <para>which declares a new region
        <replaceable>Region</replaceable> which is a subregion of
        <replaceable>Parent</replaceable>.  A region may be declared to
        be <varname>static</varname>, and may have any of the standard
        Java visibility modifiers (or none).  A
        <varname>static</varname> region must extend another
        <varname>static</varname> region; non-<varname>static</varname>
        regions may extend <varname>static</varname> regions.  If no
        parent region is specified, <varname>Instance</varname> is used
        for non-<varname>static</varname> regions; the root
        region&mdash;the <varname>static</varname> region
        <varname>All</varname>&mdash;is used for
        <varname>static</varname> regions.  Java only allows a single
        annotation of each type to be used at time, so to declare more
        than one region on a class, the <varname>@Regions</varname>
        annotation is used:</para>
        
        <programlisting>
<emphasis>@Regions</emphasis>({
  @Region("region1"), // region with default visibility, extends Instance
  @Region("private static region2"), // static private region, extends All
  @Region("public region3 extends region2") // public instance region
})
        </programlisting>
        
        <para>Unless otherwise specified, a <varname>static</varname>
        field is in the region <varname>All</varname>, and a
        non-<varname>static</varname> field is in the region
        <varname>Instance</varname>.  To place a field in a
        user-declared region, the <varname>@InRegion</varname> annotation
        is used:</para>
        
        <programlisting>
@Region("protected NewRegion")
public class C {
  <emphasis>@InRegion("NewRegion")</emphasis>
  private int f;
  &hellip;
}
        </programlisting>
        
        <para>As with abstract regions, a <varname>static</varname>
        field may only be placed into a <varname>static</varname>
        region.  Non-<varname>static</varname> fields may be placed into
        either <varname>static</varname> or
        non-<varname>static</varname> regions.</para>

      </sect2>
      
      <sect2 id="locks-with-regions">
        <title>Associating Locks with Regions</title>
        
        <para>The general form of the <varname>@RegionLock</varname> annotation is</para>
        
        <programlisting>
@RegionLock("<replaceable>LockName</replaceable> is <replaceable>Lock</replaceable> protects <replaceable>Region</replaceable>")
        </programlisting>
        
        <para>where <replaceable>LockName</replaceable> is a programmer-declared name for the lock, <replaceable>Lock</replaceable> is a reference to the lock object, and <replaceable>Region</replaceable> is the name of a region.  More specifically, <replaceable>Lock</replaceable> must be one of the following:</para>

        <variablelist>
          <varlistentry>
            <term><varname>this</varname></term>
            
            <listitem><para>The object itself is acquired to protect the state.</para></listitem>
          </varlistentry>
          
          <varlistentry>
            <term>A field declared in the class being annotated or an ancestor of the class being annotated that is visible within the class, for example, a protected field from an ancestor.</term>
            
            <listitem><para>The field must refer to an object.  The field must be <varname>final</varname>: otherwise the lock object referenced by the field could change.  The field may be <varname>static</varname> or instance.</para></listitem>
          </varlistentry>
          
          <varlistentry>
            <term><varname>class</varname></term>
            
            <listitem><para>The unique <varname>Class</varname> object referenced by the <varname>static</varname> pseudo-field <varname>class</varname>.  (This is the object that is locked by <varname>static synchronized</varname> methods.)</para></listitem>
          </varlistentry>
            
          <varlistentry>
            <term>A field of an outer class.</term>
            
            <listitem><para>If a class is declared inside class <varname>Outer</varname>, and wants to declare that the field <varname>f</varname> of the <varname>Outer</varname> instance that is the container for the inner class's instance protects a region of the inner class, then the lock reference is given by <varname>Outer.this.f</varname>.</para>
            
            <para>Although the tool supports declaring locks that are the fields of outer classes, it is not presently possible to assure their correct use.  This is because of deficiencies in both our internal representation and with Java syntax.  Given a variable <varname>v</varname> that refers to an instance of a non-<varname>static</varname> inner class, there is no syntactic expression that evaluates to the “outer” object of that instance, that is, the object referenced by <varname>o</varname> in the expression <varname>o.new Inner()</varname>.</para>
            
            <para>We allow the declaration of such locks, even though they cannot be assured, because we have encountered them in real code and it is nice to be able to document the design intent.</para></listitem>
          </varlistentry>
        </variablelist>
        
        <para>A region may only be associated with a lock declared in a class <varname>C</varname> if the region doesn't contain any fields from superclasses of <varname>C</varname>.  This is trivially true if the region is declared in <varname>C</varname>.  The region may have abstract sub-regions, but they also cannot contain any fields.  Specifically, the region (and any of its subregions) cannot contain any fields, when considered from the point of view of the class in which the lock declaration appears.  (Indeed, otherwise you could never associate a lock with a region.)  This restriction exists to prevent unsoundness.  Suppose class <varname>C</varname> declares a region <varname>R</varname> and populates it with field <varname>f</varname>.  Suppose <varname>D</varname> extends <varname>C</varname>, adds field <varname>g</varname> to region <varname>R</varname>, and also associates <varname>R</varname> with a lock.  The problem is, in contexts where a <varname>D</varname> object is viewed as a <varname>C</varname>, such as when a <varname>D</varname> object is passed a method with a <varname>C</varname> parameter, analysis cannot enforce <varname>D</varname>'s locking policy.  Thus, fields in <varname>R</varname> that should be protected might not be, and analysis would not complain.</para>
          
        <para>We allow the protection of an empty region to be delayed because no state can be accessed through that region by “unprotected” superclasses.  Any actual code that accesses state in that region must access the region through a subclass that does know about the protection, and therefore analysis can enforce the protection.</para>
          
        <para>A <varname>static</varname> region must be protected by a <varname>static</varname> field or by <varname>class</varname>.</para>

        <para>A region may be associated with a lock only if none of its ancestors are associated with a lock.  This prevents a region from being protected by multiple locks.</para>
      </sect2>
      
      <sect2 id="multiple-locks">
        <title>Declaring Multiple Locks</title>
        
        <para>Multiple locks are declared as members of a class my using the <varname>@RegionLocks</varname> annotation:</para>
        
        <programlisting>
@Regions({
  @Region("public Location"),
  @Region("public Appearance")
})
<emphasis>@RegionLocks({</emphasis>
  <emphasis>@RegionLock("LocationLock is this protects Location"),</emphasis>
  <emphasis>@RegionLock("AppearanceLock is appLock protects Appearance")</emphasis>
<emphasis>})</emphasis>
public class Sprite {
  protected static Object appLock = new Object();
  &hellip;
}
        </programlisting>
      </sect2>
    </sect1>
    
    <sect1 id="returning-locks">
      <title>Returning Locks</title>
      
      <para>A method may be declared to return a particular lock using the <varname>@ReturnsLock</varname> annotation.  This allows an implementation to provide access to a lock object without revealing how that lock is “implemented.”  That is, the identity of the field that refers to the lock is kept hidden by the implementation, although the lock object is made accessible to clients.  The <varname>@ReturnsLock</varname> annotation is fully checked: it is checked that the method actually returns the object representing the lock it says it returns.  The following code fragment shows an example use of the <varname>@ReturnsLock</varname> annotation.</para>
      
      <programlisting>
@RegionLock("DataLock is lock protects DataRegion")
@Region("protected DataRegion")
public class C {
  // NOTE: field is private
  private final Object lock = new Object();

  <emphasis>@ReturnsLock("DataLock")</emphasis>
  protected Object getDataLock() {
    return lock;
  }
  &hellip;
  public void doSomething() {
    synchronized (<emphasis>getDataLock()</emphasis>) {
      // Access DataRegion
    }
  }
}
      </programlisting>

      <para>An example of this sort of thing in production code is the method <varname>getTreeLock()</varname> in the JDK class <varname>java.awt.Container</varname>.</para>
    </sect1>
    
    <sect1 id="policy-locks">
      <title>Policy Locks</title>
      
        <para>Sometimes there is no obvious state to associate with a lock.  That is, a lock is being used to enforce a higher-level invariant that requires a section of code to execute atomically with respect to some other section of code.  We call locks used for such a purpose <emphasis>policy locks</emphasis>.  They can be declared using the class annotation</para>
        
        <programlisting>
@PolicyLock("LockName is Lock")
        </programlisting>
        
        <para>This annotation is basically the same as the <varname>@RegionLock</varname> annotation except that it does not associate the lock with any particular region of state.  The tool does not provide any assurance about the uses of policy locks.  The annotation is primarily used to document the intent behind the lock, and to suppress tool warnings about a particular lock object being an unknown lock.</para>
        
        <para>One common use for policy locks is to enforce an “initalize once” invariant.  Consider this example from <varname>java.util.logging.Logger</varname>:</para>
        
        <programlisting>
<emphasis>@PolicyLock("InitLock is class")</emphasis>
public class Logger {
  &hellip;
  public static synchronized Logger getLogger(String name) { 
    LogManager manager = LogManager.getLogManager(); 
    Logger result = manager.getLogger(name);
   if (result == null) {
     result = new Logger(name, null); 
      manager.addLogger(result);
     result = manager.getLogger(name); 
    }
   return result;
  }
}
      </programlisting>
      
      <para>First, note the <varname>static</varname> method does not change any state directly; it is difficult so say what state the lock <varname>Logger.class</varname> is protecting.  This is because the lock is ensuring that the method <varname>getLogger</varname> executes atomically with respect to itself.  If two threads were allowed to simultaneously execute the method it would be possible to create two new <varname>Logger</varname> objects with the same name, but only one of them would be registered in the global log registry.  This would cause problems later on during the use of the loggers.  The synchronization ensures that only one <varname>Logger</varname> object is ever created for any given name.</para>
    </sect1>
  </chapter>
</book>
