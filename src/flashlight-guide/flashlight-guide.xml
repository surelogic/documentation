<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<book id="flashlight-guide" lang="en-US">
  <title>Flashlight User Guide</title>
  <subtitle>How to use and configure the Flashlight Eclipse client</subtitle>
  <bookinfo>
    <copyright>
      <year>2009</year>
      <holder>SureLogic Inc.</holder>
    </copyright>
    <legalnotice>
      <para>The authors and publishers have taken care in the
      preparation of this documentation, but make no expressed or
      implied warranty of any kind and assume no responsibility for
      errors and omissions. No liability is assumed for incidental or
      consequential damages in connection with or arising out of the use
      of the information or programs herein.</para>
    </legalnotice>
    <pubdate>Version 2.1.1&mdash;March 2009</pubdate>
  </bookinfo>

  <preface id="preface">
    <title>Preface</title>
    
    <sect1>
      <title>Audience</title>
      
      <para>This document is intended for Java developers who want to
      use the Flashlight tool within the Eclipse Java IDE. We assume
      that the reader understands both the Java programming language and
      the use of Eclipse for Java development.</para>
    </sect1>
    
    <sect1>
      <title>Contact information</title>
      
      <para>For technical support or other questions, please
      contact:</para>
      
      <para><email>support@surelogic.com</email></para>
      
      <para>5808 Forbes Avenue, Pittsburgh, PA 15217-1602</para>
    </sect1>
  </preface>

  <chapter id="getting-started">
    <title>Getting started</title>
    
    <sect1>
      <title>Introduction</title>

      <para><emphasis>What is Flashlight?</emphasis> Flashlight is a
      dynamic analysis tool that helps you to understand the concurrency
      within your Java software. It is similar to a profiler in the
      sense that it collects data from a program execution and presents
      information about that run to the tool user. Flashlight casts
      light on issues related to performance, concurrency, and code
      safety. The Flashlight dynamic analysis tool is designed so that
      even one run can reveal information regarding a relatively much
      larger universe of runs, and thus enable developers to address
      potential issues earlier. The tool is also designed to afford
      developers and evaluators a visibility that enables them to
      develop models to support a "more complete" analysis by a sound
      static analysis tool like SureLogic's JSure.</para>

      <para>At a more technical level, Flashlight is designed to scale
      to very large amounts of collected instrumentation data. It
      accomplishes this through a unique pipeline/buffering approach
      that rapidly moves data out of the instrumented program's process
      heap and into secondary storage. It is designed to interact
      cleanly with garbage collection and object finalization.</para>

      <para>Flashlight use imposes an overhead cost, in terms of time
      and memory, on your program. Flashlight is a much more invasive
      analysis than a typical Java profiler. Roughly, an instrumented
      program will require two to three times the memory it normally
      uses and will run from 20 times to 80 times slower than it
      normally runs.  A dual- or quad-core CPU is recommend to reduce
      the overhead Flashlight imposes on the instrumented program
      because Flashlight is able to take advantage of the available
      hardware. Flashlight uses a large amount of disk space to store
      the data it collects, thus 50 to 100 Gigabytes of free disk space
      is recommended.</para>

      <para>Flashlight has a highly effective query capability, wherein
      the database of program run data is queried using a hierarchy of
      queries that enable the results of one query to be used as a basis
      for "drill in" using sub-queries.</para>
    </sect1>

    <sect1>
      <title>Quick start: How to instrument your code and query
      Flashlight</title>

      <para>This section assumes that you have installed Flashlight. If
      you see a <guimenu>Flashlight</guimenu> menu item on your Eclipse
      main menu then you can assume Flashlight has been properly
      installed.</para>

      <para>You need to install a license to use Flashlight.  If you do
      not have a license file visit <ulink
      url="http://www.surelogic.com">http://www.surelogic.com</ulink> to
      obtain one.  To install the license select <guimenuitem>Manage
      SureLogic Licenses</guimenuitem> from the
      <guimenu>Flashlight</guimenu> menu as shown in <xref
      linkend="fig-quick-start-license-menu" />.</para>

      <figure id="fig-quick-start-license-menu">
        <title>The menu option to install a license for Flashlight</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/quick-start-license-menu.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para> This will cause the <guilabel>Manage SureLogic
      Licenses</guilabel> to appear as shown in <xref
      linkend="fig-quick-start-license-dialog-empty" />. Highlight the
      Flashlight row and select the <guibutton>Install
      License</guibutton> button to install your license file.</para>

      <figure id="fig-quick-start-license-dialog-empty">
        <title>The SureLogic license management dialog</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/quick-start-license-dialog-empty.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Flashlight will not disrupt your Eclipse installation if a
      license for it is not installed, however, it will not allow you to
      use Flashlight functionality.  We will assume from this point on
      that you have installed your license.</para>

      <para>Flashlight is a dynamic analysis tool which means that you
      have to run your program to use it.  Flashlight instruments your
      program when it starts up and uses that instrumentation to collect
      data about your program.  By default, data is collected into the
      directory <filename>~/.flashlight-data</filename>.</para>
    </sect1>

    <sect1>
      <title>Tutorials</title>

      <para>This section contains a series of Flashlight tutorials.  It
      is recommended that you go through these tutorials in order.  It
      is also recommended that these tutorials be performed "hands-on"
      at your computer. You might want to create a new Eclipse workspace
      to use for these tutorials. In addition, if you run into any
      difficulties as you step through the tutorials please consider
      sending us a tip for improvement as described in <xref
      linkend="sec-bugs-and-tips"/>.</para>

      <sect2 id="sec-tutorial-client">
        <title>Using the Flashlight Eclipse client on PlanetBaron</title>

        <para>This tutorial assumes that you have installed Flashlight.
        If you see a <guimenu>Flashlight</guimenu> menu item on your
        Eclipse main menu than you can assume it has been installed
        properly.</para>

        <para>First download the <application>PlanetBaron</application>
        project from www.surelogic.com at <ulink
        url="http://www.surelogic.com/static/flashlight/PlanetBaron.zip">
        http://www.surelogic.com/static/flashlight/PlanetBaron.zip</ulink>
        to your disk. Unzip this archive into your workspace and
        it will create a <filename>PlanetBaron</filename> directory.
        Next import this project into your Eclipse workspace using
        <menuchoice><guimenu>File</guimenu> <guimenuitem>Import&hellip;</guimenuitem></menuchoice>
        from the Eclipse main menu
        and then choosing <guilabel>Existing Projects into
        Workspace</guilabel> for the import wizard. Follow the import
        steps of wizard until the <application>PlanetBaron</application>
        project is imported and built.</para>

        <para>PlanetBaron is a network-based real-time strategy game. It
        contains three programs that we will run during this tutorial.
        The first is a server program that manages the distributed game
        state. The second is a graphical program that allows a player to
        interact with the game. The third program, called the chat-test
        client, allows direct interaction with the server for the
        purpose of debugging and management. For example, the chat-test
        client is used to shutdown a server.</para>

        <para>Flashlight is a dynamic analysis tool. To get any useful
        results from Flashlight we have to collect data while a program
        is running. We will start below by describing how to run and
        play a PlanetBaron game. After we understand a bit about how to
        run the game we will return to using Flashlight on it.</para>

        <para>Let's run a PlanetBaron game. Select
        <filename>Server.java</filename> in the
        <package>edu.afit.planetbaron.server</package> package.
        Right-click and select <menuchoice><guisubmenu>Run As</guisubmenu> 
        <guimenuitem>Java Application</guimenuitem></menuchoice>. You should see
        following output in the console which indicates that the server
        has started successfully:</para>

        <screen>
[INFO "server-main"] PlanetBaron game server listening for clients on port 8693 and playing on a 15x15 map
        </screen>

        <para>Now we need to add some players. Select
        <filename>PlayerUI.java</filename> in the
        <package>edu.afit.planetbaron.client</package> package.
        Right-click and select <menuchoice><guisubmenu>Run As</guisubmenu> 
        <guimenuitem>Java Application</guimenuitem></menuchoice>. You will see a
        Window appear has a blank grid and the title
        <application>PlanetBaron</application>. In the lower
        right-hand-corner enter a player name,
        <userinput>Laurel</userinput>, and press
        <guibutton>Connect</guibutton>.</para>

        <para>The screen will change to contain several planets and one
        ship with "Laurel" as its label. By moving your mouse around the
        grid you can direct your ship. Place your mouse over a planet
        and left-click. This action will cause your ship to move slowly
        to that planet. When your ship arrives you will become the owner
        of that planet. This is called "taking ownership" of a planet.
        Go ahead an take ownership of a few planets. Note that while
        your ship is moving you are not allowed to change its
        destination.  Once it arrives at the destination you selected
        you can then select a subsequent destination.</para>

        <para>If you look at the console for the server you will see the
        commands that have come in from the Laurel PlayerUI. For
        example, your server console might look similar to the
        below:</para>

        <screen>
[INFO "server-main"] PlanetBaron game server listening for clients on port 8693 and playing on a 15x15 map [edu.afit.planetbaron.server.Server.startListening()]
[INFO "server-ch10"] client handler thread started [edu.afit.planetbaron.server.ClientHandler.run()]
[INFO "server-ch10 (Laurel)"] "play "Laurel"" processed GameStateUpdate from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
[INFO "server-ch10 (Laurel)"] "moveship "Laurel" to (12,11)" processed Ok from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
[INFO "server-ch10 (Laurel)"] "moveship "Laurel" to (9,13)" processed Ok from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
[INFO "server-ch10 (Laurel)"] "moveship "Laurel" to (8,10)" processed Ok from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
        </screen>

        <para>Now, go back to Eclipse and start a second instance of
        <filename>PlayerUI.java</filename>. In the lower
        right-hand-corner enter a player name,
        <userinput>Hardy</userinput>, and press
        <guibutton>Connect</guibutton>.</para>

        <para>The game supports as many players as you choose to connect
        to the server. Notice that the planets that Laurel owns are red
        in the Hardy PlayerUI while they are white in the Laurel
        PlayerUI.  Moving back and forth between the two PlayerUIs move
        the ships to play the game.  Note that the idea of the game is
        to own as many planets as you can. A game screenshot is shown in
        <xref linkend="fig-tutorial-planetbaron-playerui" />.</para>

        <figure id="fig-tutorial-planetbaron-playerui">
          <title>The PlanetBaron PlayerUI for Laurel</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-playerui.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>To finish the game press <guibutton>Disconnect</guibutton>
        in both PlayerUI instances and then terminate the programs by
        closing the application windows as usual. This action
        ends both player user interfaces but the server is still
        running.  To terminate the server we need to use the chat-test
        client program. Select <filename>ChatTestClient.java</filename>
        in the <package>edu.afit.planetbaron.client</package> package.
        Right-click and select <menuchoice><guisubmenu>Run As</guisubmenu> 
        <guimenuitem>Java Application</guimenuitem></menuchoice>. You will see a
        window appear with the title <application>ChatTest -
        PlanetBaron</application>. This program allows you to directly
        control the game server via text commands. We want to use it to
        shutdown the game server. To do this press
        <guibutton>Connect</guibutton> to connect to the game server and
        enter <userinput>shutdown</userinput> as the command. You're
        screen should now look like the one shown in <xref
        linkend="fig-tutorial-planetbaron-chattestclient" />.</para>

        <figure id="fig-tutorial-planetbaron-chattestclient">
          <title>Using the ChatTestClient to shutdown the game server</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-chattestclient.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Press <guibutton>Send</guibutton> to shutdown the server.
        A dialog will appear stating that the server has disconnected
        from the ChatTestClient that you may dismiss. You can now
        terminate the ChatTestClient by closing the application window.
        Back in the Eclipse console for the
        server you should see the following message at the
        bottom:</para>

        <screen>
[INFO "server-main"] PlanetBaron game server shutdown complete
        </screen>

        <para>We are now ready to use Flashlight to help us understand
        the concurrency in the PlanetBaron game. Let's start with the
        ChatTestClient. To run the ChatTestClient with Flashlight
        instrumentation we select it from the Flashlight launch tab in
        the Eclipse toolbar as shown in <xref
        linkend="fig-tutorial-planetbaron-running-chattestclient"
        />.</para>

        <figure id="fig-tutorial-planetbaron-running-chattestclient">
          <title>Running ChatTestClient with Flashlight instrumentation</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-running-chattestclient.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The ChatTestClient window will appear on your screen.
        Select the <guibutton>Connect</guibutton> to try an connect to a
        game server. This will fail and the application will show a
        dialog to you which you may dismiss. The reason it fails is that
        we did not start a game server. At this point we have exercised
        the ChatTestClient enough to see some Flashlight results. Go
        ahead and close the application window to
        terminate the program. At this point Eclipse, which knows that
        this launch was instrumented, will prompt you to switch to the
        Flashlight perspective as shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-switch-dialog"
        />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-switch-dialog">
          <title>Prompting the user to switch to the Flashlight perspective</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-switch-dialog.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Press <guibutton>Yes</guibutton> and the Flashlight
        perspective will appear as shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-empty" />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-empty">
          <title>The Flashlight perspective</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-empty.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The Flashlight perspective is used to manage and query
        data collected from instrumented programs. The
        <guilabel>Flashlight Runs</guilabel> view in the upper-left
        manages the instrumented runs of programs. This view allows you
        to prepare data to be queried, select a prepared run for
        querying, and delete runs from the disk.  We need to prepare, or
        <emphasis>prep</emphasis>, the ChatTestClient run. To do this
        double-click the row in the table.  Alternatively you can select
        the run, right-click, and select
        <guimenuitem>Prepare</guimenuitem> from the context menu.</para>

        <para>A dialog will appear showing the progress of prepping the
        data for querying. For large runs prepping can take a
        significant amount of time. This run, which only collected
        roughly 5 KB of data, should prep quickly taking up a total of
        roughly 4 MB of disk space.</para>

        <para>When the prep is complete two changes will occur. First, a
        <guiicon><inlinegraphic fileref="images/drum.png" /></guiicon>
        will appear in the <guilabel>Prep</guilabel> column of the
        <guilabel>Flashlight Runs</guilabel> view table for this run.
        Second, several queries are now able to be run on the data.
        These queries are listed in the <guilabel>Query Menu</guilabel>
        view directly below the <guilabel>Flashlight Runs</guilabel>
        view.</para>

        <para>At this point we can run a query on the data. Double-click
        on the <emphasis>What fields (non-static) are shared?</emphasis>
        query. The results will appear in the <guilabel>Query
        Results</guilabel> view. Select the
        <structfield>f_connectDisconnectButton</structfield> field name and
        open the tree to display the two threads that shared this
        object. Your screen should appear as shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-ctc1" />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-ctc1">
          <title>Non-static fields that were observed to be shared in a ChatTestClient run</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-ctc1.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Query results are presented as a table, tree, or
        tree-table. This result is a tree-table. The result reports the
        shared non-static fields noted in the run. In the case of
        f_connectDisconnectButton the AWT-EventQueue-0, known as the
        event dispatch thread (EDT), and the main thread shared this
        field. Note that all the accesses by the main thread where
        during construction of the ChatTestClient. If you examine the
        other results you will note that all the shared objects are
        Swing components and that they are shared, but similar to
        f_connectDisconnectButton they are only accessed by the main
        thread during construction.</para>

        <para>Selecting fields in the query result causes these fields
        to be highlighted in two views at the bottom of the Flashlight
        perspective. The view to the left is the normal Java editor and
        represents the current state of the source code. The view to the
        left is an <guilabel>Historical Source Snapshot</guilabel> view
        that shows you the code as it existed when the program was
        executed.  This view helps you to understand if the code has
        evolved since the run you are querying was made.</para>

        <para>Select the f_connectDisconnectButton and right-click. This
        brings up a menu of queries that can be run on this result.
        Select <emphasis>Show me all accesses of this non-static
        field?</emphasis> as shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-ctc2" />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-ctc2">
          <title>Drilling in to all accesses of the f_connectDisconnectButton</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-ctc2.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The result of this query will show you each read and write
        of the field that was observed by the instrumentation as the
        program executed. It shows the time at which the event occurred
        and the thread it happened within. Select the second access by
        the main thread and right-click. Drill-in again by selecting
        <emphasis>Show stack trace for a field access</emphasis> as
        shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-ctc3" />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-ctc3">
          <title>Drilling in to see the stack trace for this field access</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-ctc3.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Which will result in a stack trace for the selected
        access. Selecting each row of the result will show that line of
        code in the program.  The bottom row is, in fact, a bug in the
        program. This line is shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-ctc3" />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-ctc4">
          <title>The broken line of code in ChatTestClient</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-ctc4.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>What is wrong? To understand this problem we quote from
        Haase and Guy's <citetitle pubwork="book">Filthy Rich
        Clients</citetitle><biblioref linkend="HaaseGuy07"/>:</para>

        <blockquote><para>Swing's threading model is based on a single
        rule: The EDT is responsible for executing any method that
        modifies a component's state. This includes any component's
        constructor. According to this rule, and despite what you can
        read in many books and tutorials about Swing. the
        <function>main()</function> method in the previous code example is
        invalid and can cause deadlock.</para></blockquote>

        <para>To fix this problem we need to call the ChatTestClient
        constructor on the EDT. We can do this by changing the
        <function>main()</function> method to look like the code
        below.</para>

        <programlisting>
<![CDATA[
public static void main(String[] args) {
  // run the application
  SwingUtilities.invokeLater(new Runnable() {
    @Override
    public void run() {
      new ChatTestClient();
    }
  });
}
]]>
        </programlisting>

        <para>Save this change and launch ChatTestClient using the
        Flashlight launch shortcut again. Perform the same actions that
        you did during the first run (i.e., try to connect, dismiss the
        dialog, and exit).</para>

        <para>A new run will appear in the <guilabel>Flashlight
        Runs</guilabel> view. Double-click this run to prep it.</para>

        <para>Clear out the previous query results by clicking the
        <guiicon><inlinegraphic fileref="images/gray_x_double.png"
        /></guiicon> in either the <guilabel>Result Explorer</guilabel>
        portion of the <guilabel>Query Flashlight</guilabel> view or the
        <guilabel>Flashlight Query Results</guilabel> view. This action
        clears out the saved results from all previous queries (the set
        of these results is saved in the <guilabel>Result
        Explorer</guilabel> portion of the <guilabel>Query
        Flashlight</guilabel> view).</para>

        <para>Check that you have the new run selected in the
        <guilabel>Flashlight Runs</guilabel> view and then double-click
        on the <emphasis>What non-static fields are shared?</emphasis>
        query. The query is successful but no rows are returned. This
        indicates that no shared fields were observed. This run provides
        some evidence that we have fixed the bug discovered in
        ChatTestClient.</para>

        <para>Before we move on let's examine the old run one final
        time. Clear out the previous query results by again clicking the
        <guiicon><inlinegraphic fileref="images/gray_x_double.png"
        /></guiicon> icon. Select the first ChatTestClient run and
        double-click the <emphasis>What non-static fields are
        shared?</emphasis> query. Select the f_connectDisconnectButton
        and right-click to select the <emphasis>Show me all accesses of
        this non-static field?</emphasis> query. Select the second
        access by the main thread and right-click to select the
        <emphasis>Show stack trace for a field access</emphasis> query.
        By selecting the bottom row of the stack trace you can see that,
        while the Java editor code might prove confusing (because we
        changed it), the <guilabel>Historical Source Snapshot</guilabel>
        view remembers what the code looked like in this previous run. 
        This difference is shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-ctc5" />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-ctc5">
          <title>The broken line of code in ChatTestClient is remembered by the Historical Source Snapshot view</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-ctc5.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>We are finished with our examination of these runs, so
        let's delete them. First, clear out all the queries by pressing
        the <guiicon><inlinegraphic fileref="images/gray_x_double.png"
        /></guiicon> icon. In the <guilabel>Flashlight Runs</guilabel>
        view select both runs and right-click. Select
        <guimenuitem>Delete</guimenuitem> from the context menu as shown in <xref
        linkend="fig-tutorial-planetbaron-perspective-ctc6" />.</para>

        <figure id="fig-tutorial-planetbaron-perspective-ctc6">
          <title>Deleting two Flashlight runs</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-perspective-ctc6.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>You will be prompted once per run to ensure that you
        really want to delete this Flashlight run data. In both cases
        check the <guilabel>Delete raw data files from the
        disk</guilabel> option and press <guibutton>OK</guibutton>.
        After a short delay the <guilabel>Flashlight Runs</guilabel>
        view should be empty. It is important to delete old runs to
        ensure that you free up disk space on your computer.</para>

        <para>ChatTestClient was a simple Swing application that we
        tried out one query on. This query let us understand shared
        state that was observed by Flashlight during a run of the
        ChatTestClient program. Even this simple query uncovered a bug
        that could easily be overlooked in a code inspection. We now
        turn our attention to a more complex multi-threaded program, the
        PlanetBaron server, to illustrate several more complex queries
        Flashlight is capable of. The basic user interaction with the
        Flashlight tool will remain the same: run a instrumented
        program, prep the data, query the data, drill into query
        results, and act (e.g., change/fix code).</para>

        <para>Start a server using the Flashlight launch tab the Eclipse
        toolbar as shown in <xref
        linkend="fig-tutorial-planetbaron-running-server" />.</para>

        <figure id="fig-tutorial-planetbaron-running-server">
          <title>Running Server with Flashlight instrumentation</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-running-server.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Next start three PlayerUI instances. We don't want to
        instrument these programs, so use the normal launch tab as shown
        in <xref linkend="fig-tutorial-planetbaron-running-playerui"
        />.</para>

        <figure id="fig-tutorial-planetbaron-running-playerui">
          <title>Running a PlayerUI without Flashlight instrumentation</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-running-playerui.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>Go ahead and connect into the game as Laurel, Hardy, and
        Groucho. Exercise the game by having each player take several
        planets. Have one planet be owned by each player at one time. To
        do this click on the same planet in all three PlayerUI
        instances. This is shown in <xref
        linkend="fig-tutorial-planetbaron-running-game" />.</para>

        <figure id="fig-tutorial-planetbaron-running-game">
          <title>Running three players at once on an instrumented server</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-planetbaron-running-game.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>When you have exercised the three players, terminate the
        thee PlayerUI instances by closing the application windows.
        Run a ChatTestClient (without
        instrumentation) and use it to shutdown the server.</para>

        <para>In the Flashlight perspective go ahead and prep the server
        run so that it can be queried. This will take a few minutes to
        complete.</para>

        <para>The queries we do on the server results may or may not be
        similar to what you see at your computer. The program we are
        examining is a multi-threaded network-based game server.
        Therefore, it is impossible to duplicate a run&mdash;even for
        tutorial purposes. You should, however, see similar results to
        what we present and you are encouraged to see what you can find
        in your run results.</para>

        <para>TODO: Run the <emphasis>What non-static fields have a
        lockset?</emphasis> query. A lockset analysis examines each
        access of an object that was observed in the program and
        intersects the set of locks held. If shared state has a lockset
        it is a good thing&mdash;this state was observed to be protected
        consistently by at least one lock. Note that this state may not
        always be protected in all possible runs of the program (to make
        this determination a sound verification tool like SureLogic
        JSure is required), but it was for the particular run of the
        program observed.  If shared state has no lockset then this may
        be a bad thing&mdash;it might mean that your program contains a
        race condition.</para>

        <para>Drill into <emphasis>Show me all accesses of this
        non-static field</emphasis> and introduce the idea of a "lock
        trace".</para>

        <para>TODO: Run the <emphasis>What non-static fields have an
        empty lockset?</emphasis> query. The
        <structfield>f_location</structfield> field of the
        <classname>Ship</classname> class will likely show up. This is an
        actual problem in the program. Drill in on an instance and run
        the <emphasis>* What locks are held for each access of this
        non-static field *</emphasis> which will take a long time.
        Examine the lock trace of the first access to see that it is a
        ReadWriteLock being used to protect this field. Now look for a
        result that is holding only one lock (on the ClientHandler
        object). The stack trace will lead you to an unprotected access.
        This is locking on the wrong lock (This same problem was also
        discovered with the JSure tool).</para>

        <para>TODO: run the <emphasis>Where does a thread hold a lock
        and acquire another?</emphasis> and examine the results to show
        potential deadlock.</para>

        <para>TODO: Show the query editor. None of these queries are
        special and they can be edited. Select
        <menuchoice><guimenu>Window</guimenu> <guisubmenu>Show
        View</guisubmenu> <guimenuitem>Flashlight Query
        Editor</guimenuitem></menuchoice> from the Eclipse main menu to
        open the <guilabel>Flashlight Query Editor</guilabel> view. This
        view is shown in <xref linkend="fig-tutorial-query-editor"
        />.</para>

        <figure id="fig-tutorial-query-editor">
          <title>The query to show where a thread is holding a lock and acquires another</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/tutorial-query-editor.png" />
            </imageobject>
          </mediaobject>
        </figure>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="reference">
    <title>Reference</title>
    
    <sect1>
      <title>The Flashlight menu</title>

      <figure id="fig-menu-flashlight">
        <title>The Flashlight menu</title>
        <mediaobject>
          <imageobject><imagedata fileref="images/menu-flashlight.png"/></imageobject>
        </mediaobject>
      </figure>

      <para>The Flashlight menu appears as an item on the Eclipse
      workspace main menu. This menu provides direct access to common
      commands. The menu is divided into three sections. The top section
      contains a shortcut to the <guilabel>Flashlight</guilabel>
      perspective. The middle section contains commands to report
      problems about or suggest improvements to Flashlight directly to
      SureLogic. The bottom section allows access to the license
      management dialog.</para>

      <para>The commands on the Flashlight menu are:</para>

      <itemizedlist>
        <listitem>
          <formalpara>
            <title>Open Flashlight Perspective</title>
            <para>This menu choice opens the
            <guilabel>Flashlight</guilabel> perspective. This
            perspective is useful for examining and querying collected
            run data. This perspective may also be opened via the normal
            Eclipse menus and toolbars for perspectives.</para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Send Tip for Improvement</title>
            <para>This command opens a dialog to allow entry of a
            suggestion by the user to improve the Sierra tool. For more
            information please see <xref
            linkend="sec-bugs-and-tips"/>.</para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Send Problem Report</title>
            <para>This command opens a dialog to allow entry of a
            problem report by the user about the Sierra tool. For more
            information please see <xref
            linkend="sec-bugs-and-tips"/>.</para>
          </formalpara>
        </listitem>
        <listitem>
          <formalpara>
            <title>Manage SureLogic Licenses</title>
            <para>This command opens the SureLogic license management
            dialog. This dialog allows the user to install, view, and
            uninstall licenses for Sierra and other SureLogic tools. 
            For more information see <xref
            linkend="sec-license-management" />.</para>
          </formalpara>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1>
      <title>The Flashlight perspective</title>

      <para>The Flashlight perspective organizes the Eclipse workbench
      to show views which will help you to interact with data from
      program runs.</para>

      <para>This perspective is useful for beginning use of the
      Flashlight tool. Its "canned" organization can help you to
      understand the capabilities of the tool.  Advanced users may want
      to reconfigure the screen layout and save a custom
      perspective.</para>
    </sect1>

    <sect1 id="sec-license-management">
      <title>License management</title>

      <para>Sierra is commercial software and a license is required to
      use it. Licenses are obtained from SureLogic and expire after some
      period of time. Lack of a license will prohibit you from running
      queries or creating new Flashlight runs. Selecting
      <guimenuitem>Manage SureLogic Licenses</guimenuitem> from the
      <guimenu>Flashlight</guimenu> menu brings up the license management form as seen in
      <xref linkend="fig-license-management" />. (It is also possible to
      bring this dialog up from the main Flashlight preferences pane by
      pressing the <guibutton>Manage SureLogic Licenses</guibutton>
      button.) For Flashlight to operate properly either a
      <emphasis>Flashlight</emphasis> or <emphasis>All Tools</emphasis>
      license must be installed.</para>

      <figure id="fig-license-management">
        <title>The SureLogic license management dialog</title>
        <mediaobject>
          <imageobject><imagedata fileref="images/license-management.png"/></imageobject>
        </mediaobject>
      </figure>

      <para>By default license installation requires internet access.
      SureLogic can, in special cases, provide licenses that do not
      require internet access. Further use of the product does not
      require internet access. If a manual uninstall is done, before
      license expiration, internet access is also required.  SureLogic
      tracks the number of times a particular license is installed and
      uninstalled. We stress that Flashlight does not, unlike other
      plug-ins such as MyEclipse, "talk-back" to SureLogic each time
      Eclipse is started.</para>

      <para>The installed license expires after a period of time
      (clearly visible to the user) and a new license has to be
      installed to continue to use Flashlight.</para>

      <para>Licenses can be installed more than once.  Thus, one license
      can be used for all of an organization or SureLogic can issue one
      per location or one per organizational entity.</para>

      <para>If the Flashlight Eclipse plug-in does not have a valid
      license it will not effect the Eclipse installation that
      Flashlight is installed into. The IDE will load and function
      normally, but when Flashlight functions are executed they will
      fail noting the lack of a license. Serviceability functions of the
      tool (e.g., sending problem reports to SureLogic, installing and
      uninstalling licenses) function properly without a license.  The
      unlicensed Flashlight plug-in can be uninstalled or disabled
      within Eclipse.</para>

      <para>When you receive a license file from SureLogic it is
      installed via this dialog.  To install the license select the row
      in the license table that matches the type of license.  For
      example, if you have been sent a Flashlight license select the
      Flashlight row in the license table.  Next press the
      <guibutton>Install License</guibutton> button.  You will be
      prompted for the location of your license file.  The tool checks
      with SureLogic and reports that your license has been installed
      and returns showing information about the installed license. The
      license file is not examined by the tool after the installation is
      completed unless you install the file again (after an
      uninstall).</para>

      <para>To uninstall a license, select the row in the license table
      and press the <guibutton>Uninstall License</guibutton>. You will
      be asked if you are sure you want to uninstall the license.  If
      you confirm the uninstall then the license is removed.  This may
      take a minute as SureLogic is informed that your license has been
      uninstalled.</para>

      <para>When a license is nearing expiration the tool warns the user
      with the dialog shown in <xref
      linkend="fig-license-management-expiration-warning" />.</para>

      <figure id="fig-license-management-expiration-warning">
        <title>Dialog warning that the installed Flashlight license is about to expire</title>
        <mediaobject>
          <imageobject><imagedata fileref="images/license-management-expiration-warning.png"/></imageobject>
        </mediaobject>
      </figure>

      <para>When a license does expire it disappears from the dialog.
      The tool is considered unlicensed at that point. To fix this
      situation install a new license (it is not required to install a
      new version of Flashlight).</para>
    </sect1>

    <sect1 id="preferences">
      <title>Preferences</title>

      <figure id="preference-page">
	<title>The Flashlight preference page</title>
	<mediaobject><imageobject><imagedata fileref="images/preference-page.png" /></imageobject></mediaobject>
      </figure>
      <para>
	Flashlight lets you adjust the way it instruments, records, and prepares
	data.  You should not have to change any preferences in order for
	Flashlight to work correctly, but changing some of these parameters may
	improve performance or convenience:
	<variablelist>
	  <varlistentry>
	    <term><guilabel>Data directory</guilabel></term>
	    <listitem><para>The directory where flashlight places all recorded and prepared data.  All data for a run is placed under a folder in this directory.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><guilabel>Action on instrumented launch</guilabel></term>
	    <listitem><para>These options affect what happens when you actually launch an instrumented application using the <guiicon><inlinegraphic fileref="images/fl_logo.png" /></guiicon> menu.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><guilabel>Instrumentation</guilabel></term>
	    <listitem><para>These options control how the instrumentation
	    collects and logs events from the running program.
	    <emphasis><guilabel>Output type</guilabel></emphasis> determines whether the
	    recorded information should be stored as an XML file, or as binary
	    data, and <emphasis><guilabel>Compress output</guilabel></emphasis> will gzip the
	    file when checked.  Flashlight has a 'refinery' that attempts to
	    cull data known to be local to a single thread, such as an object
	    that is created and garbage collected within a single method
	    invocation.  <emphasis><guilabel>Use refinery to remove thread-local
	    fields</guilabel></emphasis> will turn the refinery off and on, and you can
	    also adjust the queue sizes that it uses to hold onto
	    events. <emphasis><guilabel>Use a spy thread to detect program
	    termination</guilabel></emphasis> will have Flashlight spawn a thread on
	    program start-up that periodically checks to see if any non-daemon
	    threads are running and terminates the program when none are.  It is
	    not always necessary to run the spy thread, as Flashlight also has
	    listens to the run time shutdown event.  Some programs that do not
	    explicitly terminate may need it, though.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><guilabel>Preparing run data</guilabel></term>
	    <listitem><para>A sufficiently large Flashlight run may contain
	    millions of objects.  <emphasis><guilabel>Scan window size</guilabel></emphasis> determines
	    how many of these objects we look at in one pass of the data file.
	    Decreasing this number may allow you to prep a run with lower memory
	    utilization at the cost of a slightly longer prep time.  You may also
	    specify whether or not you want to automatically prepare data once a
	    running program has terminated.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><guilabel>Result querying</guilabel></term>
	    <listitem><para><emphasis><guilabel>Maximum rows returned</guilabel></emphasis>
	    lets you specify how many results you want to see returned by a
	    single query.  You may also change whether you are prompted once you
	    have run enough queries to use up a significant amount of
	    memory.</para></listitem>
	  </varlistentry>
	</variablelist>
      </para>
    </sect1>

    <sect1 id="launch">
      <title>Flashlight Launch Configuration</title>
      
      <para>Flashlight presents a customized launch configuration dialog
      when the <guimenuitem>Open Flashlight Dialog&hellip;</guimenuitem>
      command is selected from the <guisubmenu>Flashligh As</guisubmenu>
      submenu of the context menu in the <guilabel>Package
      Explorer</guilabel> view, or from the Flashlight &ldquo;run&rdquo;
      menu (<guiicon><inlinegraphic fileref="images/fl_logo.png" /></guiicon>) in the toolbar.  The Flashlight launch configuration dialog
      is based on the standard Java launch dialog, but with four additional
      configuration panes between the standard <guilabel>Arguments</guilabel> and
      <guilabel>JRE</guilabel> panes:
        <orderedlist>
          <listitem><guilabel>Instrumentation</guilabel></listitem>
          <listitem><guilabel>Data Collection</guilabel></listitem>
          <listitem><guilabel>Methods</guilabel></listitem>
          <listitem><guilabel>Fields</guilabel></listitem>
        </orderedlist>
      </para>
      
      <sect2 id="instrumentation-pane">
        <title>Instrumentation</title>
      </sect2>
      
      <sect2 id="data-collection-pane">
        <title>Data Collection</title>
      </sect2>
      
      <sect2 id="methods-pane">
        <title>Methods</title>
      </sect2>
      
      <sect2 id="fields-pane">
        <title>Fields</title>
      </sect2>
    </sect1>

    <sect1 id="sec-bugs-and-tips">
      <title>Bugs and tips</title>

      <para>Flashlight allows any user to send problem reports and
      suggestions to SureLogic from the main menu. Selecting
      <guimenuitem>Send Tip for Improvement</guimenuitem> or
      <guimenuitem>Send Problem Report</guimenuitem> allows a tip or
      problem report to be send to SureLogic directly within Eclipse as
      shown in <xref linkend="fig-bugs-and-tips-main-menu-service" />.
      These menu choices bring up dialogs that allow the user to control
      exactly what information is sent to SureLogic.  In addition, the
      user can preview the exact text that will be sent over the
      internet.</para>

      <figure id="fig-bugs-and-tips-main-menu-service">
        <title>Menu items to send bugs and tips to SureLogic</title>
        <mediaobject>
          <imageobject><imagedata fileref="images/bugs-and-tips-main-menu-service.png"/></imageobject>
        </mediaobject>
      </figure>

      <para>The <guimenuitem>Send Tip for Improvement</guimenuitem>
      command opens a dialog to allow entry of a suggestion by the user
      to improve the Flashlight tool as seen in <xref
      linkend="fig-bugs-and-tips-menu-send-tip" />. The dialog allows
      the user to control exactly what information is sent to SureLogic.
      In addition, the user can preview the exact text that will be
      sent.</para>

      <figure id="fig-bugs-and-tips-menu-send-tip">
        <title>Dialog allowing the user to enter a tip to improve Flashlight</title>
        <mediaobject>
          <imageobject><imagedata fileref="images/bugs-and-tips-menu-send-tip.png"/></imageobject>
        </mediaobject>
      </figure>

      <para>The <guimenuitem>Send Problem Report</guimenuitem> command
      opens a dialog to allow entry of a problem report by the user
      about the Flashlight tool as seen in <xref
      linkend="fig-bugs-and-tips-menu-problem-report" />. The dialog
      allows the user to control exactly what information is sent to
      SureLogic.  In addition, the user can preview the exact text that
      will be sent.</para>

      <figure id="fig-bugs-and-tips-menu-problem-report">
        <title>Dialog allowing the user to enter a problem report about Flashlight</title>
        <mediaobject>
          <imageobject><imagedata fileref="images/bugs-and-tips-menu-problem-report.png"/></imageobject>
        </mediaobject>
      </figure>

      <para>Messages sent from these dialogs go over HTTP to SureLogic.
      If a proxy is used on your network then it is critical to
      configure Eclipse to use it.  To do this open the Eclipse
      <guilabel>Preferences</guilabel> and examine the <guilabel>Network
      Connections</guilabel> under the <guilabel>General</guilabel>
      preferences.  This dialog allows you to configure Eclipse for your
      network as shown in <xref
      linkend="fig-bugs-and-tips-network-connections" />.</para>

      <figure id="fig-bugs-and-tips-network-connections">
        <title>Eclipse preferences for network connections within the IDE</title>
        <mediaobject>
          <imageobject><imagedata fileref="images/bugs-and-tips-network-connections.png"/></imageobject>
        </mediaobject>
      </figure>
    </sect1>
  </chapter>

  <chapter>
    <title>Release notes</title>
    
    <para>For each release of Flashlight there are new and noteworthy
    features to try out, and known limitations to avoid or workaround.
    These are presented in the sections below for each released version
    of Flashlight.</para>

    <sect1>
      <title>Flashlight version 2.1.1</title>
      
      <para>This section describes the 2.1.1 release of
      Flashlight.</para>
      
      <sect2>
        <title>New and Noteworthy</title>
        
        <para>This section describes new and noteworthy features in this
        version of Flashlight.</para>
      </sect2>
      
      <sect2>
        <title>Known Problems</title>
        
        <para>This section describes known bugs and limitations in this
        version of Flashlight.</para>
      </sect2>
    </sect1>
  </chapter>
  
  <bibliography>
    <biblioentry id="HaaseGuy07">
      <authorgroup>
        <author><firstname>Chet</firstname> <surname>Haase</surname></author>
        <author><firstname>Romain</firstname> <surname>Guy</surname></author>
      </authorgroup>
      
      <title>Filthy Rich Clients</title>      
      <subtitle>Developing Animated and Graphical Effects for Desktop Java Applications</subtitle>
      
      <publisher>
        <publishername>Prentice Hall PTR</publishername>      
      </publisher>
      
      <pubdate>2007</pubdate>
    </biblioentry>
  </bibliography>
</book>
