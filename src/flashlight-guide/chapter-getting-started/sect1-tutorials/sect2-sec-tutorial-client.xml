<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<sect2 id="sec-tutorial-client">
  <title>Using the Flashlight Eclipse client on PlanetBaron</title>

  <para>This tutorial assumes that you have installed Flashlight. If you
  see a <guimenu>Flashlight</guimenu> menu item on your Eclipse main
  menu than you can assume it has been installed properly.</para>

  <para>First download the <application>PlanetBaron</application> project from
  www.surelogic.com at <ulink
  url="http://www.surelogic.com/static/flashlight/PlanetBaron.zip">
  http://www.surelogic.com/static/flashlight/PlanetBaron.zip</ulink> to your
  disk. Unzip this archive into your workspace and it will create a
  <filename>PlanetBaron</filename> directory. Next import this project into your
  Eclipse workspace using <menuchoice><guimenu>File</guimenu>
  <guimenuitem>Import&hellip;</guimenuitem></menuchoice> from the Eclipse main
  menu and then choosing <guilabel>Existing Projects into Workspace</guilabel>
  for the import wizard. Follow the import steps of wizard until the
  <application>PlanetBaron</application> project is imported and built.</para>

  <para>PlanetBaron is a network-based real-time strategy game. It contains
  three programs that we will run during this tutorial. The first is a server
  program that manages the distributed game state. The second is a graphical
  program that allows a player to interact with the game. The third program,
  called the chat-test client, allows direct interaction with the server for the
  purpose of debugging and management. For example, the chat-test client is used
  to shutdown a server.</para>

  <para>Flashlight is a dynamic analysis tool. To get any useful results
  from Flashlight we have to collect data while a program is running. We
  will start below by describing how to run and play a PlanetBaron game.
  After we understand a bit about how to run the game we will return to
  using Flashlight on it.</para>

  <para>Let's run a PlanetBaron game. Select <filename>Server.java</filename> in
  the <package>edu.afit.planetbaron.server</package> package. Right-click and
  select <menuchoice><guisubmenu>Run As</guisubmenu> <guimenuitem>Java
  Application</guimenuitem></menuchoice>. You should see following output in the
  console which indicates that the server has started successfully:</para>

  <screen>
    [INFO "server-main"] PlanetBaron game server listening for clients on port 8693 and playing on a 15x15 map
  </screen>

  <para>Now we need to add some players. Select
  <filename>PlayerUI.java</filename> in the
  <package>edu.afit.planetbaron.client</package> package. Right-click and select
  <menuchoice><guisubmenu>Run As</guisubmenu> <guimenuitem>Java
  Application</guimenuitem></menuchoice>. You will see a Window appear has a
  blank grid and the title <application>PlanetBaron</application>. In the lower
  right-hand-corner enter a player name, <userinput>Laurel</userinput>, and
  press <guibutton>Connect</guibutton>.</para>

  <para>The screen will change to contain several planets and one ship with
  "Laurel" as its label. By moving your mouse around the grid you can direct
  your ship. Place your mouse over a planet and left-click.  This action will
  cause your ship to move slowly to that planet. When your ship arrives you will
  become the owner of that planet. This is called "taking ownership" of a
  planet. Go ahead an take ownership of a few planets. Note that while your ship
  is moving you are not allowed to change its destination.  Once it arrives at
  the destination you selected you can then select a subsequent
  destination.</para>

  <para>If you look at the console for the server you will see the commands that
  have come in from the Laurel PlayerUI. For example, your server console might
  look similar to the below:</para>

  <screen>
    [INFO "server-main"] PlanetBaron game server listening for clients on port 8693 and playing on a 15x15 map [edu.afit.planetbaron.server.Server.startListening()]
    [INFO "server-ch10"] client handler thread started [edu.afit.planetbaron.server.ClientHandler.run()]
    [INFO "server-ch10 (Laurel)"] "play "Laurel"" processed GameStateUpdate from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
    [INFO "server-ch10 (Laurel)"] "moveship "Laurel" to (12,11)" processed Ok from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
    [INFO "server-ch10 (Laurel)"] "moveship "Laurel" to (9,13)" processed Ok from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
    [INFO "server-ch10 (Laurel)"] "moveship "Laurel" to (8,10)" processed Ok from ch10 (Laurel) [edu.afit.planetbaron.server.ClientHandler.run()]
  </screen>

  <para>Now, go back to Eclipse and start a second instance of
  <filename>PlayerUI.java</filename>. In the lower right-hand-corner enter a
  player name, <userinput>Hardy</userinput>, and press
  <guibutton>Connect</guibutton>.</para>

  <para>The game supports as many players as you choose to connect to the
  server. Notice that the planets that Laurel owns are red in the Hardy PlayerUI
  while they are white in the Laurel PlayerUI.  Moving back and forth between
  the two PlayerUIs move the ships to play the game.  Note that the idea of the
  game is to own as many planets as you can. A game screenshot is shown in <xref
  linkend="fig-tutorial-planetbaron-playerui" />.</para>

  <figure id="fig-tutorial-planetbaron-playerui">
    <title>The PlanetBaron PlayerUI for Laurel</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-playerui.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>To finish the game press <guibutton>Disconnect</guibutton> in both
  PlayerUI instances and then terminate the programs by closing the application
  windows as usual. This action ends both player user interfaces but the server
  is still running.  To terminate the server we need to use the chat-test client
  program. Select <filename>ChatTestClient.java</filename> in the
  <package>edu.afit.planetbaron.client</package> package. Right-click and select
  <menuchoice><guisubmenu>Run As</guisubmenu> <guimenuitem>Java
  Application</guimenuitem></menuchoice>. You will see a window appear with the
  title <application>ChatTest - PlanetBaron</application>. This program allows
  you to directly control the game server via text commands. We want to use it
  to shutdown the game server. To do this press <guibutton>Connect</guibutton>
  to connect to the game server and enter <userinput>shutdown</userinput> as the
  command. Your screen should now look like the one shown in <xref
  linkend="fig-tutorial-planetbaron-chattestclient" />.</para>

  <figure id="fig-tutorial-planetbaron-chattestclient">
    <title>Using the ChatTestClient to shutdown the game server</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-chattestclient.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Press <guibutton>Send</guibutton> to shutdown the server. A
  dialog will appear stating that the server has disconnected from the
  ChatTestClient that you may dismiss. You can now terminate the
  ChatTestClient by closing the application window. Back in the Eclipse
  console for the server you should see the following message at the
  bottom:</para>

  <screen>
    [INFO "server-main"] PlanetBaron game server shutdown complete
  </screen>

  <para>We are now ready to use Flashlight to help us understand the
  concurrency in the PlanetBaron game. Let's start with the
  ChatTestClient. To run the ChatTestClient with Flashlight
  instrumentation we select it from the Flashlight launch tab in the
  Eclipse toolbar as shown in <xref
  linkend="fig-tutorial-planetbaron-running-chattestclient" />.</para>

  <figure id="fig-tutorial-planetbaron-running-chattestclient">
    <title>Running ChatTestClient with Flashlight instrumentation</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-running-chattestclient.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>The ChatTestClient window will appear on your screen. Select the
  <guibutton>Connect</guibutton> to try an connect to a game server.
  This will fail and the application will show a dialog to you which you
  may dismiss. The reason it fails is that we did not start a game
  server. At this point we have exercised the ChatTestClient enough to
  see some Flashlight results. Go ahead and close the application window
  to terminate the program. At this point Eclipse, which knows that this
  launch was instrumented, will prompt you to switch to the Flashlight
  perspective as shown in <xref
  linkend="fig-tutorial-planetbaron-perspective-switch-dialog"
  />.</para>

  <figure id="fig-tutorial-planetbaron-perspective-switch-dialog">
    <title>Prompting the user to switch to the Flashlight perspective</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-switch-dialog.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Press <guibutton>Yes</guibutton> and the Flashlight perspective
  will appear as shown in <xref
  linkend="fig-tutorial-planetbaron-perspective-empty" />.</para>

  <figure id="fig-tutorial-planetbaron-perspective-empty">
    <title>The Flashlight perspective</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-empty.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>The Flashlight perspective is used to manage and query data collected
  from instrumented programs. The <guilabel>Flashlight Runs</guilabel> view in
  the upper-left manages the instrumented runs of programs. This view allows you
  to prepare data to be queried, select a prepared run for querying, and delete
  runs from the disk.  We need to prepare, or <emphasis>prep</emphasis>, the
  ChatTestClient run.  When you switch to the Flashlight perspective, you should
  be prompted to prepare your run data as shown in <xref
  linkend="fig-tutorial-planetbaron-perspective-run-dialog" />.</para>


  <figure id="fig-tutorial-planetbaron-perspective-run-dialog">
    <title>Prompting the user to prepare a completed run</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-run-dialog.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Press <guibutton>Yes</guibutton> and Flashlight will start preparing the
  run.  If you have changed your workspace preferences so that the above dialog
  does not show up, double-click the row in the <guilabel>Flashlight
  Runs</guilabel> table to prepare your run.  Alternatively you can select the
  run, right-click, and select <guimenuitem>Prepare</guimenuitem> from the
  context menu.</para>

  <para>A dialog will appear showing the progress of prepping the data for
  querying. For large runs prepping can take a significant amount of time. This
  run, which only collected roughly 5 KB of data, should prep quickly taking up
  a total of roughly 10 MB of disk space.</para>

  <para>When the prep is complete two changes will occur. First, a
  <guiicon><inlinegraphic fileref="images/drum.png" /></guiicon> will
  appear in the <guilabel>Prep</guilabel> column of the
  <guilabel>Flashlight Runs</guilabel> view table for this run. Second,
  several queries are now able to be run on the data. These queries are
  listed in the <guilabel>Query Menu</guilabel> view directly below the
  <guilabel>Flashlight Runs</guilabel> view.</para>

  <para>At this point we can run a query on the data. Double-click on the
  <emphasis>What fields (non-static) are shared?</emphasis> query.  The results
  will appear in the <guilabel>Query Results</guilabel> view.  Your screen
  should appear as shown in <xref
  linkend="fig-tutorial-planetbaron-perspective-ctc1" />.  Query results are
  presented as a table, tree, or tree-table.  This result is a tree-table. The
  result reports the shared non-static fields noted in the run.</para>

  <figure id="fig-tutorial-planetbaron-perspective-ctc1">
    <title>Non-static fields that were observed to be shared in a ChatTestClient run</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc1.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Selecting fields in the query result causes these fields to be
  highlighted in two views at the bottom of the Flashlight perspective.  The
  view to the left is the normal Java editor and represents the current state of
  the source code. The view to the right is an <guilabel>Historical Source
  Snapshot</guilabel> view that shows you the code as it existed when the
  program was executed.  This view helps you to understand if the code has
  evolved since the run you are querying was made.</para>

  <para>Select the <structfield>f_connectDisconnectButton</structfield> and
  right-click. This brings up a menu of queries that can be run on this
  result. Select <emphasis>What are the individual instances of this non-static
  field?</emphasis> You should see a table with a single entry, as in <xref
  linkend="fig-tutorial-planetbaron-perspective-ctc7" />.  If any other
  ChatTestClient objects had been created and shared their
  <structfield>f_connectDisconnectButton</structfield> with more than one
  thread, we would see entries for them here as well.
  </para>

  <figure id="fig-tutorial-planetbaron-perspective-ctc7">
    <title>A ChatTestClient object containing the <structfield>f_connectDisconnectButton</structfield> field.</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc7.png" />
      </imageobject>
    </mediaobject>
  </figure>
  
  <para>Right click on the single row and select <emphasis>What threads read and
  write this field?</emphasis> The results should look something like <xref
  linkend="fig-tutorial-planetbaron-perspective-ctc2" />.  In the case of
  f_connectDisconnectButton we see that the AWT-EventQueue-0, known as the event
  dispatch thread (EDT), and the main thread shared this field. Note that all
  the accesses by the main thread were during construction of the
  ChatTestClient.
</para>

  <figure id="fig-tutorial-planetbaron-perspective-ctc2">
    <title>What threads read and write this field?</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc2.png" />
      </imageobject>
    </mediaobject>
  </figure>
  
  <para>We will zoom in a little more and look at the actual accesses of this
  field.  Right click on the table, and run <emphasis>When and by what threads
  was this field accessed?</emphasis> The result of this query should look like
  <xref linkend="fig-tutorial-planetbaron-perspective-ctc3" /> and will show you
  each read and write of the field that was observed by the instrumentation as
  the program executed. It shows the time at which the event occurred and the
  thread it happened within. Select the second access by the main thread and
  right-click. Drill-in again by selecting <emphasis>What is the stack trace for
  this access?</emphasis> as shown in <xref
  linkend="fig-tutorial-planetbaron-perspective-ctc8" />.</para>

  <figure id="fig-tutorial-planetbaron-perspective-ctc3">
    <title>Looking at the accesses made to a field</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc3.png" />
      </imageobject>
    </mediaobject>
  </figure>
  
  <figure id="fig-tutorial-planetbaron-perspective-ctc8">
    <title>Drilling in to see the stack trace for this field access</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc8.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>This will result in a stack trace for the selected access.  Selecting
  each row of the result will show that line of code in the program.  The bottom
  row is, in fact, a bug in the program. This line is shown in <xref
  linkend="fig-tutorial-planetbaron-perspective-ctc4" />.</para>

  <figure id="fig-tutorial-planetbaron-perspective-ctc4">
    <title>The broken line of code in ChatTestClient</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc4.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>What is wrong? To understand this problem we quote from Haase
  and Guy's <citetitle pubwork="book">Filthy Rich
  Clients</citetitle><biblioref linkend="HaaseGuy07"/>:</para>

  <blockquote><para>Swing's threading model is based on a single rule:
  The EDT is responsible for executing any method that modifies a
  component's state. This includes any component's constructor.
  According to this rule, and despite what you can read in many books
  and tutorials about Swing. the <function>main()</function> method in
  the previous code example is invalid and can cause
  deadlock.</para></blockquote>

  <para>To fix this problem we need to call the ChatTestClient
  constructor on the EDT. We can do this by changing the
  <function>main()</function> method to look like the code below.</para>

  <programlisting>
<![CDATA[
public static void main(String[] args) {
  // run the application
  SwingUtilities.invokeLater(new Runnable() {
    @Override
    public void run() {
new ChatTestClient();
    }
  });
}
]]>
  </programlisting>

  <para>Save this change and launch ChatTestClient using the Flashlight
  launch shortcut again. Perform the same actions that you did during
  the first run (i.e., try to connect, dismiss the dialog, and
  exit).</para>

  <para>A new run will appear in the <guilabel>Flashlight
  Runs</guilabel> view. Double-click this run to prep it.</para>

  <para>Clear out the previous query results by clicking the
  <guiicon><inlinegraphic fileref="images/gray_x_double.png"
  /></guiicon> in either the <guilabel>Result Explorer</guilabel>
  portion of the <guilabel>Query Flashlight</guilabel> view or the
  <guilabel>Flashlight Query Results</guilabel> view. This action clears
  out the saved results from all previous queries (the set of these
  results is saved in the <guilabel>Result Explorer</guilabel> portion
  of the <guilabel>Query Flashlight</guilabel> view).</para>

  <para>Check that you have the new run selected in the
  <guilabel>Flashlight Runs</guilabel> view and then double-click on the
  <emphasis>What non-static fields are shared?</emphasis> query. The
  query is successful but no rows are returned. This indicates that no
  shared fields were observed. This run provides some evidence that we
  have fixed the bug discovered in ChatTestClient.</para>

  <para>Before we move on let's examine the old run one final time.  Clear out
  the previous query results by again clicking the <guiicon><inlinegraphic
  fileref="images/gray_x_double.png" /></guiicon> icon. Select the first
  ChatTestClient run and double-click the <emphasis>What non-static fields are
  shared?</emphasis> query. Select the f_connectDisconnectButton and right-click
  to select the <emphasis>What are the invidual instances of this non-static
  field?</emphasis> query, then the <emphasis>When and by what threads was this
  field accessed?</emphasis> query. Select the second access by the main thread
  and right-click to select the <emphasis>Show stack trace for a field
  access</emphasis> query. By selecting the bottom row of the stack trace you
  can see that, while the Java editor code might prove confusing (because we
  changed it), the <guilabel>Historical Source Snapshot</guilabel> view
  remembers what the code looked like in this previous run. This difference is
  shown in <xref linkend="fig-tutorial-planetbaron-perspective-ctc5" />.</para>

  <figure id="fig-tutorial-planetbaron-perspective-ctc5">
    <title>The broken line of code in ChatTestClient is remembered by the Historical Source Snapshot view</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc5.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>We are finished with our examination of these runs, so let's
  delete them. First, clear out all the queries by pressing the
  <guiicon><inlinegraphic fileref="images/gray_x_double.png"
  /></guiicon> icon. In the <guilabel>Flashlight Runs</guilabel> view
  select both runs and right-click. Select
  <guimenuitem>Delete</guimenuitem> from the context menu as shown in
  <xref linkend="fig-tutorial-planetbaron-perspective-ctc6" />.</para>

  <figure id="fig-tutorial-planetbaron-perspective-ctc6">
    <title>Deleting two Flashlight runs</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-perspective-ctc6.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>You will be prompted once per run to ensure that you really want
  to delete this Flashlight run data. In both cases check the
  <guilabel>Delete raw data files from the disk</guilabel> option and
  press <guibutton>OK</guibutton>. After a short delay the
  <guilabel>Flashlight Runs</guilabel> view should be empty. It is
  important to delete old runs to ensure that you free up disk space on
  your computer.</para>

  <para>ChatTestClient was a simple Swing application that we tried out
  one query on. This query let us understand shared state that was
  observed by Flashlight during a run of the ChatTestClient program.
  Even this simple query uncovered a bug that could easily be overlooked
  in a code inspection. We now turn our attention to a more complex
  multi-threaded program, the PlanetBaron server, to illustrate several
  more complex queries Flashlight is capable of. The basic user
  interaction with the Flashlight tool will remain the same: run a
  instrumented program, prep the data, query the data, drill into query
  results, and act (e.g., change/fix code).</para>

  <para>Start a server using the Flashlight launch tab the Eclipse
  toolbar as shown in <xref
  linkend="fig-tutorial-planetbaron-running-server" />.</para>

  <figure id="fig-tutorial-planetbaron-running-server">
    <title>Running Server with Flashlight instrumentation</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-running-server.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Next start three PlayerUI instances. We don't want to instrument
  these programs, so use the normal launch tab as shown in <xref
  linkend="fig-tutorial-planetbaron-running-playerui" />.</para>

  <figure id="fig-tutorial-planetbaron-running-playerui">
    <title>Running a PlayerUI without Flashlight instrumentation</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-running-playerui.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Go ahead and connect into the game as Laurel, Hardy, and
  Groucho. Exercise the game by having each player take several planets.
  Have one planet be owned by each player at one time. To do this click
  on the same planet in all three PlayerUI instances. This is shown in
  <xref linkend="fig-tutorial-planetbaron-running-game" />.</para>

  <figure id="fig-tutorial-planetbaron-running-game">
    <title>Running three players at once on an instrumented server</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-running-game.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>When you have exercised the three players, terminate the thee
  PlayerUI instances by closing the application windows. Run a
  ChatTestClient (without instrumentation) and use it to shutdown the
  server.</para>

  <para>In the Flashlight perspective go ahead and prep the server run
  so that it can be queried. This will take a few minutes to
  complete.</para>

  <para>The queries we do on the server results may or may not be
  similar to what you see at your computer. The program we are examining
  is a multi-threaded network-based game server. Therefore, it is
  impossible to duplicate a run&mdash;even for tutorial purposes. You
  should, however, see similar results to what we present and you are
  encouraged to see what you can find in your run results.</para>

  <para>We'll use a couple of analyses performed by Flashlight during the prep
  phase to investigate the PlanetBaron server.  The first of these is a lockset
  analysis.  A lockset analysis examines each access of a field in the program
  and insersects the set of locks held.  If shared state has a lockset it is a
  good thing&mdash;this state was observed to be protected consistently by at
  least one lock.  This isn't a guarantee that this field will always be
  protected in every run of the program (to make this determination a sound
  verification tool like SureLogic JSure is required), but it was for the
  particular run of the program observed.  If shared state has no lockset then
  this may be a bad thing&mdash;it might mean that your program contains a race
  condition.  To take a look at the results of Flashlight's lock analysis, run
  the query <emphasis>What fields (non-static) have an empty lock
  set?</emphasis> The results should indicate that a few instances of
  <classname>edu.afit.planetbaron.game.Ship</classname> have no lock set for the
  field <structfield>f_location</structfield>, as seen in <xref
  linkend="fig-tutorial-planetbaron-lockset1" />.</para>
  
  <figure id="fig-tutorial-planetbaron-lockset1">
    <title>An empty lock set in PlanetBaron</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-lockset1.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>As we did before when we were looking at shared fields in the test
  client, we can look at the individual objects holding this field in by running
  <emphasis>What are the individual instances of this non-static
  field?</emphasis>As seen in <xref linkend="fig-tutorial-planetbaron-lockset2"
  />, there is one Ship object for each ship in the PlanetBaron game, and none
  of them have a lock set.  We'll investigate this further by looking to see
  what locks <emphasis>are</emphasis> held when this field is accessed.  Choose
  one of the Ship objects, and run the query <emphasis>How often is a lock held
  when this field is accessed after object construction?</emphasis> You should
  see something that looks like <xref
  linkend="fig-tutorial-planetbaron-lockset3" />.</para>

  <figure id="fig-tutorial-planetbaron-lockset2">
    <title>Three objects with no lock set on <structfield>f_location</structfield></title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-lockset2.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <figure id="fig-tutorial-planetbaron-lockset3">
    <title>Locks held while <structfield>f_location</structfield> is
    accessed</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-lockset3.png" />
      </imageobject>
    </mediaobject>
  </figure>
  
  <para>
    The query shows that several locks are held when this field is accessed,
    although - as we already know - none of them are held for every access.  One
    of the locks seems to be held almost all of the time, however. In the
    example shown in <xref linkend="fig-tutorial-planetbaron-lockset3" />, it
    appears that one of the locks is held for all but 5 of the accesses.  Select
    the most commonly held lock, and run the query <emphasis>Where is this field
    accessed while this lock is not held?</emphasis> Click on all three of the
    lines of code that are displayed.  Two of them are in the constructor, and
    don't appear to be a problem.  The final line, on the other hand, is an
    unprotected access that we have found.  <xref
    linkend="fig-tutorial-planetbaron-lockset4" /> shows the incorrectly
    synchronized line of code.

  <figure id="fig-tutorial-planetbaron-lockset4">
    <title>The offending line of code</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-planetbaron-lockset4.png" />
      </imageobject>
    </mediaobject>
  </figure>

    <!-- TODO fix this and show that the field now has a lockset -->
  </para>
  <!--      -->

  <para>TODO: run the <emphasis>Where does a thread hold a lock and
  acquire another?</emphasis> and examine the results to show potential
  deadlock.</para>

  <para>TODO: Show the query editor. None of these queries are special
  and they can be edited. Select <menuchoice><guimenu>Window</guimenu>
  <guisubmenu>Show View</guisubmenu> <guimenuitem>Flashlight Query
  Editor</guimenuitem></menuchoice> from the Eclipse main menu to open
  the <guilabel>Flashlight Query Editor</guilabel> view. This view is
  shown in <xref linkend="fig-tutorial-query-editor" />.</para>
  <!--      -->
  <figure id="fig-tutorial-query-editor">
    <title>The query to show where a thread is holding a lock and acquires another</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-query-editor.png" />
      </imageobject>
    </mediaobject>
  </figure>
</sect2>
