<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<section>
  <title>Uniqueness Declarations</title>
  
  <para>The same annotation, <classname>@Unique</classname>, is used to annotate
    <itemizedlist>
      <listitem><para>That a field reference is
      unaliased and aggregated into the referencing object.</para></listitem>

      <listitem><para>That a method/constructor returns an
      unaliased reference.</para></listitem>

      <listitem><para>That a method/constructor parameter expects
      to be passed an unaliased.</para></listitem>
    </itemizedlist>
    
  The general form of the annotation is 
  
    <synopsis>
@Unique("<optional>this <optional>, return</optional></optional>")
    </synopsis>
    
  where the order of <code>this</code> and <code>return</code> doesn't
  matter. Fields and parameters are annotated without any argument to
  <classname>@Unique</classname>; in fact it is syntax error if the
  annotation is not
  <classname>@Unique("")</classname>:<footnote><para><classname>@Unique</classname>
  is syntactic sugar for
  <classname>@Unique("")</classname>.</para></footnote>
  
    <programlisting>class C {
  <emphasis>@Unique</emphasis> List list;
  &hellip;
  public void method(final <emphasis>@Unique</emphasis> Object p) {
    &hellip;
  }
  &hellip;
}</programlisting>
  </para>
  
  <para>The <code>Instance</code> region of the object referenced by a 
  <classname>@Unique</classname> field is implicitly aggregated into the state
  of the referencing class:
  
    <itemizedlist>
      <listitem><para>If the field is non-<code>final</code>, the <code>Instance</code>
      region of the referenced object is aggregated into the annotated
      field.</para></listitem>
      
      <listitem><para>if the field is <code>final</code> and non-<code>static</code>,
      the <code>Instance</code> region of the referenced object is aggregated
      into the <code>Instance</code> region of the class that contains the
      annotated field.</para></listitem>
    </itemizedlist>
  </para>
  
  <para>The receiver (<parameter>this</parameter>) is a special case because
  it is not explicitly declared.  To annotate that the receiver must be
  unaliased, the method itself must be annotated instead:
  
    <programlisting>class C {
  &hellip;
  <emphasis>@Unique("this")</emphasis>
  public void needsUnaliasedReceiver(&hellip;) {
    &hellip;
  }
  &hellip;
}</programlisting>
    
  A method may be annotated to indicate that the return value is an
  unaliased object.  A constructor may be annotated to indicate that the
  newly constructed object is not aliased. Both these cases share the
  same annotation:
  
    <programlisting>
class C {
  <emphasis>@Unique("return")</emphasis>
  public C(&hellip;) {
    &hellip;
  }
  
  <emphasis>@Unique("return")</emphasis>
  public Object method(&hellip;) {
    &hellip;
  }
  &hellip;
}
    </programlisting>
    
  If a method both requires an unaliased receiver and guarantees
  an unaliased return value, the appropriate annotation is
  <classname>@Unique("this, return")</classname> or
  <classname>@Unique("return, this")</classname>.</para>
  
  <section>
    <title>Field Constraints</title>
    
    <itemizedlist>
      <listitem>
        <formalpara>
          <title>The field must have a non-primitive type</title>
        </formalpara>
      </listitem>
      <listitem>
        <formalpara>
          <title>The field cannot be <code>final static</code></title>  The
          annotation <classname>@UniqueInRegion</classname> should be used
          in this case.
        </formalpara>
      </listitem>
    </itemizedlist>
  </section>
  
  <section>
    <title>Parameter Constraints</title>
    
    <itemizedlist>
      <listitem>
        <formalpara>
          <title>The parameter must have a non-primitive type</title>
          
          <para>This is trivially satisfied when the the receiver is unique.</para>
        </formalpara>
      </listitem>
    </itemizedlist>
  </section>
  
  <section>
    <title>Return Value Constraints</title>
    
    <itemizedlist>
      <listitem>
        <formalpara>
          <title>The return value must have a non-primitive type</title>
          
          <para>This is trivially satisfied when annotating a constructor return value.</para>
        </formalpara>
      </listitem>

      <listitem>
        <formalpara>
          <title>The return type must not be <code>void</code></title>
        </formalpara>
      </listitem>

      <listitem>
        <formalpara>
          <title>A constructor with a unique return value must not also be annotated with <code>@Borrowed("this")</code></title>
        </formalpara>
      </listitem>
    </itemizedlist>
  </section>
</section>