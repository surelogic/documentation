<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">
           
      <section id="borrowed-and-effects">
        <title>Borrowed References and Method Effects</title>
        
        <para>Another reason to declare method effects is to support
        <classname>@Borrowed</classname> references. Here we first introduce
        <classname>@Borrowed</classname> parameters, and then describe how
        effects are used to support their assurance.</para>
        
        <section id="borrowed-params">
          <title>Borrowed Parameters</title>
          
          <para>When an object is passed as a parameter to a method,
          an alias to that object is created.  Thus, if strictly
          enforced, a unique field can never be passed as a parameter
          to a method, even as the receiver!  But if a method is known
          to not create any additional aliases to the object, then a
          unique field may safely be passed as a parameter because it
          is guaranteed that the method will restore the uniqueness of
          the field.  However, the method is not allowed to directly
          or indirectly make use of the unique field used as the
          parameter because the field is <emphasis>not</emphasis>
          unique within the dynamic scope of the method.  A parameter
          (including the receiver) is declared to be borrowed by
          annotating the parameter as
          <classname>@Borrowed</classname>.  To declare that
          the receiver is borrowed, we annotate the method with
         <code>@Borrowed("this")</code>. To declare that a constructor does
          not alias the object under construction, we annotate it
          with either <code>@Unique("return")</code> or
          <code>@Borrowed("this")</code> (which are defined to be equivalent
          for constructors).</para>
          
          <para>Consider method <function>C.copyInternalArray()</function>:
          
            <programlisting>
public class C {
  private Object[] myArray;
  &hellip;
  <emphasis>@Borrowed("this")</emphasis>
  public void copyInternalArray(<emphasis>@Borrowed</emphasis> Object[] array) {
    for (int i  = 0; i  &lt; array.length; i++) {
      array[i] = this.myArray[i];
    }
  }
}
            </programlisting>
          
          Because the method declares that its receiver is borrowed,
          it may be invoked on <classname>C</classname> objects referenced
          through <classname>@Unique</classname> fields.  It may also be
          passed references to arrays referenced by
          <classname>@Unique</classname> fields.  Here it is easy to see that
          no aliases to this or to array are created, but, in general,
          this is a property that is easily violated, and a separate set
          of analyses from those used to assure locking are used to assure
          that <classname>@Unique</classname> fields and
          <classname>@Borrowed</classname> variables are used
          correctly.</para>
         </section>
         
         <section id="borrowed-with-method-effects">
           <title>Supporting Borrowed With Method Effects</title>
           
           <para>As explained above, when a method is passed the value of
           a unique field as the actual to a borrowed parameter, the
           method is not allowed to access the unique field.  Analysis
           looks to the effects of the methods to determine if the method
           could possibly read the forbidden field.  Thus, if a method has
           borrowed parameters, it is usually necessary to declare the
           methods effects as well.</para>
           
           <para>Consider the class <classname>Var</classname>:
           
             <programlisting>
class Var {
  private int value = 0;
  
  <emphasis>@Borrowed("this")</emphasis>
  public void set(int v) { value = v; }

  <emphasis>@Borrowed("this")</emphasis>
  public int get() { return v; } 
}
            </programlisting>
          
          It's obvious that we can declare the receiver to be
          borrowed for the two methods.  If we never
          actually use a unique field as the receiver, then we do not need
          to declare the effects of the methods:
          
            <programlisting>
class VarClient {
  private Var v1 = new Var();
  private Var v2 = new Var();

  public void doStuff() {
    v1.set(1);
    v2.set(2);
    &hellip;
    v1.set(v2.get()+3); 
  } 
}
            </programlisting>
          </para>
          
          <para>If instead field <structfield>v1</structfield> were annotated with
          <classname>@Unique</classname>, then analysis would need to know
          that it is not possible for <function>set()</function> to read the
          field <structfield>v1</structfield> when <structfield>v1</structfield> is used
          as the receiver.  Here it is obvious that it cannot, but in
          cases where the invoked method retrieves objects from
          collections or other global object pools, it is not so clear. 
          We must explicitly declare the effects of
          <function>set()</function> to allow the uniqueness analysis to
          assure the call (we also declare the effects of
          <function>get()</function> for completeness):
          
            <programlisting>
class Var {
  private int value = 0;
  
  @Borrowed("this")
  <emphasis>@RegionEffects("writes this:Instance")</emphasis>
  public void set(int v) { value = v; }

  @Borrowed("this")
  <emphasis>@RegionEffects("reads this:Instance")</emphasis>
  public int get() { return v; } 
}
            </programlisting>
          </para>
        </section>
      </section>
