<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">
   
<sect1 id="self-protected-objects">
  <title>Thread-Safe and Immutable Objects</title>
      
  <para>Region aggregation, described above, is one technique that can
  be used to deal with the fact that fields
  <emphasis>reference</emphasis> objects.  But it is not always possible
  to use region aggregation to simplify reasoning about protected state
  because a field may be aliased.  In such cases, the tool may produce
  warnings that a reference of the form <code>e.f.g</code>, where
  <structfield>f</structfield> is field protected by a lock, is a
  “possibly unsafe reference to protected shared state.”  The message is
  meant to remind the programmer that although the field
  <structfield>f</structfield> is protected by a lock, this lock does
  not also protect the field <structfield>g</structfield> of the
  referenced object. (If field <structfield>f</structfield> is of class
  <classname>C</classname> and class <classname>C</classname> declares
  that <structfield>g</structfield> is protected by a lock then this
  warning is not produced: the tool instead attempts to assure that the
  appropriate lock for <structfield>g</structfield> is held.)  There are
  situations where invoking a method via <code>e.f.m()</code> will also
  produce the above warning.</para>
      
  <para>Region aggregation and lock declaration (as described above) can
  be used to suppress these warnings.  In general, we can suppress this
  warning for a field <structfield>f</structfield> that references
  objects of class <classname>C</classname> by annotating class
  <classname>C</classname> with <classname>@ThreadSafe</classname>. This
  annotation declares that no sequences of accesses (reads and writes to
  public fields, calls to public methods) may put an object of the
  annotated class into an invalid state, regardless of the interleaving
  of those actions by the runtime, and without requiring any additional
  synchronization or coordination on the part of the caller.  If a class
  is thread safe because its instances are immutable objects, the more
  specific annotation <code>@Immutable</code> is preferred.</para>
       
  <note>
    <para>In earlier versions of JSure the <code>@ThreadSafe</code> and
    <code>@Immutable</code> annotations were not assured by analysis. 
    This is no longer the case.
    </para>
  </note>
      
  <para>As an example, let us consider the simple rational numbers class
  below:

    <programlisting>
public class Rational {
  private final int numerator;
  private final int denominator;

  public Rational(int n, int d) { 
    numerator = n; 
    denominator = d; 
  }

  public int getNumerator() { return n; }
  public int getDenominator() { return d; } 
}
    </programlisting>
      
  Suppose we have a client class that has a lock-protected reference to
  a <classname>Rational</classname> object:
      
    <programlisting>
@RegionLock("Lock is this protects Instance")
public class C {
  &hellip;
  private Rational r;

  public synchronized doStuff() {
    int n = r.getNumerator();
    &hellip;
  }
}
    </programlisting>
  </para>
      
  <para>JSure is going to generate a warning attached to call
  <code>r.getNumerator()</code> that <computeroutput>Receiver r may be a
  shared unprotected object</computeroutput>.  That is, we may be doing
  something unsafe: accessing the state of the rational object in
  multiple threads without protection.  But in this case, we know that
  <classname>Rational</classname> objects are immutable, and thus thread
  safe, so we can both suppress this warning and use analysis to ensure
  that instances of the class remain immutable by annotating the
  <classname>Rational</classname> class:
      
    <programlisting>
<emphasis>@Immutable</emphasis>
public class Rational {
  &hellip;
}
    </programlisting>
  </para>
  
  <sect2>
    <title>The @Immutable Annotation</title>
    
    <para>Instances of a type annotated with <code>@Immutable</code> are immutable:
    its state cannot be seen to change by callers.  This annotation is currently
    assured by restricting how the fields of the class are declared and
    annotated. For a class annotated as <code>@Immutable</code> assure,
    each field must be
    
      <itemizedlist>
        <listitem>
          Declared <code>final</code>; and
        </listitem>
        
        <listitem>
          Be of a primitive type or of a type annotated <code>@Immutable</code>.
        </listitem>
      </itemizedlist>
      
    Clearly the class <classname>Rational</classname> above assures
    because both fields are <code>final int</code>.
    </para>
    
    <para>The assurance rule above for <code>@Immutable</code> is overly 
    conservative and can prevent the assurance of legitimately immutable
    classes.  Two code patterns that are disallowed by the above rule are
    lazy initialization and collection-typed fields.</para>
    
    <para>Immutable classes are allowed to have lazily initialized fields as
    long as the values of those fields are derived from other immutable fields
    and callers cannot tell the difference.  But to have a lazily initialized
    field, the field cannot be declared <code>final</code>.  Consider lazily
    computing the hash value for <classname>Rational</classname> instances:
    
      <programlisting>@Immutable
public class Rational {
  private final int numerator;
  private final int denominator;
  
  private int hashCode;

  public Rational(int n, int d) { 
    numerator = n; 
    denominator = d; 
  }

  public int hashCode() {
    if (hashCode == 0) {
      hashCode = 17;
      hashCode = 31 * hashCode + numerator;
      hashCode = 31 * hashCode + denominator;
    }
    return hashCode;
  }

  public int getNumerator() { return n; }
  public int getDenominator() { return d; } 
}
      </programlisting> 
      
    The field <structfield>hashCode</structfield> cannot be declared <code>final</code>,
    and thus the class cannot be assured to be immutable.  In this case, we can
    use the <code>@Vouch</code> annotation on the field <structfield>hashCode</structfield>
    to declare that the field does satisfy the requirements for immutability:
    
      <programlisting>@Immutable
public class Rational { &hellip;
  <emphasis>@Vouch("Immutable")</emphasis>
  private int hashCode;
  &hellip;
}
      </programlisting> 
    
    This annotation forces the assurance to believe that annotated field
    satisfies the requirements for immutability, but no additional analysis
    is performed to check that this is the case.  It is purely a declaration
    by the programmer that this is the case.  As such, <code>@Immutable</code>
    annotations that depend on programmer vouches are displayed differently 
    in the results view.  The programmer can capture the rationale for the
    declaration in the annotation to better document the situation:
    
      <programlisting>@Immutable
public class Rational { &hellip;
  @Vouch(value="Immutable",
         <emphasis>reason="Lazily initialized in hashCode()"</emphasis>)
  private int hashCode;
  &hellip;
}
      </programlisting>
    </para>
    
    <para>A field declared to be of an array type, e.g., <code>int[]</code>,
    or declared to be of a collection type, e.g., <code>List&lt;String&gt;</code>,
    is not generally immutable.  Arrays elements are never immutable, and while
    collection classes can have immutable implementations, it's usually not 
    possible to tell if this is the case.  If a class is implemented in such
    a way that the array or collection elements are not altered after
    construction, the <code>@Vouch</code> annotation can be used on the field
    to declare that this is the case:
    
      <programlisting>
      @Vouch(value="Immutable",
             reason="Assigned an immutable wrapper instance")
      private List&lt;String&gt; names = Collections.unmodifiableList(&hellip;);
      </programlisting>
    </para>
  </sect2>

  <sect2>
    <title>The @ThreadSafe Annotation</title>
    
    <para>The <code>@ThreadSafe</code> annotation is assured by check that 
    each field in the class is
      <itemizedlist>
        <listitem><code>final</code> and "safe"; or</listitem>        
        <listitem><code>volatile</code> and "safe"; or</listitem>        
        <listitem>protected by a lock and "safe"</listitem>        
      </itemizedlist>
    
    where "safe" means that one of the following conditions is true:
    
      <itemizedlist>
        <listitem>The declared type is primitive.</listitem>
        
        <listitem>The declared type is annotated <code>@ThreadSafe</code>.</listitem>
        
        <listitem>The declared type is annotated <code>@Immutable</code>.</listitem>
        
        <listitem>The declared type is annotated <code>@Containable</code> and 
        the object referenced by the field is aggregated into a region
        protected by a lock.         
        </listitem>
      </itemizedlist>
      
    Finally, a <code>@Containable</code> class is one whose instances can
    be encapsulated because methods of the class do not leak references 
    to the instance or to any other object transitively referenced by the 
    instance.  Specifically, every non-<code>static</code> method and constructor
    must be annotated with <code>@Borrowed("this")</code> to indicate that
    the instance will not be aliased (leaked), and every field must be of a 
    primitive type or type annotated with <code>@Containable</code>.
    </para>
    
    <para>We can build a thread-safe, containable, mutable rectangle class out of a
    containable point class:
    
      <programlisting>
 @Containable
 public class Point {
   private int x;
   private int y;
 
   @Unique("return")
   @RegionEffects("none")
   public Point(int x, int y) {
     this.x = x;
     this.y = y;
   }
 
   @Borrowed("this")
   @RegionEffects("writes Instance")
   public void translate(int dx, int dy) {
     x += dx;
     y += dy;
   }
 }
 
 @Containable
 @ThreadSafe
 @RegionLock("Lock is this protects Instance")
 public class Rectangle {
   @Unique
   private final Point topLeft;
 
   @Unique
   private final Point bottomRight;
 
   @Unique("return")
   public Rectangle(int x1, int y1, int x2, int y2) {
     topLeft = new Point(x1, y1);
     bottomRight = new Point(x2, y2);
   }
 
   @Borrowed("this")
   @RegionEffects("writes Instance")
   public synchronized void translate(int dx, int dy) {
     topLeft.translate(dx, dy);
     bottomRight.translate(dx, dy);
   }
 }
      </programlisting>
    </para>
  </sect2>
</sect1>
