<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect2 id="sec-tutorial-android" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Running Flashlight with Android</title>

  <para>The following tutorial is intended to get you up and running with
  Android.  You can try this on your Android smartphone or tablet if you have
  one.  If you don't, you can still do this tutorial using the emulator provided
  by Google's Android Development Tools (ADT).  If you do not have the Android
  SDK and ADT installed, you should do so at this time by following the
  instructions at <link
  xlink:href="http://developer.android.com/sdk/installing.html">here</link>.
  Once you have installed ADT in Eclipse, go ahead and add the
  <application>Counter Race</application> tutorial to your workspace.  You can
  do this by Choosing <menuchoice><guimenu>Flashlight</guimenu><guimenuitem>Run
  Flashlight Tutorials</guimenuitem></menuchoice>.  Make sure that
  <application>FlashlightTutorial_CounterRace</application> is checked and click
  OK.  If you have an Android device connected to your computer by USB,
  <application>Counter Race</application> will likely launch on your device.  If
  you don't, then you will need to set up an emulator.  See Android's
  documentation on <link
  xlink:href="http://developer.android.com/tools/devices/index.html">Managing
  Virtual Devices</link> to set this up.</para>

  <para><application>Counter Race</application> is a simple program we developed
  to demonstrate that, despite being less powerful than today's generation of
  desktop processors, concurrency remains an issue that must be dealt with
  correctly on Android devices.  <application>Counter Race</application>
  demonstrates this by running several threads, all of which increment two
  shared counters.  The first counter is a static field that is incremented
  without any protection from locking or the volatile keyword.  The second
  counter is implemented as a collection of thread-local counters.  When the
  user checks a box, several threads are spawned.  Each thread increments both
  the static counter and its own thread-local counter.  Once the box is
  unchecked and the threads finish, the values of the thread-local counters are
  safely added up and presented as the total count.  This count is compared to
  the value of the static counter and the results are displayed to the user.
  We'll go ahead and demonstrate this by running the program with Flashlight
  now.  Right-click on the project and choose <menuchoice><guimenu>Flashlight
  As</guimenu><guimenuitem>Android
  Application</guimenuitem></menuchoice>.</para>

  <figure id="fig-tutorial-android-launch">
    <title>Launching Counter Race</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-launch.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>If you are using an emulator, the emulator will take a while to start
  up.  Once <application>Counter Race</application> has been deployed on the
  phone, the application should launch automatically.  You should see the
  following:</para>
  <figure id="fig-tutorial-android-phone-1">
    <title>The Counter Race application</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-phone-1.png" />
      </imageobject>
    </mediaobject>
  </figure>
  
  <para>To start the threads, tap the checkbox once.  After allowing it to run
  for a few seconds, you can tap the checkbox again to see the results.  Your
  results should look something like this:</para>

  <figure id="fig-tutorial-android-phone-2">
    <title>Tap the checkbox to start and stop the counters</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-phone-2.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Once you have exercised the program, you can go ahead and stop it in
  order to look at your data.  Pressing the <guilabel>Home</guilabel> or
  <guilabel>Back</guilabel> buttons on your phone will close the
  <application>Counter Race</application> application, but most devices will
  keep the process running in the background.  In order to stop the
  instrumentation so that we can collect our data, we can do one of two things:
  connect to the runtime monitor and stop the instrumentation, or manually stop
  the background process.  For the purposes of this tutorial, we will do the
  latter.  On your device or emulator open up the running applications tab by
  choosing
  <menuchoice><guimenu>Applications</guimenu><guimenuitem>Settings</guimenuitem><guimenuitem>Apps</guimenuitem></menuchoice>
  and selecting the <guilabel>Running</guilabel> tab.  You will likely need to
  click on <guilabel>Show cached processes</guilabel> as well, if your version
  of the phone has this option.  Then navigate through the list of processes
  until you find Counter Race.  Select Counter Race, and then click
  <guilabel>Stop</guilabel> to terminate the running process.</para>
  <figure id="fig-tutorial-android-phone-3">
    <title>The cached Counter Race process</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-phone-3.png" />
      </imageobject>
    </mediaobject>
  </figure>
  <figure id="fig-tutorial-android-phone-4">
    <title>Stopping the background process.</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-phone-4.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Once you terminate the running process, a notification window should pop
  up asking if you want to switch to the Flashlight perspective and if you would
  like to prep the run.  Go ahead and prep the run now.  Once you do so, you
  should have access to the Run Overview.  Clicking on the <guilabel>Race
  Conditions</guilabel> tab, we can see that we have detected potential race
  conditions on two fields: <structfield>f_sharedCounter</structfield> and
  <structfield>f_threadLocalCounts</structfield>.  Note that by clicking on the
  fields in the overview, we see that neither field was accessed when any locks
  where held in the program, so we know that neither field was protected by any
  sort of locking strategy.</para>
  
  <figure id="fig-tutorial-android-raceconditions">
    <title>Potential Race Conditions in CounterRace</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-raceconditions.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>We will look at f_sharedCounter first.  Clicking on
  <structfield>f_sharedCounter</structfield>, we can see from the source code
  that it is a static, non-volatile field in the
  <classname>CounterThread</classname> class.  To investigate this further,
  double click on <emphasis>What fields (static) have an empty lock
  set?</emphasis> in the <guilabel>Query Menu</guilabel>.  The <guilabel>Query
  Results</guilabel> view should display one such field -
  <structfield>f_sharedCounter</structfield>.</para>

  <figure id="fig-tutorial-android-sharedcounter-1">
    <title>Looking at f_sharedCounter</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-sharedcounter-1.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Click on <structfield>f_sharedCounter</structfield> and run
  <emphasis>What threads read and write this field?</emphasis> from the
  <guilabel>Query Menu</guilabel>.  The results should resemble the figure
  below:</para>

  <figure id="fig-tutorial-android-sharedcounter-2">
    <title>What threads read and write f_sharedCounter?</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-sharedcounter-2.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>We can see from the above query that f_sharedCounter is indeed read from
  and written to by multiple threads.  From this and our knowledge of the
  program, we can convince our self that there is a race condition on
  <structfield>f_sharedCounter</structfield>.  The detected race condition on
  <structfield>f_sharedCounter</structfield> was expected, however.  What was
  not expected was a detected race condition on
  <structfield>f_threadLocalCounts</structfield>.  What might be going on?  Get
  ready to start a new line of inquiry by clearing the results out of the
  <guilabel>Query Results Explorer</guilabel> view, or just click on the run of
  <application>Counter Race</application> in the <guilabel>Flashlight
  Runs</guilabel> view to return the <guilabel>Query Menu</guilabel> to the top
  level menu.  Now double click on <emphasis>What fields (non-static) have an
  empty lock set after object construction?</emphasis> in the <guilabel>Query
  Menu</guilabel>.  The <guilabel>Query Results</guilabel> view should display
  the <structfield>f_threadLocalCounts</structfield> field.</para>

  <figure id="fig-tutorial-android-threadlocal-1">
    <title>Looking at f_threadLocalCounts</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-threadlocal-1.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>There should be four instances of
  <structfield>f_threadLocalCounts</structfield> in the program &mdash; one for
  each counter thread.  Select <structfield>f_threadLocalCounts</structfield>
  and run <emphasis>What instances of this field have an empty lock
  set?</emphasis></para>
  <figure id="fig-tutorial-android-threadlocal-2">
    <title>Four instances of f_threadLocalCounts</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-threadlocal-2.png" />
      </imageobject>
    </mediaobject>
  </figure>
  
  <para>Now select an instances of
  <structfield>f_threadLocalCounts</structfield> for us to investigate more
  closely and run <emphasis>What threads read and write
  this field?</emphasis>
  </para>
  <figure id="fig-tutorial-android-threadlocal-4">
    <title>What threads read and write f_threadLocalCounts</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-threadlocal-5.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>We can see that all but one access of
  <structfield>f_threadLocalCounts</structfield> is in the counter thread, as
  should be the case for a thread confined field.  In our case, the counter
  thread is Thread-1940.  There is one access made from the main thread while
  the object is under construction, however.  It is common for fields that are
  thread confined, such as <structfield>f_threadLocalCounts</structfield>, to be
  written to during construction in a parent thread, but subsequently accessed
  solely by another thread created by that parent.  As long as a happens-before
  relationship is established between the parent thread and its child thread on
  creation, this is thread-safe.  Flashlight cannot detect this happens-before
  relationship yet, so the best we can do is verify for our self that it exists.
  Let's do that by taking a look at where in the main thread
  <structfield>f_threadLocalCounts</structfield> is initialized.  Start by
  running <emphasis>When and by what threads was this field
  accessed?</emphasis></para>

  <figure id="fig-tutorial-android-threadlocal-3">
    <title>When and by what threads was f_threadLocalCounts accessed?</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-threadlocal-3.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>Here we can see that the write to
  <structfield>f_threadLocalcounts</structfield> by the main thread was the very
  access of the field.  Go ahead and select it, then run <emphasis>What is the
  stack trace for this access?</emphasis> 
  </para>

  <figure id="fig-tutorial-android-threadlocal-4">
    <title>What is the stack trace for this access?</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-threadlocal-4.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>We can see from the figure above that
  <structfield>f_threadLocalCounts</structfield> is written to during the
  construction of <classname>CounterThread</classname>.  If we click on the
  middle row, where the <methodname>go</methodname> method of class
  <classname>CounterRaceActivity</classname> is called, we jump to that line of
  code in the source code and can see the context where
  <classname>CounterThread</classname> is initialized.  Following along with the
  code, we can see that all of the <classname>CounterThread</classname> objects
  are constructed first, then started from the main thread.  When
  <methodname>Thread.start</methodname> is called, a happens-before relationship
  is created between the main thread and the counter threads.  Because we can
  see that there is a happens-before relationship in between the write to
  <structfield>f_threadLocalCounts</structfield> from the main thread and the
  read/writes occurring in the counter thread, we can be satisfied that there is
  no race condition here.  This concludes the Android tutorial.</para>

  <figure id="fig-tutorial-android-threadlocal-6">
    <title>Initialization of <structfield>f_threadLocalCounts</structfield> in
    <classname>CounterRaceActivity</classname></title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-android-threadlocal-6.png" />
      </imageobject>
    </mediaobject>
  </figure>

</sect2>
