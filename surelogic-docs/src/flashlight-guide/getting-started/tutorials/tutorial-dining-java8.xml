<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<section id="sec-tutorial-dining-java8">
  <title>Using Flashlight on a troubled dining philosophers implementation (Java 8)</title>
  
  <para>
    This tutorial explores a small program based on the classic <ulink
    url="http://en.wikipedia.org/wiki/Dining_philosophers">Dining
    Philosophers</ulink> problem. The program models the following scenario:
    Five philosophers sit down at a table.  Five plates are layed out, one in
    front of each philosopher. Five forks are set down, one between each plate.
    A bowl of spaghetti sits in the middle. While dinner takes place, each
    philosopher alternates between states of thinking or eating.  They must
    acquire the two forks on either side of their plate to eat from the bowl of
    spaghetti, and after eating they relinquish their forks to think again. The
    philosophers never speak to each other.
  </para>
  <para>
    The program represents each philosopher as a separate thread, and the forks
    are java.util.concurrent locks. A philosopher must acquire a lock on both
    nearby forks in order to eat.  The source code for the
    <classname>Philosopher</classname> enum and main method of
    <classname>DiningPhilosophers</classname> is displayed below.  We create
    five forks, and assign two forks to each dining philosopher to serve as the
    fork on their left and right.  The first philosopher, Kant, Will have forks
    0 and 1, Diogenes will have 1 and 2, and this goes on until we reach
    Russell, who has forks 4 and 0.
  </para>

  <programlisting>
<![CDATA[
	enum Philosopher {
		Kant, Diogenes, Descartes, Goethe, Russell;
		private static final Lock[] forks;

		/*
		 * Create one fork for every philosopher, the fork to the philosopher's
		 * left has the same ordinal as the philosopher.
		 */
		static {
			forks = new Lock[values().length];
			for (Philosopher p : values()) {
				forks[p.ordinal()] = new ReentrantLock();
			}
		}

]]>
  </programlisting>
  <programlisting>
<![CDATA[
	/**
	 * Create an instance of DiningPhilosophers and start it. Terminate the
	 * program after running it for half a minute.
	 */
	public static void main(String[] args) {
		DiningPhilosophers d = new DiningPhilosophers();
		d.startEating(DiningPhilosophers::leftThenRightPhilosopher);
		try {
			Thread.sleep(30000);
		} catch (final InterruptedException e) {
			// Do nothing
		}
		System.exit(0);
	}

	/**
	 * Start a thread for each philosopher that attempts to execute the given
	 * strategy
	 *
	 * @param strategy
	 */
	void startEating(PhilosopherStrategy strategy) {
		Philosopher[] philosophers = Philosopher.values();
		for (Philosopher phil : philosophers) {
			strategy.startThread(phil);
		}
	}
]]>
  </programlisting>

  <para>
    The <classname>PhilosopherStrategy</classname> itself is just a functional
    interface, any valid lambda expression that takes a
    <classname>Philosopher</classname> as its sole parameter can serve as an
    implementation.  The implementation itself is expected to acquire both forks
    in some fashion, "eat", and then relinquish said forks.
  </para>

  <programlisting>
<![CDATA[

	/**
	 * A functional interface that takes a {@link Philosopher}. The
	 * implementation of eat should attempt to acquire both locks.
	 *
	 * @author nathan
	 *
	 */
	interface PhilosopherStrategy {
		void eat(Philosopher philosopher) throws InterruptedException;

		default Thread startThread(Philosopher phil) {
			Thread thread = new Thread(() -> {
				for (;;) {
					try {
						eat(phil);
					} catch (InterruptedException e) {
						// Do nothing
					}
			}
		}, phil.toString());
			thread.start();
			return thread;
		}
	}
]]>
  </programlisting>
  <para>
    The fork itself is a straightforward re-entrant lock.  The
    <classname>Fork</classname> class is used by several of our strategies, it
    implements <classname>Autocloseable</classname> in order to make fork
    acquisition in our strategies less error-prone.
  </para>
  <programlisting>
<![CDATA[
	/**
	 * An {@link AutoCloseable} wrapper around a lock, this represents a fork
	 * held by a philosopher.
	 *
	 * @author nathan
	 *
	 */
	static class Fork implements AutoCloseable {
		private final Lock lock;

		Fork(Lock lock) {
			this.lock = lock;
			lock.lock();
		}

		@Override
		public void close() {
			lock.unlock();
		}

	}
]]>
  </programlisting>

  <para>
    The first implementation of our philosopher is
    <methodname>leftThenRightPhilosopher</methodname>. With this strategy, each
    philosopher will try to acquire the fork on their left (in the case of Kant
    this would be fork 0) and then the fork on their right.  Once they have two
    forks, they may eat.
  </para>

  <programlisting>
<![CDATA[
	/**
	 * This philosopher always attempts to take the fork on their left, and then
	 * the fork on their right.
	 *
	 *
	 */
	static void leftThenRightPhilosopher(Philosopher phil)
			throws InterruptedException {
		System.out.printf("%s is thinking.\n", phil);
		Thread.sleep(1000);
		try (Fork left = phil.acquireLeftFork()) {
			System.out.printf("%s picks up the left fork.\n", phil);
			Thread.sleep(1000);
			try (Fork right = phil.acquireRightFork()) {
				System.out.printf("%s picks up the right fork.\n", phil);
				Thread.sleep(1000);
				System.out.printf("%s is eating.\n", phil);
				Thread.sleep(1000);
			}
		}
	}
]]>
  </programlisting>

  <para>
    Let's go ahead and run this and see what we get.  Right click on the
    <classname>DiningPhilosophers</classname> class in the <guilabel>Package
    Explorer</guilabel> and choose <menuchoice><guisubmenu>Flashlight
    As</guisubmenu>
    <guimenuitem>Java Application</guimenuitem></menuchoice>.  The output of the
    program in the <guilabel>Console</guilabel> should appear as shown below.
    After thirty seconds the program will terminate and Flashlight will prep the
    run. If you don't want to wait thirty seconds you can press the
    <guilabel>Stop</guilabel> button in the console once you see the output below.
  </para>
  <programlisting>
<![CDATA[
Kant is thinking.
Descartes is thinking.
Diogenes is thinking.
Goethe is thinking.
Russell is thinking.
Diogenes picks up the left fork.
Descartes picks up the left fork.
Goethe picks up the left fork.
Russell picks up the left fork.
Kant picks up the left fork.
]]>
  </programlisting>

  <para>
    This doesn't look good.  It appears that every philosopher picked up the
    fork on their left, and then no one was able to eat!  Now that the run has
    terminated, Flashlight will prepare it for inspection and we can see what
    went wrong.  Switch to the Flashlight perspective now if you have not been
    prompted to do so already, and select the
    <classname>DiningPhilosophers</classname> run in the <guilabel>Flashlight
    Runs</guilabel> view.  You should see one article of bad news in the
    <guilabel>Query Results</guilabel> view.
  </para>

  <figure id="fig-tutorial-dining-java8-news">
    <title>Bad News in DiningPhilosophers</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-dining-java8-news.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>
    Go ahead and click on the <emphasis>Lock cycles were observed that could
    cause the program to deadlock</emphasis> link.  You should see one lock cycle displayed, as shown in  <xref
    linkend="fig-tutorial-dining-java8-what-lock-cycles" />. As expected the cycle involves five locks&mdash;one for each fork.</para>
    

  <figure id="fig-tutorial-dining-java8-what-lock-cycles">
    <title>What lock cycles could potentially cause deadlock?</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-dining-java8-what-lock-cycles.png" />
      </imageobject>
    </mediaobject>
  </figure>
    
    <para>Double click on this entry and a lock graph will be
    displayed that should look something like <xref linkend="fig-tutorial-dining-java8-what-are-the-edges"/>.  Every node in this
    graph is a lock in the program.  In this case that means the five
    <classname>Fork</classname> objects that we created.  Each edge represents a
    time in the program that we held the lock at the source of the edge and
    tried to acquire the lock at the edge's destination. You can manipulate the graph by clicking and dragging nodes
  if the layout is cluttered. You can also move the whole graph by clicking and dragging on the background
   of the graph.
  </para>


  <figure id="fig-tutorial-dining-java8-what-are-the-edges">
    <title>What are the edges for this lock cycle?</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-dining-java8-what-are-the-edges.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>
    From the graph it is clear what happened.  Each philosopher attempted to
    acquire the lock on their left, and then tried to acquire a lock that was
    already held by someone else by the person on their right.  So Kant needed
    the lock held by Diogenes, who needed the lock held by Descartes, and on to
    Goethe, then Russell, who closed the loop by needing the lock held by Kant.
  </para>

  <para>
    Now that we have seen that <methodname>leftThenRightPhilosopher</methodname>
    leads to deadlock, we can try to fix this by using a different
    implementation.  The typical first approach to fixing a deadlock scenario is
    to choose a global ordering of all locks in the program, and then
    <emphasis>always</emphasis> acquire locks in that order.  Recall that each
    fork has an ordinal value, based on their position in the
    <structfield>forks</structfield> array of the
    <classname>Philosopher</classname> enum.  We're going to take advantage of
    that fact to construct a philosopher that always acquires the lowest
    numbered lock first.  The <methodname>orderedPhilosopher</methodname>
    strategy, displayed below, does just that.
  </para>

  <programlisting>
<![CDATA[
	/**
	 * A common strategy to prevent deadlock is to assign every lock an ordinal
	 * value, then always acquire locks from lowest to highest. In our example
	 * we assume each fork is assigned an ordinal value, such that the first
	 * philosopher's left and right forks would be 0 and 1 respectively, the
	 * second philosopher 1 and 2. This continues up until the final
	 * philosopher, who around a table with n philosophers would have forks
	 * (n-1) and 0.
	 *
	 * This allows us to use a consistent locking order by always locking the
	 * lowest numbered fork. For every philosopher but the final one this is
	 * just the left fork. For the final philosopher, however, it is the right
	 * fork.
	 *
	 */
	static void orderedPhilosopher(Philosopher phil)
			throws InterruptedException {
		boolean leftFirst = phil.ordinal() != Philosopher.values().length - 1;
		System.out.printf("%s is thinking.\n", phil);
		Thread.sleep(1000);
		try (Fork first = leftFirst ? phil.acquireLeftFork() : phil
				.acquireRightFork()) {
			System.out.printf("%s picks up the %s fork.\n", phil,
					leftFirst ? "left" : "right");
			Thread.sleep(1000);
			try (Fork second = leftFirst ? phil.acquireRightFork() : phil
					.acquireLeftFork()) {
				System.out.printf("%s picks up the %s fork.\n", phil,
						leftFirst ? "right" : "left");
				Thread.sleep(1000);
				System.out.printf("%s is eating.\n", phil);
				Thread.sleep(1000);
			}
		}
	}
]]>
  </programlisting>

  <para>
    Change the main method of DiningPhilosophers to use the <methodname>orderedPhilosopher</methodname>
    implementation as shown below.
  </para>

  <programlisting>
<![CDATA[
	/**
	 * Create an instance of DiningPhilosophers and start it. Terminate the
	 * program after running it for half a minute.
	 */
	public static void main(String[] args) {
		DiningPhilosophers d = new DiningPhilosophers();
		d.startEating(DiningPhilosophers::orderedPhilosopher);
		try {
			Thread.sleep(30000);
		} catch (final InterruptedException e) {
			// Do nothing
		}
		System.exit(0);
	}
]]>
  </programlisting>

  <para>
    Now go ahead and run the program again by right clicking on <classname>DiningPhilosophers</classname> in the <guilabel>Package
    Explorer</guilabel> and choosing <menuchoice><guisubmenu>Flashlight As</guisubmenu>
    <guimenuitem>Java Application</guimenuitem></menuchoice>.  You should see
    quite a bit more output from the program this time.  Your run will be different, but will probably look something like this:
  </para>

  <programlisting>
<![CDATA[
Kant is thinking.
Russell is thinking.
Goethe is thinking.
Descartes is thinking.
Diogenes is thinking.
Russell picks up the right fork.
Diogenes picks up the left fork.
Goethe picks up the left fork.
Descartes picks up the left fork.
Russell picks up the left fork.
Russell is eating.
Russell is thinking.
Kant picks up the left fork.
Goethe picks up the right fork.
Goethe is eating.
Goethe is thinking.
Descartes picks up the right fork.
Descartes is eating.
Descartes is thinking.
Diogenes picks up the right fork.
...
]]>
  </programlisting>

  <para>
    Once the run has completed and prepped, we can see in the overview that the
    program no longer has any potential for deadlock.
  </para>
  <figure id="fig-tutorial-dining-java8-no-news">
    <title>OrderedPhilosopher does not cause deadlock</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/tutorial-dining-java8-no-news.png" />
      </imageobject>
    </mediaobject>
  </figure>

  <para>
    This completes the tutorial.
  </para>


</section>

