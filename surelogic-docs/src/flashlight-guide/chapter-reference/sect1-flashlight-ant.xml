<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../lib/docbook-xml-4.5/docbookx.dtd">

<section id="flashlight-ant-tasks"  xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Flashlight Ant tasks</title>

  <para>Flashlight-related ANT tasks are declared in the JAR file
  flashlight-ant.jar. </para>
  <section><title>Loading Flashlight tasks into Ant</title>

  <para>The JAR file flashlight-ant.jar contains an antlib.xml file located at
  com/surelogic/flashlight/ant/antlib.xml. The best way to load the Flashlight
  ANT tasks into ANT and into their own namespace is to use the ANT
  &lt;taskdef&gt; tag:</para>

  <programlisting>
<![CDATA[
<?xml version="1.0" encoding="ISO-8859-1"?>
<project ... xmlns:flashlight="antlib:com.surelogic.flashlight.ant">
    <taskdef uri="antlib:com.surelogic.flashlight.ant"
    		resource="com/surelogic/flashlight/ant/antlib.xml"
    		classpath="path/to/flashlight-ant.jar"/>
    ...
]]>
  </programlisting>
  <para>
    The flashlight tasks can now be referred to using the the task names
    &lt;flashlight:taskname&gt;.
  </para>
  </section>
  <section>
    <title>Flashlight Ant task: instrument</title>
    <para>Rewrite a set of classfiles to contain Flashlight instrumentation. The
    instrument task can</para>
    <itemizedlist>
      <listitem>Rewrite the classfiles found in a particular directory
      hierarchy, writing the instrumented classfiles to another directory. This
      is declared using a <link linkend="instrument-task-dir">nested
      <code>&lt;dir srcdir=... destdir=.../&gt;</code> element</link>, or a
      <link linkend="instrument-task-dirs">nested <code>&lt;dirs .../&gt;</code>
      element.</link></listitem>
      <listitem>Rewrite the classfiles found in a particular directory
      hierarchy, writing the instrumented classfiles to JAR file. This is
      declared using a <link linkend="instrument-task-dir">nested <code>&lt;dir
      srcdir=... destdir=.../&gt;</code> element</link>, or a <link
      linkend="instrument-task-dirs">nested <code>&lt;dirs .../&gt;</code>
      element.</link></listitem>
      <listitem>Rewrite the classfiles found in a particular JAR file, writing
      the instrumented classfiles to a new JAR file. This is declared using a
      <link linkend="instrument-task-jar">nested <code>&lt;jar
      srcfile=... destdir=.../&gt;</code> element</link> or a <link
      linkend="instrument-task-jars">nested <code>&lt;jars .../&gt;</code>
      element.</link></listitem>
      <listitem>Rewrite the classfiles found in a particular JAR file, writing
      the instrumented classfiles to a directory. This is declared using a <link
      linkend="instrument-task-jar">nested <code>&lt;jar
      srcfile=... destdir=.../&gt;</code> element</link> or a <link
      linkend="instrument-task-jars">nested <code>&lt;jars .../&gt;</code>
      element</link>.</listitem>
    </itemizedlist>
    <para>In all cases, any files that are not classfiles (that do not
    end in <code>.class</code>) are copied unchanged.</para>
    <para>To execute the rewritten classes, the Flashlight runtime
    flashlight-runtime.jar needs to be on the classpath. When rewriting a JAR
    file, or creating a JAR file from a directory, by default, the manifest file
    is updated so that the Class-Path attribute includes a reference to this
    file.</para>
    <para>The task needs to know the complete classpath of the application being
    instrumented. The element libraries is used for specifying any classfile
    directories and JAR files that are not instrumented, but that are required
    by the application. In extreme cases the elements bootclasspath and extdirs
    may also be used to specify additional libraries that make up the complete
    application. See <link linkend="instrument-task-classpath">below</link> for
    more information.</para>
    <section>
      <title>Attributes</title>
      <para>In normal usage, there are three required attributes</para>
      <informaltable>
        <tgroup cols='3'>
          <colspec colname='c1' align='left'/>
          <colspec colname='c2' align='left'/>
          <colspec colname='c3' align='left'/>
          <thead>
            <row>
              <entry>Attribute</entry>
              <entry>Default Value</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>fieldsFile</entry>
              <entry>none</entry>
              <entry>The name of the file to write the fields database to. This
              file must be given to the flashlight data analysis along with the
              file generated by running an instrumented program.</entry>
            </row>
            <row>
              <entry>sitesFile</entry>
              <entry>none</entry>
              <entry>The name of the file to write the program sites database
              to. This file must be given to the flashlight data analysis along
              with the file generated by running an instrumented
              program.</entry>
            </row>
            <row>
              <entry>logFile</entry>
              <entry>none</entry>
              <entry>The name of the file to write the instrumentation activity
              log. This file is purely informative.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section>
      <title>Nested Elements</title> 
      <para>The classfiles to be rewritten are declared using nested
      <code>dir</code> and <code>jar</code> elements. Any number and combination
      of dir and jar elements may appear inside an instrument task.</para>
      <formalpara id="instrument-task-dir">
        <title>Dir</title>
        <programlisting><![CDATA[
<dir srcdir=... destdir=... [jar=... [runtime=...]]/>
        ]]></programlisting>
        <para>The <code>dir</code> element is used to declare a directory of
        classfiles to be rewritten. The source directory must be specified using
        the srcdir attribute. The jar attribute defaults to "false", and
        indicates whether the classfiles in the directory should be written to a
        new JAR file. When <code>jar</code> is <code>false</code>, the directory
        is rewritten to the directory named by the destdir attribute. When jar
        is true, the directory is rewritten to a new JAR file in the directory
        named by <code>destdir</code>. The name of the JAR file is taken from
        the name of the last directory in <code>srcdir</code>.</para>
        <itemizedlist>
          <listitem>All classfiles (those files ending in .class) are rewritten
          as specified by the outer code <code>instrument</code>
          task.</listitem>
          <listitem>All other files are copied unchanged.</listitem>
        </itemizedlist>
        <para>When creating a JAR file, the manifest file
        <code>META-INF/MANIFEST.MF</code> of the new JAR file is given a
        <code>Class-Path</code> attribute. By default, the manifest file will be
        updated to include a reference to
        <code>flashlight-runtime.jar</code>. This is not always desirable
        because the JAR file class path resolution system is flaky, you may want
        to use <code>flashlight-all.jar</code> for some reason, you may want to
        specify a path component to the JAR file, you may have bundled the
        run-time classes into a different jar, etc. You can specify the name of
        the flashlight run-time to add to the class path by setting the
        <code>runtime</code> attribute.</para>
      </formalpara>
      <formalpara id="instrument-task-dirs">
        <title>Dirs</title>
        <programlisting><![CDATA[
<dirs list=... delimiters=... srcdirpattern=... destdirpattern=... replace=.../>
<dirs list=... delimiters=... srcdirpattern=... destfilepattern=... replace=.../>
        ]]></programlisting>
        <para>The <code>dirs</code> element is used to a declare a set of
        directories of classfiles to be rewritten, by iterating over the
        contents of the <code>list</code> attribute. In particular, a
        <code>java.util.StringTokenizer</code> is used to iterate over the value
        of <code>list</code>, using the value of the delimiters attribute to
        control the token delimiters. The token is substituted into the value of
        <code>srcdirpattern</code>, <code>destdirpattern</code>, and
        <code>destfilepattern</code> wherever the value of <code>replace</code>
        occurs. One <code>dir</code> element is generated for each token in the
        value of <code>list</code>.</para>
      </formalpara>
      <para>To rewrite the directories to new directories, use the
      <code>destdirpattern</code> attribute. To rewrite the directories to new
      JAR files, use the <code>destfilepattern</code> attribute. One but not
      both of these attributes must appear. When using the
      <code>destfilepattern</code> attribute, you may also use the
      <code>runtime</code> attribute to set the name of the Flashlight run-time
      JAR file.</para>
      <para>The default value of the <code>delimiters</code> attribute is
      ",".</para>
      <para>Be aware that the substitution performed with the
      <code>replace</code> pattern is very stupid. If the value of the
      <code>replace</code> attribute appears more than once in a pattern it will
      be replaced more than once. Also, you should make sure that the pattern
      does not appear in any of the values of any other properties used to
      construct the value of the source or destination pattern. That is, if
      <code>srcdirpattern</code> is "<code>${workspace}/FOO/bin</code>", replace
      is "<code>FOO</code>", and <code>workspace</code> is
      "<code>/Users/fred/FOOBAR Workspace</code>", then the results will
      probably not be what the user expects because the "FOO" in "FOOBAR" will
      be replaced as well as the "FOO" in the pattern.</para>
      <para>The purpose of the <code>dirs</code> element is to allow the list of
      directories that are to be instrumented to be specified by the value of an
      ANT property. This property could list the name of Java projects in an
      Eclipse workspace, for example. See the examples below for more
      detail. This is useful, for example, when the list of directories is also
      used to drive other ANT tasks, such as cleanup or installation.</para>

      <formalpara id="instrument-task-jar">
        <title>Jar</title>        
        <programlisting><![CDATA[
<jar srcfile=... destdir=... [updatemanifest=...] [runtime=...] [unjar=...]/>
        ]]></programlisting>
        <para>The <code>jar</code> element is used to declare a JAR file to be
        rewritten. The source file must be specified using the
        <code>srcfile</code> attribute. The <code>unjar</code> attribute
        defaults to <code>false</code> and indicates whether the contents of the
        JAR file should be expanded into the destination directory or not. When
        <code>unjar</code> is <code>false</code>, the JAR file is rewritten to a
        new JAR file of the same name in <code>destdir</code>. When the
        <code>unjar</code> is <code>true</code> the contents of the JAR file are
        rewritten to the directory named by the <code>destdir</code>. The JAR
        file is rewritten as follows:</para>
        <itemizedlist>
          <listitem>All classfiles (those files ending in <code>.class</code>)
          are rewritten as specified by the outer instrument task.</listitem>
          <listitem>The manifest file <code>META-INF/MANIFEST.MF</code> may be
          updated to include the Flashlight run-time JAR in the
          <code>Class-Path</code> attribute. By default, the manifest file will
          be updated to include a reference to
          <code>flashlight-runtime.jar</code>. This is not always desirable
          because the JAR file class path resolution system is flaky, you may
          want to use <code>flashlight-all.jar</code> for some reason, you may
          want to specify a path component to the JAR file, you may have bundled
          the run-time classes into a different jar, etc. You can disable
          modification of the manifest file by setting the
          <code>updatemanifest</code> attribute to
          <code>false</code>. Alternatively, you can specify the name of the
          flashlight run-time to add to the class path by setting the
          <code>runtime</code> attribute.</listitem>
          <listitem>All other files are copied unchanged.</listitem>
        </itemizedlist>
      </formalpara>
      <formalpara id="instrument-task-jars">
        <title>Jars</title>
        <programlisting><![CDATA[
<jars srcdir=... destdir=... [recurse=...] [extensions=...] [updatemanifest=...] [runtime=...] [unjar=...]/>
        ]]></programlisting>
        <para>The jars element is used to declare a directory of jar files to be
        rewritten. The source directory must be specified using the srcdir
        attribute. Each file in the directory ending with an extension declared
        in the extensions attribute is considered to be a JAR file. Be default,
        directories are recursively scanned; this can be disabled by setting
        unjar to false. The results are written to the directory declared in
        destdir. If unjar is false, the default, then each JAR file is written
        to an new JAR file of the same name in the destination directory. When
        searching recursively, the nested directory structure is preserved. When
        jar is true the contents of each JAR are rewritten to the directory
        declared in destdir; the nested directory structure is not
        preserved. Note, this also means all the META-INF directories in the JAR
        files are written on top of each other in the destination
        directory.</para>
        <itemizedlist>
          <listitem>The <code>updatemanifest</code> and
          <code>runtime</code> attributes are as in the <code>jar</code>
          element.</listitem>
          <listitem>The <code>extensions</code> attribute is a comma-separated
          list of extensions. The default value is <code>.jar,
          .class</code>. The extensions are matched on a case-insensitive
          basis. Specifically, the list is parse using a
          <code>java.lang.StringTokenizer</code> using a ", " as the set of
          delimiters.</listitem>
        </itemizedlist>
      </formalpara>
      <formalpara>
        <title>Filter</title>
        <programlisting><![CDATA[
<filter packages=.../>
        ]]></programlisting>
        <para>The <code>filter</code> element is used to declare a list of
        packages for the field access filtering. Package names are separated by
        commas or spaces. More than one filter element can be used. Thus</para>
        <programlisting><![CDATA[
<filter packages="com.foo.bar, com.foo.baz com.foo.biff"/>
        ]]></programlisting>
        <para>is the same as</para>
        <programlisting><![CDATA[
<filter packages="com.foo.bar com.foo.baz"/>
<filter packages="com.foo.biff"/>
        ]]></programlisting>
        <para>is the same as</para>
        <programlisting><![CDATA[
<filter packages="com.foo.bar"/>
<filter packages="com.foo.baz"/>
<filter packages="com.foo.biff"/>
        ]]></programlisting>
        <para>If you are naming only a single package, then you may use the
        package attribute instead of the <code>packages</code> attribute:</para>
        <programlisting><![CDATA[
<filter package="com.foo.bar"/>
<filter package="com.foo.baz"/>
<filter package="com.foo.biff"/>
        ]]></programlisting>
      </formalpara>
      <formalpara>
        <title>Blacklist</title>
        <programlisting><![CDATA[
<blacklist classes=.../>
        ]]></programlisting>
        <para>The <code>blacklist</code>. element is used to declare a list of
        classes that should not be instrumented. Class names are separated by
        commas or spaces. More than one blacklist element can be
        used. Thus</para>
        <programlisting><![CDATA[
<blacklist classes="com.foo.C1, com.foo.C2, com.foo.C3"/>
        ]]></programlisting>
        <para>is the same as</para>
        <programlisting><![CDATA[
<blacklist classes="com.foo.C1 com.foo.C2"/>
<blacklist classes="com.foo.C3"/>
        ]]></programlisting>
        <para>is the same as</para>
        <programlisting><![CDATA[
<blacklist classes="com.foo.C1"/>
<blacklist classes="com.foo.C2"/>
<blacklist classes="com.foo.C3"/>
        ]]></programlisting>
        <para>If you are naming only a single package, then you may use the
        <code>class</code> attribute instead of the <code>classes</code>
        attribute:</para>
        <programlisting><![CDATA[
<blacklist class="com.foo.C1"/>
<blacklist class="com.foo.C2"/>
<blacklist class="com.foo.C3"/>
        ]]></programlisting>
      </formalpara>
      <formalpara>
        <title>MethodFiles</title>
        <para>The <code>methodFiles</code> element is a <link
        xlink:href="http://ant.apache.org/manual/using.html#path">path-like
        structure</link> used to declare files containing additional definitions
        of methods that make indirect access to state aggregated into their
        arguments. All the elements of the path must exist and refer to
        files. <emphasis>.[The format of these files is described
        elsewhere.]</emphasis></para>
        <para>As a path-like structure, there is a lot of flexibility in how
        <code>methodFiles</code> can be used:</para>
        <programlisting><![CDATA[
<methodFiles>
    <pathelement path="lib/methods.xml:lib/moreMethods.xml"/>
    <pathelement location="../global/lib/globalMethods.xml"/>
</methodFiles>
        ]]></programlisting>
        <programlisting><![CDATA[
<methodFiles location="c:\library\moreInirectAccessMethods.xml"/>
        ]]></programlisting>
        <programlisting><![CDATA[
<path id="my.method.files">
    <pathelement location="lib/methods.xml"/>
    <pathelement location="lib/moreMethods.xml"/>
</path>
<methodFiles>
    <path refid="my.method.files"/>
</methodFiles>
        ]]></programlisting>
      </formalpara>
    </section>
    <section>
      <title>Examples</title>
      <para>Rewrite the classfiles found in the <code>input</code> directory,
      writing them to the <code>output</code> directory:</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <dir srcdir="input" destdir="output"/>
</flashlight:instrument>     
      ]]></programlisting>
      <para>Rewrite the classfiles found in the directories <code>input1</code>
      and <code>input2</code>, writing them to the JAR files
      <code>output/input1.jar</code>, and <code>output/input2.jar</code>,
      respectively:</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <dir srcdir="input1" destdir="output" jar="true"/>
    <dir srcdir="input2" destdir="output" jar="true"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Rewrite the classfiles found in the JAR file <code>app.jar</code>,
      writing them to the new JAR file <code>instrumented/app.jar</code>. In
      this case the manifest file will be updated to refer to the
      <code>flashlight-runtime.jar</code>:</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <jar srcfile="app.jar" destdir="instrumented"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Rewrite the classfiles found in the JAR file <code>app.jar</code>,
      writing them to the directory <code>instrumented</code>. In this case the
      manifest file will be updated to refer to the
      <code>flashlight-runtime.jar</code>:</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <jar srcfile="app.jar" destdir="instrumented" unjar="true"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Rewrite the classfiles found in the JAR file <code>app.jar</code>,
      writing them to the new JAR file <code>instrumented/app.jar</code>, but do
      not modify the manifest file:</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <jar srcfile="app.jar" destdir="instrumented" updatemanifest="false"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Rewrite the classfiles found in the JAR file <code>app.jar</code>,
      writing them to the directory <code>instrumented</code>, and update the
      manifest file to refer to <code>flashlight-all.jar</code>:</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <jar srcfile="app.jar" destdir="instrumented" unjar="true" runtime="flashlight-all.jar"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Rewrite the classfiles found in the JAR file <code>app.jar</code>,
      writing them to the new JAR file
      <code>instrumented/app.jar</code>. Additionally rewrite all the classfiles
      found in the JAR files in the directory <code>lib</code> and write them to
      new JAR files in the directory <code>instrumented/lib</code>.</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <jar srcfile="app.jar" destdir="instrumented"/>
    <jars srcdir="lib" destdir="instrumented/lib"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Rewrite the classfiles found in the directories named by the
      property <code>projects</code>, all of which have similar subdirectories,
      and write the instrumented classfiles to new directories. Here we also
      assume that the <code>workspace</code> property has been set to the path
      of an Eclipse workspace.</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <dirs list="${projects}" replace="PROJECT"
        srcdirpattern="${workspace}/PROJECT/bin"
        destdirpattern="${workspace}/PROJECT/bin-instrumented"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>When <code>projects</code> is bound to <code>"project1 project2
      project3"</code>, and the value of workspace does not contain the
      substring <code>"PROJECT"</code>, the above is equivalent to</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <dir srcdir="${workspace}/project1/bin" destdir="${workspace}/project1/bin-instrumented"/>
    <dir srcdir="${workspace}/project2/bin" destdir="${workspace}/project2/bin-instrumented"/>
    <dir srcdir="${workspace}/project3/bin" destdir="${workspace}/project3/bin-instrumented"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Rewrite the classfiles found in the directories named by the
      property <code>projects</code>, all of which have similar subdirectories,
      and write the instrumented classfiles to JAR files. Here we also assume
      that the <code>workspace</code> property has been set to the path of an
      Eclipse workspace.</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <dirs list="${projects}" replace="PROJECT"
        srcdirpattern="${workspace}/PROJECT/bin"
        destfilepattern="${workspace}/PROJECT/instrumented/bin.jar"/>
</flashlight:instrument>       
      ]]></programlisting>
      <para>When <code>projects</code> is bound to <code>"project1 project2
      project3"</code>, and the value of <code>workspace</code> does not contain
      the substring <code>"PROJECT"</code>, the above is equivalent to</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <dir srcdir="${workspace}/project1/bin" destdir="${workspace}/project1/instrumented" jar="true"/>
    <dir srcdir="${workspace}/project2/bin" destdir="${workspace}/project2/instrumented" jar="true"/>
    <dir srcdir="${workspace}/project3/bin" destdir="${workspace}/project3/instrumented" jar="true"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Use additional indirect access method definitions.</para>
      <programlisting><![CDATA[
<flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log">
    <methodFile file="support/methods.xml"/>
    <methodFile file="support/global.xml"/>

    <jar srcfile="app.jar" destdir="instrumented"/>
</flashlight:instrument>      
      ]]></programlisting>
      <para>Only instrument field accesses to fields that are declared in
      classes in the packages "com.foo.util" and "com.foo.io".</para>
      <programlisting><![CDATA[
 <flashlight:instrument fieldsfile="fields.txt" sitesfile="sites.txt" logfile="instrumentation.log" fieldFilter="DECLARED">
    <filter package="com/foo/util"/>
    <filter package="com/foo/io"/>

    <jar srcfile="app.jar" destdir="instrumented"/>
</flashlight:instrument>     
      ]]></programlisting>
    </section>
  </section>
  <section>
    <title>Flashlight Ant task: instrument-archive</title>
    <para>This task cracks open an executable jar, ejb jar, or war file. It then
    instruments its contents and outputs a new archive file that can be dropped
    into any commonly used web server or, in the case of an executable jar, run
    from the command line.</para>
    <section>
      <title>Attributes</title>
      <informaltable>
        <tgroup cols='3'>
          <colspec colname='c1' align='left'/>
          <colspec colname='c2' align='left'/>
          <colspec colname='c3' align='left'/>
          <thead>
            <row>
              <entry>Attribute</entry>
              <entry>Default Value</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>destFile</entry>
              <entry>none</entry>
              <entry>The file to write the instrumented archive.</entry>
            </row>
            <row>
              <entry>srcFile</entry>
              <entry>none</entry>
              <entry>The archive file to instrument.</entry>
            </row>
            <row>
              <entry>name</entry>
              <entry>none</entry>
              <entry>A name for the Flashlight runs produced when this archive
              is executed or initialized by a web container.  This is to help
              identify runs in the Eclipse Client.</entry>
            </row>
            <row>
              <entry>runtime</entry>
              <entry>none</entry>
              <entry>The location of the Flashlight runtime jar.  This will be
              bundled into the instrumented version of the archive.</entry>
            </row>
            <row>
              <entry>dataDir</entry>
              <entry>none</entry>
              <entry>The location of the Flashlight data directory.  This
              directory will be used to store the results of any runs performed
              with the instrumented archive.</entry>
            </row>
            <row>
              <entry>properties</entry>
              <entry>none</entry>
              <entry>A file containing properties that should be made available
              to Flashlight at runtime.  Please note that if the
              <code>FL_RUN</code> or <code>FL_COLLECTION_TYPE</code> properties
              are set in this file, they will be overridden by the
              <code>collectionType</code> and <code>name</code>
              attributes.</entry>
            </row>
            <row>
              <entry>collectionType</entry>
              <entry>ALL</entry>
              <entry>One of ALL or ONLY_LOCKS.  If ONLY_LOCKS is specified, then
              Flashlight will only observer lock acquisitions.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section>
      <title>Nested Elements</title>
      <para>See <link linkend="instrument-task-classpath">Specifying the
      Complete Classpath</link> for details on how to specify archive
      dependencies that are provided by the archive's execution environment (for
      example the servlet api provided by a web container).</para>
      <formalpara>
        <title>Sources</title>
        <programlisting><![CDATA[
<sources path="..." />
        ]]></programlisting>
        <para>The <code>sources</code> element is a <link
        xlink:href="http://ant.apache.org/manual/using.html#path">path-like
        structure</link>.  Each member of the path should be a folder containing
        Java source code.  Everything in these folders will be stored in the
        instrumented archive, and will be available to the Historical Source
        View in the Eclipse client after a run has been prepped.</para>
      </formalpara>
    </section>
    <section>
      <title>Examples</title>
      <para>
        The following example instruments a Web Archive named
        <code>my.war</code>.  The instrumented version of the WAR is written to
        the file <code>instrumented.war</code>.  A folder named src contains
        source code matching the Java classes found in this archive.  When
        <code>instrumented.war</code> is loaded by a web server, data will be
        written to the directory specified by the
        <code>flashlight.dataDir</code> Ant property.
      </para>
      <programlisting><![CDATA[
<flashlight:instrument-archive srcFile="my.war" destfile="instrumented.war" runtime="${flashlight.dir}/flashlight-runtime.jar" dataDir="${flashlight.dataDir}">
    <sources path="src"/>
</flashlight:instrument>     
      ]]></programlisting>
    </section>
  </section>
  <section>
    <title>Flashlight Ant task: record</title>
    <para>Executes a java application in a manner similar to the <link
    xlink:href="http://ant.apache.org/manual/Tasks/java.html">Ant Java
    Task</link>.</para>
    <section>
      <title>Attributes</title>
      <informaltable>
        <tgroup cols='3'>
          <colspec colname='c1' align='left'/>
          <colspec colname='c2' align='left'/>
          <colspec colname='c3' align='left'/>
          <thead>
            <row>
              <entry>Attribute</entry>
              <entry>Default Value</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>dataDir</entry>
              <entry>none</entry>
              <entry>The Flashlight data directory.  When the program is run,
              all collected data will be placed in a new folder created under
              this one.</entry>
            </row>
            <row>
              <entry>name</entry>
              <entry>none</entry>
              <entry>The name of the run.  This is useful for identifying runs</entry>
            </row>
            <row>
              <entry>jar</entry>
              <entry>none</entry>
              <entry>The location of a jar to execute.  This jar must have a
              Main-Class entry in the manifest. Only one of jar or classname may
              be set.</entry>
            </row>
            <row>
              <entry>classname</entry>
              <entry>none</entry>
              <entry>The Java class to execute.  Only one of jar or classname
              may be set.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>
    <section>
      <title>Nested Elements</title> 
      <formalpara>
        <title>Inspect</title>
        <programlisting><![CDATA[
<inspect loc=... source=... />
        ]]></programlisting>
        <para>The <code>inspect</code> element is used to declare a directory or
        jar file to be instrumented.  The <code>loc</code> attribute is required
        and should be the location of a jar file or class folder.  The
        <code>source</code> element is optional and should be the location of a
        java source directory containing the source code used to build the jar
        or directory.</para>
      </formalpara>
    </section>
    <section>
      <title>Examples</title>
      <para></para>
    </section>
  </section>
  <section id="instrument-task-classpath">
    <title>Specifying the complete classpath</title>
    <para>The following elements are <link
    xlink:href="http://ant.apache.org/manual/using.html#path">path-like
    structures</link> used to specify additional members of the application's
    classpath.</para>
    <informaltable>
      <tgroup cols='3'>
        <colspec colname='c1' align='left'/>
        <colspec colname='c2' align='left'/>
        <colspec colname='c3' align='left'/>
        <thead>
          <row>
            <entry>Attribute</entry>
            <entry>Default Value</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>libraries</entry>
            <entry>empty</entry>
            <entry>A list of directories and JAR files containing classes used
            by the application that are not being instrumented.</entry>
          </row>
          <row>
            <entry>bootclasspath</entry>
            <entry>Derived from the JVM</entry>
            <entry>A list of JAR files that make up the application's expected
            boot classpath. It is an error if any of path elements are not
            files.</entry>
          </row>
          <row>
            <entry>extDirs</entry>
            <entry>Derived from the JVM</entry>
            <entry>A list of directories containing Java extension JAR files
            that are expected to be present by the application. It is an error
            if any of the path elements are not directories.</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>The task needs to know the complete classpath of the application being
    instrumented. That is, the set of classes specified by all the
    <code>jar</code>, <code>jars</code>, <code>dir</code>, <code>dirs</code>,
    <code>libraries</code>, <code>bootclasspath</code>, and <code>extDirs</code>
    elements must include all the classes that could possibly be referenced by
    the application. This sounds overwhelming at first, but keep the following
    in mind:</para>
    <itemizedlist>
      <listitem>Most likely you have already named all classes of your
      application in the <code>jar</code>, <code>jars</code>, <code>dir</code>,
      and <code>dirs</code> elements. Generally speaking, you want to instrument
      all the classes you have written for your application, plus those in
      3rd-party libraries used by the application.</listitem>
      <listitem>If for some reason you don't want to instrument a library used
      by the application, list it in the <code>libraries</code>
      element.</listitem>
      <listitem>Unless you are doing something unusual, you don't need to
      specify the <code>bootclasspath</code> or <code>extDirs</code> elements at
      all; the task will get these values from the JVM.</listitem>
    </itemizedlist>
    <para>If unspecified, the task gets the value of bootclasspath using the
    <code>java.lang.management</code> framework via the
    <code>RuntimeMXBean</code>. If unspecified, the task gets the value of
    <code>extDirs</code> from the Java system property
    <code>java.ext.dirs</code>. You would want to explicitly specify
    <code>bootclasspath</code> or <code>extdirs</code> if the intended execution
    environment of the application is different from that being used to execute
    the ANT task. For example,
    </para>
    <itemizedlist>
      <listitem>If the application is expected to run on a different JVM version
      than the one being used to execute the ANT Task, you would want to specify
      <code>bootclasspath</code> and <code>extDirs</code> to refer to the boot
      classpath and extension directories appropriate to the expected JVM
      version. (This is important because the Flashlight Instrument ANT task
      requires at least Java 5 to run.)</listitem>
      <listitem>If the application expects different Java extensions then are
      standard, you would want to explicitly specify the
      <code>extDirs</code>.</listitem>
    </itemizedlist>
    <formalpara>
      <title>Duplicate Classes on the Classpath</title> 
      <para>If a class appears more than once on the classpath as described
      above, then only the first version of the class that is encountered is
      processed. This matches the JVM semantics of finding the first class that
      matches on the classpath. Specifically, this means that the order in which
      JAR files, class directories, and other classpath entries are specified in
      the task is significant. Generally speaking, you should avoid having two
      identically named classes on the classpath. The instrumentation task
      reports to the instrumentation log when it skips a duplicate class.</para>
    </formalpara>
  </section>
  <section>
    <title>Flashlight debugging attributes</title> 
    <para>All ant tasks support a set of optional attributes used to configure
    the instrumentation step.  By changing these attribute values in the
    instrument, instrument-archive, and record tasks you can control which
    instructions are rewritten. In normal usage you should not mess around with
    these attributes; they only exist to assist with debugging
    transformations. There are three distinct sets of attributes</para>
    <orderedlist>
      <listitem>Attributes controlling the data store</listitem>
      <listitem>Attributes controlling instruction rewriting</listitem>
      <listitem>Attributes controlling method instrumentation</listitem>
    </orderedlist>
    <para>These attributes replace the use of Java properties to configure the
    behavior of the bytecode rewriter.  The <code>instrument</code> task
    <emphasis>does not</emphasis> look up the value of any Java property.</para>
    <table>
      <title>Controlling the Data Store</title>
      <tgroup cols='3'>
        <colspec colname='c1' align='left'/>
        <colspec colname='c2' align='left'/>
        <colspec colname='c3' align='left'/>
        <thead>
          <row>
            <entry>Attribute</entry>
            <entry>Default Value</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>store</entry>
            <entry><code>com.surelogic._flashlight.Store</code></entry>
            <entry>The fully qualified classname of the Flashlight Store class
            to use.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <table>
      <title>Controlling Instruction Rewriting</title>
      <tgroup cols='3'>
        <colspec colname='c1' align='left'/>
        <colspec colname='c2' align='left'/>
        <colspec colname='c3' align='left'/>
        <thead>
          <row>
            <entry>Attribute</entry>
            <entry>Default Value</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>rewriteArrayLoad</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether array load operations are rewritten.</entry>
          </row>
          <row>
            <entry>rewriteArrayStore</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether array store operations are
            rewritten.</entry>
          </row>
          <row>
            <entry>rewriteInvokeinterface</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>INVOKEINTERFACE</code> operations are
            rewritten. In particular if this is false no wrapper methods will be
            generated for methods invoked through an interface.</entry>
          </row>
          <row>
            <entry>rewriteInvokespecial</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>INVOKESPECIAL</code> operations used
            to invoke methods (but not constructors) are rewritten. In
            particular if this is false no wrapper methods will be generated for
            methods invoked using INVOKESPECIAL.</entry>
          </row>
          <row>
            <entry>rewriteInvokestatic</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>INVOKESTATIC</code> operations used to
            invoke static methods are rewritten. In particular if this is false
            no wrapper methods will be generated for static methods.</entry>
          </row>
          <row>
            <entry>rewriteInvokevirtual</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>INVOKEVIRTUAL</code> operations used
            to invoke methods are rewritten. In particular if this is false no
            wrapper methods will be generated for methods invoked using
            <code>INVOKEVIRTUAL</code>.</entry>
          </row>
          <row>
            <entry>rewriteSynchronizedMethod</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether synchronized methods are rewritten to use
            explicit <code>MONITORENTER</code> and <code>MONITOREXIT</code>
            operations.</entry>
          </row>
          <row>
            <entry>rewriteMonitorenter</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>MONITORENTER</code> operations, i.e,
            the start of <code>synchronized</code> blocks, are
            rewritten.</entry>
          </row>
          <row>
            <entry>rewriteMonitorexit</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>MONITOREXIT</code> operations, i.e,
            the close of <code>synchronized</code> blocks, are
            rewritten.</entry>
          </row>
          <row>
            <entry>rewriteGetstatic</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>GETSTATIC</code> operations, i.e.,
            static field reads, are rewritten.</entry>
          </row>
          <row>
            <entry>rewritePutstatic</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>PUTSTATIC</code> operations, i.e.,
            static field writes, are rewritten.</entry>
          </row>
          <row>
            <entry>rewriteGetfield</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>GETFIELD</code> operations, i.e.,
            instance field reads, are rewritten.</entry>
          </row>
          <row>
            <entry>rewritePutfield</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether <code>PUTFIELD</code> operations, i.e.,
            instance field writes, are rewritten.</entry>
          </row>
          <row>
            <entry>rewriteInit</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether constructor calls made via Java
            <code>new</code> operations are rewritten.</entry>
          </row>
          <row>
            <entry>rewriteConstructorExecution</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the body of constructors is rewritten to
            include pre- and post-execution events.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <table>
      <title>Controlling Method Instrumentation</title>
      <tgroup cols='3'>
        <colspec colname='c1' align='left'/>
        <colspec colname='c2' align='left'/>
        <colspec colname='c3' align='left'/>
        <thead>
          <row>
            <entry>Attribute</entry>
            <entry>Default Value</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>instrumentBeforeCall</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the wrapper method generates the before
            method call event.</entry>
          </row>
          <row>
            <entry>instrumentAfterCall</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the wrapper method generates the after
            method call event.</entry>
          </row>
          <row>
            <entry>instrumentBeforeWait</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the before wait event is generated if the
            method being called is one of the <code>Object.wait()</code>
            methods.</entry>
          </row>
          <row>
            <entry>instrumentAfterWait</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the after wait event is generated if the
            method being called is one of the <code>Object.wait()</code>
            methods.</entry>
          </row>
          <row>
            <entry>instrumentBeforeJUCLock</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the before lock event is generated if the
            method being called is one of <code>Lock.lock()</code>,
            <code>Lock.tryLock()</code>, or
            <code>Lock.lockInterruptibly()</code>.</entry>
          </row>
          <row>
            <entry>instrumentAfterLock</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the before lock event is generated if the
            method being called is one of <code>Lock.lock()</code> or
            <code>Lock.lockInterruptibly()</code>.</entry>
          </row>
          <row>
            <entry>instrumentAfterTryLock</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the before lock event is generated if the
            method being called is <code>Lock.tryLock()</code>.</entry>
          </row>
          <row>
            <entry>instrumentAfterUnlock</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether the after lock event is generated if the
            method being called is <code>Lock.unlock()</code>.</entry>
          </row>
          <row>
            <entry>instrumentIndirectAccess</entry>
            <entry><code>true</code></entry>
            <entry>Controls whether an event is generated after a calling a
            method that indirect accesses aggregated state of one of its
            arguments.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <table>
      <title>Other</title>
      <tgroup cols='3'>
        <colspec colname='c1' align='left'/>
        <colspec colname='c2' align='left'/>
        <colspec colname='c3' align='left'/>
        <thead>
          <row>
            <entry>Attribute</entry>
            <entry>Default Value</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>fieldsFilter</entry>
            <entry><code>NONE</code></entry>
            <entry>Whether to statically filter the field accesses that are
            instrumented.  Must be one of
            <itemizedlist>
              <listitem><code>NONE</code> &mdash; No filtering; instrument all field accesses.</listitem>
              <listitem><code>DECLARATION</code> &mdash; Instrument field accesses where the field is declared in a class in one of the named packages only.</listitem>
              <listitem><code>USE</code> &mdash; Instrument field accesses in the named packages only.</listitem>
            </itemizedlist>
            <emphasis>This value is case sensitive and the values must be in all
            capital letters.</emphasis> The <code>filter</code> element is used
            to declare the packages.
            </entry>
          </row>
          <row>
            <entry>useDefaultIndirectAccessMethods</entry>
            <entry><code>true</code></entry>
            <entry>Whether to use the default list of methods that indirectly
            access aggregated state.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>      
  </section>

</section>


