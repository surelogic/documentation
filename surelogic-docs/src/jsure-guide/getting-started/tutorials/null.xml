<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<section id="nonnull" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Verifying non-<code>null</code> references</title>

	<para>This tutorial demonstrates the use of the <code>@NonNull</code> and
  the <code>@Initialized</code> annotations for declaring intent regarding
  non-<code>null</code> references.  We assure two classes that could be
	part of a graphics package, <classname>Point</classname> and
	<classname>Rectangle</classname>.  These classes are contrived, based
	on code patterns that we have encountered in production code.</para>  

  <para>The class <classname>Point</classname> implements an immutable
  two-dimensional point:</para>	
	
	<programlisting><emphasis>@Immutable</emphasis>
public class Point {
  private final int x;
  private final int y;
  
  public Point(int x, int y) {
    this.x = x;
    this.y = y;
  }
  
  public int getX() {
    return x;
  }

  public int getY() {
    return y;
  }
  
  public Point translate(int dx, int dy) {
    return new Point(x + dx, y + dy);
  }
  
  public boolean isAboveLeftOf(Point p) {
    return this.x &lt;= p.x &amp;&amp; this.y &lt;= p.y;
  }
}</programlisting>

  <para>Besides the getter methods, the class has the method
  <function>translate</function> that returns a <emphasis>new</emphasis>
  point instance, and the predicate <function>isAboveLeftOf</function> that 
  returns whether the point is above, and to the left of the given point.</para>
  
  <para>The mutable class <classname>Rectangle</classname> has three fields,
  <code>@NonNull</code> point references, and a cached perimeter value:</para>
  
  <programlisting>public class Rectangle {
  private <emphasis>@NonNull</emphasis> Point topLeft;
  private <emphasis>@NonNull</emphasis> Point bottomRight;
  
  private int perimeter;
  
  // ...
}</programlisting>

  <para>Our assurance of this class is going to be based around the
  <code>@NonNull</code> annotations on the <structfield>topleft</structfield>
  and <structfield>bottomRight</structfield> fields.</para>
  
  <para>Before analyzing the code, make sure that JSure's Nullable Assurance is
  activated by checking <guilabel>Nullable</guilabel> in the 
  <menuchoice><guimenuitem>JSure</guimenuitem><guimenuitem>Verifying
  Analysis Selection</guimenuitem></menuchoice> preference pane.  (The
  <guilabel>Nullable Preprocessor</guilabel> analysis will always be selected
  when <guilabel>Nullable</guilabel> is selected.)  Now scan the project 
  with JSure.</para>

  <section>
    <title>Initial Assurance Results</title>
    
    <para>The initial assurance results from the <guilabel>Verification
    Status</guilabel> view are shown below:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-initial.png" />
      </imageobject>
    </mediaobject>
    
    <para>First we see that the <code>@Immuable</code> annotation on
    <classname>Point</classname> assures because the only fields in the class
    are <code>final</code> integer values.  Second we see four unsatisfied 
    <code>@NonNull</code> annotations: two on the fields <structfield>topLeft</structfield>
    and <structfield>bottomRight</structfield>, and two <emphasis>virtual</emphasis>
    annotations on the receivers of <function>copyFrom</function> and 
    <function>computePerimeter</function>.  The annotations on the fields are
    explicit in the code (see above).  The annotations on the method receivers
    are virtual because they are not present in the code; instead the annotations
    are implicit on all method receivers and displayed in the results only 
    when they are unsatisfied.</para>
    
    <para>The rest of the tutorial proceeds as follows:
      <orderedlist>
        <listitem>
          <para>The annotations on the fields <structfield>topLeft</structfield>
          and <structfield>bottomRight</structfield> are assured by adding additional
          annotations to method parameters and method return values.</para>
        </listitem>
        <listitem>
          <para>The virtual annotations on the receivers of
          <function>copyFrom</function> and <function>computePerimeter</function>
          are assured.</para>
        </listitem>
        <listitem>
          <para>The code is refactored to avoid the problems raised by 
          <function>copyFrom</function> and <function>computePerimeter</function>.</para>
        </listitem>
      </orderedlist>
    </para>    
  </section>
  
  <section>
    <title>Assuring the Fields</title>
    
    <para>We continue by expanding the results for the fields
    <structfield>topLeft</structfield> and <structfield>bottomRight</structfield>.
    They are used similarly by the class implementation and thus have similar
    results:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-fields.png" />
      </imageobject>
    </mediaobject>
    
    <para>The <code>@NonNull</code> annotation for each field has a positive
    &ldquo;Definitely assigned&rdquo; result.  JSure requires the every non null
    field be explicitly initialized during construction, otherwise the field's 
    value will be the Java language default <code>null</code> value.  In this
    case, JSure is satisfied that the fields are definitely assigned by the
    constructor <function>Rectangle(Point, Point)</function>.  However, assurance
    is not satisfied that the constructor <function>Rectangle(Rectangle)</function>
    initializes the fields.  This is because the constructor invokes a method
    to initialize the fields:</para>
    
    <programlisting>  /**
   * Copy constructor.
   */
  public Rectangle(Rectangle other) {
    copyFrom(other);
  }</programlisting>
    
    <para>Assurance cannot be sure what the invoked method may do, and thus
    cannot be sure that the constructor will initialize the fields to
    non-<code>null</code> values.  We revisit this problem later in the
    tutorial.</para>
    
    <para>The first unacceptable assignment result for each field refers to
    values being assigned to the fields in the constructor
    <function>Rectangle(Point, Point)</function>.  The constructor is as
    follows:</para>
    
    <programlisting>  /**
   * Caller responsibility to insure that the points really are
   * top-left and bottom-right.  Origin (0, 0) is the top-left corner
   * of the canvas.
   */
  private Rectangle(Point topLeft, Point bottomRight) {
    this.topLeft = topLeft;
    this.bottomRight = bottomRight;
    computePerimeter();
  }</programlisting>
    
    <para>Because the formal parameters <parameter>topLeft</parameter>
    and <parameter>bottomRight</parameter> are unannotated they are 
    allowed to be passed the value <code>null</code>, and thus the 
    fields could be initialized to <code>null</code> in violation of their
    <code>@NonNull</code> annotation.  The solution, as proposed in the
    results, is to annotate the two parameters with <code>@NonNull</code>.
    Go ahead and do that now.</para>
    
    <para>Next we see that <structfield>topLeft</structfield> and 
    <structfield>bottomRight</structfield> have unacceptable assignments
    due to the &ldquo;return value of method call&rdquo; <code>translate()</code>.
    This is a method from the class <classname>Point</classname> that returns
    a new point translated from the original:</para>
    
    <programlisting>  public Point translate(int dx, int dy) {
    return new Point(x + dx, y + dy);
  }</programlisting>
  
    <para>Assurance rejects the assignments to the fields because without any
    programmer annotation assurance assumes that a method may return the
    value <code>null</code>.  In this case the method always returns a 
    new object, and thus always returns a non-<code>null</code> reference.
    We can annotate this by adding the <code>@NonNull</code> annotation
    to the method:</para>
    
    <programlisting>  <emphasis>@NonNull</emphasis>
  public Point translate(int dx, int dy) {
    return new Point(x + dx, y + dy);
  }</programlisting>
     
    <para>Add the annotation and reverify the project.  The five unacceptable
    assignments we just looked at are now acceptable.  If you have 
    <guilabel>Highlight differences from last scan</guilabel> button
    selected on the view, the changes to the results are highlighted in yellow:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-fields2.png" />
      </imageobject>
    </mediaobject>
    
    <para>The initialization of the <structfield>topLeft</structfield> in
    the constructor <function>Rectangle(Point, Point)</function> is now
    satisfied by the annotation on the formal parameter.  Furthermore, calls
    to the constructor itself are also now verified to pass only non-<code>null</code>
    values as actuals.  In this case, there is one call site and it passes
    a new object:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-param-chain.png" />
      </imageobject>
    </mediaobject>
    
    <para>Similarly, the assigned to <structfield>topLeft</structfield> in
    <function>Rectangle.translate()</function> is now satisfied by the annotation
    on the return value of <function>Point.translate()</function>.  And the 
    chain of evidence continues to the actual return value of the method
    (the creation of the new <classname>Point</classname> object):</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-return-chain.png" />
      </imageobject>
    </mediaobject>
    
    <para>The results are similar for the field
    <structfield>bottomRight</structfield>.</para>
    
    <para>Both fields have an &ldquo;Acceptable assignment&rdquo; result that 
    shows with a red X.  This means that some annotation that the chain of
    evidence relies on does not assure.  In this case, the annotation is a 
    recursive reference to the <code>@NonNull</code> annotation on the field 
    itself:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-redx-assured.png" />
      </imageobject>
    </mediaobject>
    
    <para>You can tell the reference is recursive because of the upward 
    pointing arrow.  The reference is caused by an assignment in method
    <function>copyFrom()</function> where the the value of the field in
    one object is copied to the field in another object:</para>
    
    <programlisting>  public void copyFrom(Rectangle other) {
    topLeft = other.topLeft;
    bottomRight = other.bottomRight;
    perimeter = other.perimeter;
  }</programlisting>
  
    <para>This chain of evidence will sort itself out once the other assurance
    failures under the <code>@NonNull</code> annotation are corrected.</para>
    
    <para>There is one more &ldquo;Unacceptable assignment&rdquo; for the
    field <structfield>bottomRight</structfield>:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-setBottomRight.png" />
      </imageobject>
    </mediaobject>
    
    <para>The assignment in question is in the method
    <function>setBottomRight()</function>:</para>
    
    <programlisting>  public void setBottomRight(Point newCorner) {
    if (!topLeft.isAboveLeftOf(newCorner)) {
      throw new IllegalArgumentException();
    }
    bottomRight = newCorner;
    computePerimeter();
  }</programlisting>
  
    <para>This is another case of the field being assigned the value from
    an unannotated formal parameter.  The solution once again is to add
    <code>@NonNull</code> to the formal parameter
    <parameter>newCorner</parameter>.  Go ahead and do this now.</para>
    
    <para>You may notice that just before <function>setBottomRight()</function>
    in the source code is the method <function>setTopLeft()</function>.  This
    begs the question, why there is not a similar assurance failure of the
    assignment to <structfield>topLeft</structfield> in that method.  The answer
    lies in the condition of the <code>if</code>-statements used to check that
    the top-left&ndash;bottom-right invariant on the fields is maintained.  In
    <function>setBottomRight()</function> the expression
    <code>!topLeft.isAboveLeftOf(newCorner)</code> is used, with the 
    field reference used as the receiver to <function>isAboveLeftOf()</function>.
    But in the method <function>setTopLeft()</function>, the expression
    <code>!newCorner.isAboveLeftOf(bottomRight)</code> is used, with 
    formal parameter <parameter>newCorner</parameter> used as the receiver.
    Why does this matter?  When analyzing the body of the method
    <function>setTopLeft()</function>, the analysis knows that receivers must
    always be non-<code>null</code>, or else the Java runtime will throw
    a <code>NullPointerException</code>.  So the analysis knows that in any code
    that executes after the dereference of <parameter>newCorner</parameter>
    in the conditional of the <code>if</code>-statement the value of 
    <parameter>newCorner</parameter> must not be <code>null</code>.  It would 
    still be wise from a documentation point of view to annotate the formal
    parameter of <function>setTopLeft</function> as <code>@NonNull</code>.  
    Do this now and reverify the project.</para>
    
    <para>The assignment in <function>setBottomRight</function> now
    assures:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-setBottomRight-assures.png" />
      </imageobject>
    </mediaobject>
    
    <para>We are now done assuring the <code>@NonNull</code> annotations on
    the fields <structfield>topLeft</structfield> and
    <structfield>bottomRight</structfield>.</para>    
  </section>
  
  <section>
    <title>References to Partially Initialized Objects</title>
    
    <para>We now visit the unassured virtual <code>@NonNull</code>
    annotations.  We start with the last one on the receiver of 
    <function>Rectangle.computePerimeter()</function>:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-computePerimeter.png" />
      </imageobject>
    </mediaobject>
    
    <para>What does this chain of evidence mean exactly?  The result is on the
    method call <code>computePerimeter()</code> in the constructor 
    <function>Rectangle(Point, Point)</function>:</para>
    
    <programlisting>  private Rectangle(@NonNull Point topLeft, @NonNull Point bottomRight) {
    this.topLeft = topLeft;
    this.bottomRight = bottomRight;
    computePerimeter();
  }</programlisting>
  
    <para>Assurance does not like the reference from <code>this</code> that
    is being used as the receiver to the method
    <function>computePerimeter()</function>.  Specifically, unless otherwise 
    annotated, a method expects that its receiver is <code>@NonNull</code>,
    but JSure finds in this case that the receiver is
    <code>@Initialized(through="Object")</code>.  What does this mean? 
    It means that the object referenced by <code>this</code> in the constructor
    is <emphasis>partially initialized</emphasis>, in this case through class
    <classname>Object</classname>.  An <code>@Initialized(through="X")</code>
    reference is (1) never <code>null</code>; and (2) only guaranteed to have 
    the fields from ancestor classes through <classname>X</classname> initialized.
    So in this case, the fields from class <classname>Rectangle</classname>
    are not guaranteed to have been initialized&mdash;because the referenced object
    is only initialized through its <classname>Object</classname> portion&mdash;and thus <emphasis>may be seen
    to hold the value <code>null</code> despite being annotated as 
    <code>@NonNull</code></emphasis>.  For this reason, even though an
    <code>@Initialized</code> reference is never <code>null</code>, it cannot
    be passed to a <code>@NonNull</code> reference because we must manage the
    fact that some of the fields of the referenced object may violate their
    <code>@NonNull</code> invariants.  In our particular case here, we can
    see that the <code>@NonNull</code> fields <structfield>topLeft</structfield>
    and <structfield>bottomRight</structfield> are correctly initialized
    before calling <function>computePerimeter</function>.  We use this fact
    later in the example.</para>
    
    <para>Partially initialized references originate in constructors: an object
    of type <classname>C</classname> is not fully initialized until its final
    constructor, the one defined within <classname>C</classname>, executes. If
    a reference to the receiver is passed to another method during
    construction&mdash;as it is in <function>Rectangle(Point, Point)</function>&mdash;then
    that reference is partially initialized through the most recently
    constructed superclass component.  That is, if we have class
    <classname>C</classname> extends <classname>B</classname> extends
    <classname>A</classname>, and during the execution of the constructor for
    <classname>B</classname> a reference to the object being constructed is
    leaked, then that reference is partially initialized through
    <classname>A</classname>.</para>
    
    <!--formalpara>
      <title>To be continued</title>
      <para>This section will continue by showing several attempts to
      assure the method <function>computePerimeter()</function>.  The section
      further continues by discussing the assurance failure in 
      <function>Rectangle(Rectangle)</function>, which is also related to
      a partially initialized object.  All the assurance 
      techniques discussed are flawed, relying on escaping JSure's analysis-based
      assurance. The best approach is to rewrite the class, which
      is to be discussed in a later section.</para>
    </formalpara-->
    
    <para>How can we satisfy the assurance for constructor
    <function>Rectangle(Point, Point)</function>?  The most straightforward
    way to do so is to declare to <function>computePerimeter()</function> that
    the receiver is possible partially intialized by annotating it with an
    <code>@Initialized</code> annotation:</para>
    
    <programlisting>  <emphasis>@Initialized(through="Object", value="this")</emphasis>
  private void computePerimeter() {
    int width = bottomRight.getX() - topLeft.getX();
    int height = bottomRight.getY() - topLeft.getY();
    perimeter = (width + height) &lt;&lt; 1;
  }</programlisting>
    
    <para>Here we have to use the <code>value</code> attribute of the 
    annotation to indicate that that receiver of the method (and not the return
    value) is being annotated.  Add this to the code and reverify the
    project.  At first glance the results seem acceptable.  There is a 
    new model drop corresponding to the <code>@Initialized</code> annotation
    and all the call sites of the method are assured.  Note that the actual
    receiver is <code>@Initialized</code> when the method is called
    from the constructor, but <code>@NonNull</code> when the method
    is called from other methods:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-computePerimeter2.png" />
      </imageobject>
    </mediaobject>
    
    <para>Unfortunately, there are also changed results for the
    <code>@NonNull</code> annotations on the two fields.  This is noted by 
    the small delta decoration on the icons.  Opening up these results reveals
    new <emphasis>negative</emphasis> results about the field: possible 
    dereferences of a <code>null</code> value.</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-computePerimeter3.png" />
      </imageobject>
    </mediaobject>
    
    <para>The fields <structfield>topLeft</structfield> and
    <structfield>bottomRight</structfield> are not supposed to be <code>null</code>
    so how can we possibly read a <code>null</code> value from them?  The 
    receiver of the method <structfield>computePerimeter</structfield> 
    is <code>@Initialized(through="Object")</code>, which means inside the method 
    analysis must assume that the fields have not yet been initialized to a 
    non-<code>null</code> value.  So attempting to dereference the fields
    to use them as receivers for <function>getX()</function> and
    <function>getY()</function> can yield a <code>null</code> value.  As 
    <code>null</code> is not acceptable for a receiver, assurance creates 
    a negative result here.  Assurance does not normally report an error result
    when a possible null value is used as a receiver because in unannotated code
    this would create too many errors.  It does however report the situation as a 
    warning when a field is explicitely annotated with <code>@Nullable</code>.
    Assurance reports an error in this case because of the 
    special situation of reading <code>null</code> from a <code>@NonNull</code>
    field.</para>
     
    <para>To assure the method <function>computePerimeter()</function> we need
    to handle the fact that the fields <structfield>topLeft</structfield> and
    <structfield>bottomRight</structfield> may be <code>null</code>.  We 
    could do this by testing the fields against <code>null</code> and only 
    computing the perimeter if they are not null:</para>
    
    <programlisting>  @Initialized(through="Object", value="this")
  private void computePerimeter() {
    Point tL = topLeft;
    Point bR = bottomRight;
    if (tL != null &amp;&amp; bR != null) {
      int width = bR.getX() - tL.getX();
      int height = bR.getY() - tL.getY();
      perimeter = (width + height) &lt;&lt; 1;
    }
  }</programlisting>
  
    <para>Here we first copy the value of the fields into local variables
    before testing against <code>null</code>.  This is necessary because the
    flow analysis only tracks the values of local variables because it cannot
    be sure that the value of a field is not going to be modified by a 
    concurrently executing thread of control.  (We are currently working on 
    relaxing this constraint by exploiting our concurrency annotations, e.g., 
    <code>@RegionLock</code>.)  Flow analysis also understands comparisons 
    against <code>null</code> and thus can determine that both
    <varname>tL</varname> and <varname>bR</varname> are non null in the
    body of the <code>if</code>-statement.  After reverifying the project
    the &ldquo;possible dereference of a null value&rdquo; negative results
    are gone:</para> 
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-computePerimeter4.png" />
      </imageobject>
    </mediaobject>

    <para>Despite this apparent success at verifying the method, this 
    approach is undesirable because it leaves the field
    <structfield>perimeter</structfield> in an unknown state when 
    one of the corners of the rectangle is <code>null</code>.  More importantly,
    it swallows the error when one of the fields is <code>null</code>.  We 
    could add error handling here, but what would we do?  Throwing an exception
    is extreme because there isn't anything the caller of the method can 
    do about the situation.  The fact is that
    <function>computePerimeter()</function> must rely on the 
    <code>@NonNull</code> annotations on <structfield>topLeft</structfield> and
    <structfield>bottomRight</structfield>.</para>  
    
    <para>We must return <function>computePerimeter()</function> to its
    original form:</para>
    
    <programlisting>  private void computePerimeter() {
    int width = bottomRight.getX() - topLeft.getX();
    int height = bottomRight.getY() - topLeft.getY();
    perimeter = (width + height) &lt;&lt; 1;
  }</programlisting>
  
    <para>The best approach to assurance in this case is recognizing that
    the constructor <function>Rectangle(Point, Point)</function> has
    completed initializing the <code>@NonNull</code> fields before calling
    <function>computePerimeter()</function>:</para>
    
    <programlisting>  private Rectangle(@NonNull Point topLeft, @NonNull Point bottomRight) {
    this.topLeft = topLeft;
    this.bottomRight = bottomRight;
    computePerimeter();
  }</programlisting>
   
    <para>So what we need to do is force the analysis to consider the receiver
    to be <code>@NonNull</code> when invoking
    <function>computePerimeter()</function>.  We can do this using the 
    method <code>Cast.toNonNull()</code>.  This is a method in the SureLogic
    library that always returns it's given reference as a <code>@NonNull</code>
    reference.  As a safe-guard it triggers a Java assertion failure if the
    given reference is actually <code>null</code>.  Analysis recognizes this
    method and treats it like a <code>@Vouch</code> in the results.  </para>
    
    <programlisting>  private Rectangle(@NonNull Point topLeft, @NonNull Point bottomRight) {
    this.topLeft = topLeft;
    this.bottomRight = bottomRight;
    Cast.toNonNull(this).computePerimeter(); // N.B. topLeft and bottomRight are initialized
  }</programlisting>

    <para>After reverifying the project, the negative assurance result on the 
    virtual <code>@NonNull</code> annotation for method
    <function>Rectangle.computePerimeter()</function> is gone.  We also see
    a new vouch result corresponding to the call to 
    <function>Cast.toNonNull()</function>:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-cast-to-nonnull.png" />
      </imageobject>
    </mediaobject>
    
    
    
    <para>Now we look at the virtual <code>@NonNull</code> on method
    <function>copyFrom()</function>:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-copyFrom.png" />
      </imageobject>
    </mediaobject>
    
    <para>Again, we have an instance method called from a constructor
    using the object under construction as the receiver:</para>
    
    <programlisting>  /**
   * Copy constructor.
   */
  public Rectangle(Rectangle other) {
    copyFrom(other);
  }</programlisting>  
   
   
    <para>As before, the obvious starting point is to annotate the receiver
    of <function>copyFrom()</function> as being a partially initialized 
    object.  This is obviously a safe thing to do because the method only 
    writes the fields of the receiver.  While we are at it, we also declare
    that the parameter <parameter>other</parameter> is <code>@NonNull</code>:</para>
    
    <programlisting>  <emphasis>@Initialized(through="Object", value="this")</emphasis>
  public void copyFrom(<emphasis>@NonNull</emphasis> Rectangle other) {
    topLeft = other.topLeft;
    bottomRight = other.bottomRight;
    perimeter = other.perimeter;
  }</programlisting>
    
    <para>After reassuring the project, the <code>@Initialized</code>
    annotation assures, but the <code>@NonNull</code> annotation does not.  The
    problem being that the formal paramter in the constructor used as the 
    actual in the method call needs to be <code>@NonNull</code> as well:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-copyFrom2.png" />
      </imageobject>
    </mediaobject>
    
    <para>Add the <code>@NonNull</code> annotation to the parameter
    <parameter>other</parameter> of <function>Rectangle(Rectangle)</function>.
    After reassuring the project, the new <code>@NonNull</code> annotations 
    assure:</para>

    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-copyFrom3.png" />
      </imageobject>
    </mediaobject>
    
    <para>Reviewing the rest of the results, we see that we still have a 
    &ldquo;Not definitely assigned&rdquo; failure for each of the fields
    <structfield>topLeft</structfield> and <structfield>bottomRight</structfield>
    and recursive failures originating from the assignments in the 
    method <function>copyFrom</function>.  Again, the recursive failures 
    originate in the fact the correctness of copy assignments depends on the 
    fields <structfield>topLeft</structfield> and
    <structfield>bottomRight</structfield> being <code>@NonNull</code> 
    which is not assuring due to the definite assignment errors.</para>
    
    <para>As described previously, Nullable assurance requires that every
    <code>@NonNull</code> field be explicitly assigned in each constructor
    or in its field declaration.  This is so that the Java-default value of
    <code>null</code> for references is never visible.  Analysis is unable to 
    determine that the fields <structfield>topLeft</structfield> and <structfield>bottomRight</structfield>
    are properly initialized in <function>Rectangle(Rectangle)</function>
    because the constructor relies on the method <function>copyFrom()</function>
    to initialize the fields.  We must use a <code>@Vouch</code> annotation 
    on the constructor to explicitly indicate that the fields are 
    correctly initialized:</para>
    
    <programlisting>  <emphasis>@Vouch("topLeft and bottomRight are initialized by copyFrom()")</emphasis>
  public Rectangle(@NonNull Rectangle other) {
    copyFrom(other);
  }</programlisting>
    
    <para>Assuring the project after adding this annotation is finally
    successful:</para>
    
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/nonnull-copyFrom-assured.png" />
      </imageobject>
    </mediaobject>

    <para>The &ldquo;Not definitely assigned&rdquo; results now display with 
    a grey plus, indicating the that result has been explicitly made acceptable
    by the addition of the <code>@Vouch</code> annotation.  We also see that the
    recursive dependency of the <code>@NonNull</code> field annotations 
    finally assures because the rest of the errors have been resolved.</para>

  </section>
  
</section>
