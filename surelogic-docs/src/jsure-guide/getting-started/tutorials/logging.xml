<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<section id="loggin" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Uncovering a bug in <package>java.util.logging</package></title>

	<para>
		In this tutorial we examine a real-world bug in the
		<package>java.util.logging</package>
		portion of the Java standard library. This is a check-than-act
		bug that was reported to Sun when it appeared in Java 5 but was not fixed until Java 7. Our version of
		the code for this tutorial is changed to be in a different package so
		that it doesn't conflict with the standard library.
	</para>

	<para>
		The project we will be using is named
		<emphasis>JSureTutorial_java.util.logging</emphasis>
		.
	</para>

	<section>
		<title>A check-than-act problem</title>

		<para>In the tutorial project go into the
			<package>com.surelogic.util.logging</package>
			package and open the
			<classname>Logging</classname>
			class in the Java editor. Examine the lines listed below.</para>
			
			<programlisting linenumbering="numbered" startinglinenumber="401">public void log(LogRecord record) {
  if (record.getLevel().intValue() &lt; levelValue || levelValue == offValue) {
    return;
  }
  synchronized (this) {
    if (filter != null &amp;&amp; !filter.isLoggable(record)) {
      return;
    }
  }

  // Post the LogRecord to all our Handlers, and then to
  // our parents' handlers, all the way up the tree.</programlisting>
  
	<para>Of interest is line 406 that <structfield>filter</structfield>
	    is first checked that it is not null, followed by its use: <code>!filter.isLoggable(record)</code>. This occurs in order
	    because the <code>&amp;&amp;</code> is a shortcut
	    logical and which will return false if the first expression is false. This code is reasonable because if, in fact, <structfield>filter</structfield>
	    is null then the expression <code>!filter.isLoggable(record)</code> would throw a <emphasis>NullPointerException</emphasis>.</para>
	    
	<para>A lock on the instance is held as this operation occurs, this lock is acquired using <code>synchronized (this)</code> at line 40. Therefore, it appears
	    that the programmer intent is to hold a lock on the class when the <structfield>filter</structfield> is accessed. In fact, the
	    <emphasis>Logger</emphasis> class is intented to be threadsafe. You can see this way up at line 119 of the class's Javadoc.</para>
	    
	<programlisting linenumbering="numbered" startinglinenumber="119"> * All methods on Logger are multi-thread safe.</programlisting>
	
	<para>We now turn our attention to the getter and setter for the <structfield>filter</structfield> field in the implementation of <emphasis>Logger</emphasis>.
	    This code, which beings at line 362, is listed below.</para>
	
	<programlisting linenumbering="numbered" startinglinenumber="362">  /**
   * Set a filter to control output on this Logger.
   * &lt;P&gt;
   * After passing the initial "level" check, the Logger will call this Filter
   * to check if a log record should really be published.
   * 
   * @param newFilter
   *            a filter object (may be null)
   * @exception SecurityException
   *                if a security manager exists and if the caller does not
   *                have LoggingPermission("control").
   */
  public void setFilter(Filter newFilter) throws SecurityException {
    if (!anonymous) {
      manager.checkAccess();
    }
    filter = newFilter;
  }

  /**
   * Get the current filter for this Logger.
   * 
   * @return a filter object (may be null)
   */
  public Filter getFilter() {
    return filter;
  }</programlisting>
  
	<para>The problem is that neither the setter nor the getter follow the locking model. Worse, the Javadoc at line 368 makes it
	    clear that a value of null is an acceptable value for the <structfield>filter</structfield> field.</para>
	    
	<para>The access of the <structfield>filter</structfield> field without holding the
	    proper lock is the concurrency problem. We refer to this as a check-than-act
	    problem because the change to null could occur, via the setter,
	    after the null check at line 406, but before the use of the field in the <code>!filter.isLoggable(record)</code>. Causing the program
	    the throw a <emphasis>NullPointerException</emphasis>.</para>

	</section>

	<section>
		<title>Causing a Logger to throw a NullPointerException</title>
		
		<para>The <emphasis>Logger</emphasis> class can be exercised to throw a <emphasis>NullPointerException</emphasis>.
		    We have included a small test program that has several threads obtain the same <emphasis>Logger</emphasis> instance
		    and repeatedly change the filter from a value to null while logging output.
		    This code is shown in <xref linkend="fig-logging-concurrent-exercise-code"/>.</para>
    
	    <figure id="fig-logging-concurrent-exercise-code">
	      <title>The concurrent exercise program to cause the library bug to throw a NullPointerException</title>
	      
	      <mediaobject>
	        <imageobject>
	          <imagedata fileref="images/logging_concurrent-exercise-code.png" />
	        </imageobject>
	      </mediaobject>
	    </figure>
	    
	    <para>If you launch this program in Eclipse it will sometimes complete normally. Sometimes
	        one thread will throw a NullPointerException. Sometimes more than one thread will
	        throw a NullPointerException.  This is due to the unpredicable nature of this type
	        of problem, making it untestable.</para>

	</section>
	
	<section>
		<title>(Optional) Use of Flashlight dynamic analysis to show the problem</title>
		
		<para>If you have the SureLogic Flashlight tool you can use it to reliably uncover the
		    problem with the <structfield>filter</structfield> field within
		    the <emphasis>Logger</emphasis> class. Launch the program with Flashlight using either the Flashlight menu or
		    the <inlinegraphic fileref="images/fl_logo.png"/> in the Eclipse launch toolbar. Let it
		    finish its execution, and let the tool automatically prepare the data collected for querying.  When prompted
		    switch to the Flaslight perspective. The result should appear as shown in the screenshot below.</para>
		    
	      <mediaobject>
	        <imageobject>
	          <imagedata fileref="images/logging_flashlight-news.png" />
	        </imageobject>
	      </mediaobject>
	      
	      <para>The news item of interest is boxed in red in the image
	          above: <emphasis>Shared fields with writes that do not happen-before subsequent reads</emphasis>.
	          What the Flashlight tool has observed during the program run is that their are (instance) fields
	          that are shared between two or more threads but do not respect the Java memory model. In particular,
	          the tool could not establish that a write in one thread <emphasis>happened-before</emphasis> a read
	          in a second thread. Click on this finding to find out what fields were observered to have this problem.</para>
	          
	      <mediaobject>
	        <imageobject>
	          <imagedata fileref="images/logging_flashlight-finding.png" />
	        </imageobject>
	      </mediaobject>
	      
	      <para>The screenshot above shows that Flashlight indeed noted the problem we described in the section above. However, it
	          did this by examining the memory model, whereas we were examining consistent locking.  Dynamic analysis results
	          using the Java memory model are usually more percise, but Flashlight also noted the lack consitent lock useage
	          for the <structfield>filter</structfield> field within the <emphasis>Logger</emphasis> class.
	          You can see this if you select the <emphasis>Shared fields with no common lock held for each access</emphasis>
		      result in the bad news report, or the <emphasis>What fields (non-static) have an empty
		      lock set after object construction?</emphasis> query from the <guilabel>Query Menu</guilabel> view.</para>
		      
	      <para>Flashlight contains rich information about these findings that you can feel free to dig into, however, we
	          will now turn our attention back to JSure. We want to now model the programmer intended locking model and fix the code bug.</para>
		
	</section>


</section>
