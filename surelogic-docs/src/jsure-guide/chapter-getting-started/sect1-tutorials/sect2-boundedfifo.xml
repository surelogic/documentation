<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect2 id="boundedfifo"
    xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Verifying BoundedFIFO</title>
  
  <para>In this tutorial we walk through the complete assurance of the
  <classname>JSureTutorial_BoundedFIFO</classname> project using JSure.
  Specifically, we assure both the implementation and <emphasis>usage</emphasis>
  of a simple class.  That is, we demonstrate that it's not always enough to
  assure the implementation of a class: <emphasis>sometimes the clients of a
  class must conform to a specific behavior as well</emphasis>. This example
  focuses on two classes (plus one auxiliary class):
  
    <itemizedlist>
      <listitem>
        <formalpara>
          <title><classname>BoundedFIFO</classname></title>
          
          <para>The &ldquo;thread safe&rdquo; class.  This class is
          taken &ldquo;as is&rdquo; from the Apache Log4J project.</para>
        </formalpara>
      </listitem>
    
      <listitem>
        <formalpara>
          <title><classname>BlockingFIFO</classname></title>
        
          <para>The client code.  We wrote this class based on actual
          client code in the Apache Log4J project.</para>
        </formalpara>
      </listitem>
    
      <listitem>
        <formalpara>
          <title><classname>LoggingEvent</classname></title>
        
          <para>The class of objects stored in the queue.  This
          class is not interesting, and is merely a placeholder for queue
          objects.</para>
        </formalpara>
      </listitem>
    </itemizedlist>
  </para>

  <para>In addition to showing the basic usage of JSure with Eclipse,
  this example shows off the JSure annotations
  <classname>@RegionLock</classname>,
  <classname>@RequiresLock</classname>,
  <classname>@Borrowed</classname>, <classname>@Unique</classname>,
  and <classname>@Promise</classname>. </para>
    
  <para>After completely assuring the project, we show how the annotated model
  for <classname>BoundedFIFO</classname> can be augmented by named regions
  of state using the annotations <classname>@Region</classname>,
  <classname>@InRegion</classname>, and <classname>@UniqueInRegion</classname>.</para>
  
  <sect3 id="declaring-protected-state">
    <title>Declaring Protected State</title>
    
    <para>The <classname>BoundedFIFO</classname> class is a buffer
    meant to be shared between two threads. It obviously must be made
    thread-safe. The usual assumption is that an object protects its
    own state, and we intend for that to be the case here.  Declare this 
    design intent by adding a <classname>@RegionLock</classname> annotation
    to the class <classname>BoundedFIFO</classname> 
    (and not to <classname>BlockingFIFO</classname>):
    
    <programlisting>
<emphasis>@RegionLock("BufLock is this protects Instance")</emphasis>
public class BoundedFIFO {
  &hellip;
}</programlisting>    
    </para>

    <note>
      <title>Don't forget to <code>import</code> the annotation type</title>
      
      <para>The annotation type <classname>RegionLock</classname> (and any other
      JSure annotation used in these examples) must be imported
      before the class name can be resolved by the compiler.  There are a number of ways
      you can do this:
      
        <itemizedlist>
          <listitem>
            <para>You can manually add <code>import
            com.surelogic.RegionLock</code>, or more generally,
            <code>import com.surelogic.*</code> to the list of imports
            at the top of <filename>BoundedFIFO.java</filename>.</para>
          </listitem>

          <listitem>
            <para>If you are typing the annotation into the editor you can
            use the Eclipse &ldquo;content assist&rdquo; feature as you are typing
            the name <classname>RegionLock</classname>.  The Java editor will 
            automatically add the correct <code>import</code> clauses or
            enter the fully qualified name of the class, depending on your
            Eclipse preferences.</para>
          </listitem>

          <listitem>
            <para>If you used copy-and-paste to copy the annotation from this tutorial and paste
            it into the Eclipse editor you can use the Eclipse &ldquo;quick fix&rdquo; feature
            to insert the <code>import</code> clause.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </note>

    <para>Adding annotations is not enough to see assurance
    results&mdash;you need to scan the project. To scan the project

    <itemizedlist>
      <listitem>
	<para>Choose <menuchoice><guimenu>JSure</guimenu>
	<guisubmenu>Verify Project</guisubmenu></menuchoice> from the
	Eclipse main menu. You can also use the keyboard shortcut
	<keysym>Ctrl</keysym>+<keysym>Alt</keysym>+<keysym>Shift</keysym>+<keysym>V</keysym>.

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/verify-project.png" />
	  </imageobject>
	</mediaobject>  
	</para>
      </listitem>

      <listitem>
	<para>This will bring up the dialog shown below which allows
	you to select the set of projects you want to scan from the
	set of open Java projects in your Eclipse workspace.

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/verify-project-dialog.png" />
	  </imageobject>
	</mediaobject>  

	Check <application>JSureTutorial_BoundedFIFO</application> and press
	<guilabel>OK</guilabel> to start a scan. A balloon
	notification will appear telling you that the scan has been
	started in the background and that you will be notified when
	the scan has been completed.

	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/verify-project-scan-started.png" />
	  </imageobject>
	</mediaobject>  

	</para>
      </listitem>

      <listitem>
	<para>The scan should not take long to complete. When it
	finishes you will be prompted to switch to the <guilabel>Code
	Verification</guilabel> perspective.
	
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/perspective-switch.png" />
	  </imageobject>
	</mediaobject>  

	Choose <guilabel>Yes</guilabel> because we want to examine the
	scan results.</para>
      </listitem>
    </itemizedlist>
    </para>

    <para>Switching to the <guilabel>Code Verification</guilabel>
    perspective at this point should look something like this:
    <mediaobject>
      <imageobject>
	<imagedata fileref="images/switched-to-code-verification.png" />
      </imageobject>
    </mediaobject>
    We begin our examination of the results using the
    <guilabel>Verification Status</guilabel> view.  This view shows
    the results of assuring model&ndash;code consistency. It is
    similar to a file system explorer, but instead of showing
    directories and files, it shows the chain of evidence used to
    build a verification judgment&mdash;consistent or inconsistent&mdash;about
    each of your annotations.</para>
    
    <para>By digging into the <guilabel>Concurrency</guilabel> results, we see
        two results. First, notice that the lock model <computeroutput>java.lang.Object.MUTEX</computeroutput> is initially unassured.
        This intrinsic lock model is declared on <classname>java.lang.Object</classname> and
        defines to the need to hold a lock when invoking the <code>wait()</code> and <code>notify()</code>
        methods on any Java object.  The lock model declares <code>this</code>, the object itself, as the
        lock that protects the waitâ€“notify queue, and requires that the lock be held before the
        <code>wait()</code> and <code>notify()</code> methods may be invoked.  The fact that this model is unassured
        indicates that somewhere in the code JSure is unable to prove that a lock is held on an object that either
        <code>wait()</code> or <code>notify()</code> is invoked on. We will discover this finding to be accurate later in this tutorial.</para>
    
    <para>Second, we note the
    single annotation we added to the code. Verification of this annotation by JSure produces
    a concurrency result indicating that the
    annotation is <emphasis>not</emphasis> assured, and a few
    warnings.  There are 27 unprotected field accesses for
    <structfield>BufLock</structfield>, and no protected field
    accesses:
    
    <mediaobject>
      <imageobject>
	<imagedata fileref="images/boundedfifo1.png"/>
      </imageobject>
    </mediaobject>
    </para>
  
    <para>Opening up the results tree further we see that JSure
    identifies each location in the code where state is accessed
    without holding the correct lock:
    
    <mediaobject>
      <imageobject>
	<imagedata fileref="images/boundedfifo2.png" />
      </imageobject>
    </mediaobject>    

    Double-clicking on any of the results in the
    <guilabel>Verification Status</guilabel> view focuses an Eclipse
    Java editor and the <guilabel>JSure Historical Source</guilabel>
    view on the offending line of code.  Let us view line of code from
    the assurance failure at line 52 by double-clicking on
    <computeroutput>Lock "&lt;this&gt;.BufLock" not held when
    accessing this.numElts</computeroutput>. Eclipse opens an editor window for
    <classname>BoundedFIFO</classname> and highlights the field
    expression <code>numElts</code> on line 52. In addition the
    <guilabel>JSure Historical Source</guilabel> view shows the same
    code because the current Java code and the code when the scan was
    performed are the same.

  <mediaobject>
    <imageobject>
      <imagedata fileref="images/boundedfifo3.png" />
    </imageobject>
  </mediaobject>   
  
  <tip>
		<title>How to show line numbers in the Eclipse Java editor</title>
		
		<para>You can enable line numbering in the Java editor by
      right-clicking in the editor gutter and selecting <guimenu>Show
      Line Numbers</guimenu> or by going to
      <menuchoice><guimenu>General</guimenu>
      <guisubmenu>Editors</guisubmenu> <guisubmenu>Text
      Editors</guisubmenu></menuchoice> in the Eclipse
      <guilabel>Preferences</guilabel> dialog box, and selecting
      <guilabel>Show line numbers</guilabel> in the preference
      pane.</para>
 </tip> 
      
    This state access is one of many in the <function>get()</function>
    method.  A quick inspection of the method shows that it does not
    acquire any locks.  In fact, if you scroll through the rest of the
    <classname>BoundedFIFO</classname> you will see that no locks are
    acquired anywhere.  There are several explanations for this
    situation, including
      <orderedlist>
        <listitem id="li1">
          <para>The class is broken and needs to have
          <code>synchronization</code> statements added to it.</para>
        </listitem>
        <listitem id="li2">
          <para>The class expects the locks to acquired by users of
          instances of the class.</para>
        </listitem>
        <listitem id="li3">
          <para>The class uses some other technique to prevent data
          races.</para>
        </listitem>
      </orderedlist>
    It is very possible that <xref linkend="li1"/> is the case.  Another
    quick inspection of the code suggests that <xref linkend="li3"/> is
    probably not the case.  We need to inspect the clients of
    <classname>BoundedFIFO</classname> to consider <xref
    linkend="li2"/>. </para>

    <para>We can investigate the clients of
    <classname>BoundedFIFO</classname> by seeing where the methods of
    the class are invoked.  Of course, we know already that the class
    is used by <classname>BlockingFIFO</classname>, but suppose we did
    not already know that.  We can find this out by using Eclipse to
    display the call hierarchy for a method.  Open the context menu
    within the <function>get()</function> method and select
    <menuchoice><guimenuitem>Open Call
    Hierarchy</guimenuitem></menuchoice>.  The <guilabel>Call
    Hierarchy</guilabel> view appears, and shows
    
      <mediaobject>
        <imageobject>
         <imagedata fileref="images/boundedfifo4.png" />
        </imageobject>
      </mediaobject>    
    
    This tells us that <function>BoundedFIFO.get()</function> is
    called by <function>BlockingFIFO.get</function>.  Double-clicking
    on <computeroutput>get() - test.BlockingFIFO</computeroutput> opens
    <classname>BlockingFIFO</classname> in a Java editor and selects
    the call expression:
    
      <mediaobject>
        <imageobject>
         <imagedata fileref="images/boundedfifo5.png" />
        </imageobject>
      </mediaobject>    
    </para>
    
    <para>Here we can see that the
    <function>BlockingFIFO.get()</function> calls
    <code>fifo.get()</code> on line 38. The method acquires the lock
    on the object referenced by <structfield>fifo</structfield> on
    line 29.  This suggests that it is the case the clients of
    <classname>BoundedFIFO</classname> are expected to acquire the
    lock.</para>
  </sect3>

  <sect3 id="declaring-lock-preconditions">
    <title>Declaring Lock Preconditions</title>
    
    <para>We can test this hypothesis by annotating all the methods of
    <classname>BoundedFIFO</classname> with the lock precondition
    <classname>@RequiresLock("BufLock")</classname>.  There are seven
    methods in the class, so we could quickly add the annotations
    without too much work.  We can also take advantage of the
    <guilabel>Proposed Annotations</guilabel> view to have JSure add
    these promises for us.  First, we make sure the view is only showing inferred annotations by
    pressing the <inlinegraphic fileref="images/annotation_abductive.gif"/> icon
    in the view's tool bar (or unselecting <inlinegraphic fileref="images/annotation_abductive.gif"/> <guilabel>Show Only Proposals
    Inferred From Other Promises</guilabel> in the view's menu). In the tree view of the proposed annotations, select
    the project <classname>JSureTutorial_BoundedFIFO</classname> and
    choosing <menuchoice><guimenuitem>Expand</guimenuitem></menuchoice>:
    
      <mediaobject>
        <imageobject>
         <imagedata fileref="images/proposed-annotation-requireslock.png" />
        </imageobject>
      </mediaobject>    
      
    The view shows annotations in the context of the Java declaration 
    that they are proposed to be automatically placed on. Selecting any node
    in the tree, including a Java declaration
    or Eclipse project, and choosing <menuchoice><guimenuitem>Annotate Code...</guimenuitem></menuchoice>
    from the view context menu begins an automatic code edit.
    Doing this would bring up an Eclipse source code refactoring
    dialog box.  We choose not to go this route here, however, an example of
    adding annotations using this view is presented below.
    </para>
    
    <para>There is a way, however, to accomplish the
    same thing with only single annotation: we can use a
    <emphasis>scoped annotation</emphasis> to add the annotation to all
    the methods in the class.

      <programlisting>
@RegionLock("BufLock is this protects Instance")
<emphasis>@Promise("@RequiresLock(BufLock) for *(**)")</emphasis>
public class BoundedFIFO {
  &hellip;
}
      </programlisting>  

    Here we use the <classname>@Promise</classname> annotation to add
    <code>@RequiresLock("BufLock")</code> to the class members that
    match the pattern <code>*(**)</code>. In the scoped promise the
    quotation marks are removed from inside the parenthesis. This is
    to avoid having to escape the inner quotation marks (i.e., \").
    The pattern <code>*(**)</code> matches method with any name,
    <code>*</code>, that have any parameter list, <code>(**)</code>.
    Using a scoped promise has the additional advantage of better
    capturing the design intent: all methods in the class are expected
    to have the same lock precondition.  Were we to add a new method
    to the class, and if we did not use the scoped annotation, we
    would have to remember to add the
    <classname>@RequiresLock</classname> annotation to the new method.
    The scoped annotation would automatically apply the lock
    precondition to a new method.</para>

    <para>Add the <classname>@Promise</classname> annotation to
    <classname>BoundedFIFO</classname> and save the source
    file. You could choose <menuchoice><guimenu>JSure</guimenu>
    <guisubmenu>Verify Project</guisubmenu></menuchoice> from the
    Eclipse main menu to scan the project again or use the keyboard
    shortcut
    <keysym>Ctrl</keysym>+<keysym>Alt</keysym>+<keysym>Shift</keysym>+<keysym>V</keysym>,
    however there is an easy shortcut to re-run the same scan again. Select the scan
    in the <guilabel>JSure Scans</guilabel> view and choose <menuchoice><guimenu>Re-Verify</guimenu></menuchoice>
    from the context menu as shown below.</para>
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo-re-verify.png"/>
        </imageobject>
      </mediaobject>    
        
    <para>After the analysis completes, there is a new <guilabel>Scoped
    promises</guilabel> heading in the <guilabel>Verification
    Status</guilabel> view, and we can see all the places where the
    <classname>@Promise</classname> annotation added
    <classname>@RequiresLock</classname> annotations. Only 4 out of
    the 7 are currently satisfied:
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo6.png"/>
        </imageobject>
      </mediaobject>
      
    Note that the view highlights differences in light yellow. In this case indicating that the scoped
    promise results are new since the previous scan. A <inlinegraphic fileref="images/delta_decr.gif"/> decorates
    the lower-right of all images providing a trail from the root of the view's tree to new and changed results.
    </para>
    
    <para>Let us look at the chain of evidence for the unassured
    <code>@RequiresLock</code> on the method <function>BoundedFIFO.isFull()</function>:
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo7.png"/>
        </imageobject>
      </mediaobject>
    
    We see that the caller is confused and is synchronized on
    <parameter>this</parameter> (as evidenced by the caller holding
    the lock <code>this.MUTEX</code>), although the analysis tells use
    that the lock on <code>this.fifo</code> is the lock that is
    needed.  Double-clicking on the supporting information result
    opens a Java editor and selects the expression that acquires the
    lock:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo8.png"/>
        </imageobject>
      </mediaobject>

    Here we see that the method
    <function>BlockingFIFO.put()</function> acquires the lock on
    <parameter>this</parameter>.  But in the context of
    <classname>BlockingFIFO</classname>, <parameter>this</parameter>
    refers to the <classname>BlockingFIFO</classname> object, not the
    <classname>BoundedFIFO</classname> object that is correctly
    referred to by <structfield>fifo</structfield>. Therefore, this
    code is <emphasis>acquiring the wrong lock</emphasis>. The
    <code>synchronized</code> statement in method
    <function>isFull()</function> needs to be changed:

      <programlisting>
public void put(LoggingEvent e) {
  synchronized (<emphasis>fifo</emphasis>) {
    &hellip;
  }
}
      </programlisting>
    </para>
    
    <para>Indeed, this problem is why the <computeroutput>java.lang.Object.MUTEX</computeroutput> lock model has remained unassured.
        Notice that <code>fifo.notify()</code>  is called within the synchronized block.
        The <computeroutput>java.lang.Object.MUTEX</computeroutput> lock model declares the object itself (in this case <code>fifo</code>) as the
        lock that protects the waitâ€“notify queue, and requires that the lock be held before the
        <code>wait()</code> and <code>notify()</code> methods may be invoked.  The verification state of this model
        also hinted that the wrong lock was being acquired in the code. This code change will allow the <computeroutput>java.lang.Object.MUTEX</computeroutput> lock model to assure.</para>
    
    <para>Make this change to <filename>BlockingFIFO.java</filename>
    and run another JSure scan using the keyboard shortcut
    <keysym>Ctrl</keysym>+<keysym>Alt</keysym>+<keysym>Shift</keysym>+<keysym>V</keysym> or
    by using <guilabel>Re-Verify</guilabel> in the <guilabel>JSure Scans</guilabel> view.</para>
  </sect3>
  
  <sect3 id="single-threaded-constructor">
    <title>Declaring a Thread-Confined Constructor</title>

    <para>After analysis of the
    <application>JSureTutorial_BoundedFIFO</application> code completes, all
    the lock preconditions are assured, but there are still five
    unprotected field accesses:
    
    <mediaobject>
      <imageobject>
	<imagedata fileref="images/boundedfifo9.png"/>
      </imageobject>
    </mediaobject>

    Getting to these results can take several click in the
    <guilabel>Verification Status</guilabel> view. It is possible to
    get a list of the inconsistent analysis results more directly
    using the <guilabel>JSure Quick Search</guilabel>.

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/boundedfifo9qs1.png"/>
      </imageobject>
    </mediaobject>

    Select <guilabel>Analysis Result</guilabel> from the menu. This
    lets you filter the results by the type of analysis result. The
    graphics show that there are 41 analysis results and that 36 of
    those results are consistent and 5 are inconsistent. Check
    <inlinegraphic fileref="images/red_x.gif"/>
    <guilabel>Inconsistent</guilabel>. This selection allows the
    inconsistent analysis results through this filter. We don't need
    another filter, so select <guilabel>Show</guilabel> to show the 5
    inconsistent analysis results.

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/boundedfifo9qs2.png"/>
      </imageobject>
    </mediaobject>

    This query is useful so we want to save it for future use. Click
    on the <inlinegraphic fileref="images/saveas_edit.gif"/> icon at
    the lower-left of the view and enter <code>X Results</code> into
    the dialog.

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/boundedfifo9qs3.png"/>
      </imageobject>
    </mediaobject>

    Press <guilabel>OK</guilabel> to save the query. It now appears in
    the space below the view and can be selected at any time via a
    click. Let's test the saved query. First, clear the current query
    by pressing the <inlinegraphic fileref="images/gray_x.gif"/> image
    in the upper-right-hand corner of the view. The view resets to its
    initial state. Now, to get our query back, click on the <code>X
    Results</code> link at the bottom of the view. The query is
    redisplayed in the view.

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/boundedfifo9qs4.png"/>
      </imageobject>
    </mediaobject>
    </para>

    <para>If you double-click on the five assurance failures, the
    <inlinegraphic fileref="images/red_x.gif"/> results at the right
    above, you will see that they point to the field initializers for
    the fields <structfield>first</structfield>,
    <structfield>next</structfield>, and
    <structfield>numElts</structfield>, and to the use of the fields
    <structfield>buf</structfield> and <structfield>size</structfield>
    in the class&rsquo;s constructor.  Constructors are interesting
    because we cannot require the caller to hold a lock on
    <parameter>this</parameter> because the instance does not exist
    before the constructor is called.  Furthermore, it is bad practice
    to use <code>synchronized</code> blocks in the constructor to
    protect the state of the object under construction because we
    cannot create a single atomic block that encloses all the
    constructors invoked while initializing an object.  There would
    have to be multiple distinct <code>synchronized</code> blocks: one
    in the constructor for the class and one in each constructor of
    any subclasses, etc.</para>
    
    <para>The solution is to take advantage of the fact the
    constructor is operating on a newly created object.  Specifically,
    we would like to assure that the constructor does not do anything
    that gives any thread other than the one that invoked the
    constructor access to the newly created object.  If we can assure
    this, we know that the object can only be accessed by a single
    thread&mdash;the one that invoked the constructor&mdash;during the
    execution of the constructor.  We can do this by annotating the 
    constructor <function>BoundedFIFO(int)</function> with
    <classname>@Unique("return")</classname> to declare
    the intent that no aliases to the newly constructed object will be
    created during the execution of the constructor.  This annotation is
    listed in the <guilabel>Proposed Annotation</guilabel> view:
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/proposed-annotation-uniquereturn.png"/>
        </imageobject>
      </mediaobject>
    </para>

    <para>Select the <classname>@Unique("return")</classname> annotation
    in the view and choose <menuchoice><guimenuitem>Annotate
    Code&hellip;</guimenuitem></menuchoice> from the context menu.  An Eclipse
    refactoring dialog appears:
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/proposed-annotation-refactoring-window.png"/>
        </imageobject>
      </mediaobject>
    
    Select <guibutton>OK</guibutton> to insert the annotation.  Rescan
    the project and the model now assures:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo10.png"/>
        </imageobject>
      </mediaobject>    
    </para>
        
    <tip>
      <para>For constructors the annotations
      <classname>@Unique("return")</classname> and
      <classname>@Borrowed("this")</classname> are defined to be
      equivalent. That said, most programmers have a mental model of the
      constructor "returning" a new object. The idea that the returned
      object is required to be a unique reference is intuitive to them
      and, therefore, the <classname>@Unique("return")</classname>
      annotation is as well.</para>
    </tip>
    
    <para>The verification result for <classname>BufLock</classname> includes
    a <inlinegraphic fileref="images/reddot_decr.gif"/> icon in its
    upper-left. This is an indication of something in the consistency proof
    that is not being checked, or verified, by analysis. In this case the
    consistency of the <classname>BufLock</classname> lock model depends upon
    the <classname>@Unique("return")</classname> promise at line 43. As can be seen
    at the bottom of the image above, this promise is not only decorated by a
    <inlinegraphic fileref="images/reddot_decr.gif"/> icon in its
    upper-left but also by a <inlinegraphic fileref="images/trusted_decr.gif"/> icon in its
    upper-right. The <inlinegraphic fileref="images/trusted_decr.gif"/> indicates
    that the promise is <emphasis>trusted</emphasis>&mdash;it is not checked by an analysis.
    This is because we asked you to be sure that the uniqueness
    verifying analysis is turned off. This is the analysis which
    checks the <classname>@Unique("return")</classname> promise. A key feature of JSure is that analyses can be turned on
    and off (or replaced)&mdash;the automated reasoning/proof maintenance system is a separate component
    from the verifying analyses. In
    the <guilabel>Verification Status</guilabel> any trail of <inlinegraphic fileref="images/reddot_decr.gif"/>
    icons will lead you to a node that not being checked, or verified, by analysis.</para>
  </sect3>    
  
  <sect3 id="aggregating-state">
    <title>Aggregating State</title>
    
    <para>Although the results show no outright assurance failures, there are still 
    two warnings about references to possibly shared objects:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo11.png"/>
        </imageobject>
      </mediaobject>

    These warnings refer to access to the contents of the array
    referenced by the field <structfield>buf</structfield>. This array
    is an object separate from the <classname>BoundedFIFO</classname>
    object and is not protected by the lock protecting the fields of the
    <classname>BoundedFIFO</classname> object. We can extend protection
    to the contents of the array by declaring the array reference to be
    <classname>@Unique</classname>&mdash;no object but the
    <classname>BoundedFIFO</classname> object can hold a reference to
    it&mdash;this also declares that the state of the array is part
    of the state of the <classname>BoundedFIFO</classname>
    object (its <code>Instance</code> region):
    
      <programlisting>
@RegionLock("BufLock is this protects Instance")
@Promise("@RequiresLock(BufLock) for *(**)")
public class BoundedFIFO {
  <emphasis>@Unique</emphasis>
  LoggingEvent[] buf;
  &hellip;
}
      </programlisting>
    
    This annotation is suggested by JSure in the
    <guilabel>Verification Status</guilabel> view (under the
    suggestion) and in <guilabel>Proposed Promises</guilabel>
    view. Add the promise using the context menu in the
    <guilabel>Verification Status</guilabel> view. Select <guilabel>Annotate Code..</guilabel>
    to add the proposed <classname>@Unique</classname> annotation to the
    code.
    </para>
    
    <para>Now, as part of the state of the
    <classname>BoundedFIFO</classname> object, the array object
    referenced by <structfield>buf</structfield> is also protected by
    the lock that protects that state of the buffer.</para>

    <para>After adding the annotations to the field
    <structfield>buf</structfield> and performing a scan of the
    <application>JSureTutorial_BoundedFIFO</application> project again we can
    see the effects of this annotation: there are now 29 protected
    field accesses, up from 27. This is because the two array
    dereferences are now counted as protected accesses (lines 59 and
    76):
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo12.png"/>
        </imageobject>
      </mediaobject>      
      
      The models and code in the
      <application>JSureTutorial_BoundedFIFO</application> project are now
      consistent with no warnings.
    </para>
  </sect3>

  <sect3 id="named-region">
    <title>Using a Named Region</title>
    
    <para>The lock <structfield>BufLock</structfield> is declared to protect
    the region <structfield>Instance</structfield>.  This is a region declared
    the class <classname>java.lang.Object</classname> that is the ancestor of 
    every instance field declared in a class.  By associating the lock with this
    region we declare that every instance field of the class, <emphasis>and every
    instance field declared in all subclasses of the class</emphasis>, are protected
    by the lock.  This is not something that we always want to do, and using the 
    <structfield>Instance</structfield> region in this way, while convenient, 
    does not usually describe the design intent as well as one might like.  It is
    often better to use an explicitly declared region.  In real-world use of the JSure
    tool explicitly declared regions are far more common than the use of the
    default <structfield>Instance</structfield> region. It is important for you to
    understand how to use explicitly declared regions.  Here we demonstrate how to
    annotate <classname>BoundedFIFO</classname> to use an explicitly declared
    region <structfield>BufState</structfield>.</para>
    
    <para>We declare the new region using the <classname>Region</classname> annotation
    on the class <classname>BoundedFIFO</classname>.  We also update the
    <classname>RegionLock</classname> annotation to protect
    <structfield>BufState</structfield> instead of <structfield>Instance</structfield>:

      <programlisting><emphasis>@Region("BufState")</emphasis>
@RegionLock("BufLock is this protects <emphasis>BufState</emphasis>")
@Promise("@RequiresLock(BufLock) for *(**)")
public class BoundedFIFO {
  &hellip;
}</programlisting>
    
    After making this change and performing a scan of the project, the
    model still assures, but upon closer inspection the assurance is
    essentially vacuous because it contains no protected or
    unprotected field accesses, although the method preconditions are
    still shown to be satisfied:
    
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo-named-region1.png"/>
        </imageobject>
      </mediaobject>      
    </para>
    
    <para>The problem here is that the region
    <structfield>BufState</structfield> is initially empty.  It needs
    to be populated with actual state, that is, with fields.  This is
    done by annotating fields with the <classname>InRegion</classname>
    annotation and changing our <classname>Unique</classname>
    annotation to a <classname>UniqueInRegion</classname> annotation:
    
      <programlisting>@Region("BufState")
@RegionLock("BufLock is this protects BufState")
@Promise("@RequiresLock(BufLock) for *(**)")
public class BoundedFIFO {
  <emphasis>@UniqueInRegion("BufState")</emphasis>
  LoggingEvent[] buf;

  <emphasis>@InRegion("BufState")</emphasis>
  int numElts = 0;
  <emphasis>@InRegion("BufState")</emphasis>
  int first = 0;
  <emphasis>@InRegion("BufState")</emphasis>
  int next = 0;
  <emphasis>@InRegion("BufState")</emphasis>
  int size;
  &hellip;
}</programlisting>
    
    In this case, we place each of the fields into the
    region <structfield>BufState</structfield>.  We also update the
    aggregation of the array referenced by
    <structfield>buf</structfield> so that the array elements are
    aggregated into <structfield>BufState</structfield> by replacing
    the previous <classname>@Aggregate</classname> annotation with
    <classname>@AggregateInRegion("BufState")</classname>.  After these
    changes we again have 29 protected field accesses:

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo-named-region2.png"/>
        </imageobject>
      </mediaobject>      
    </para>
    
    <para>Region declarations, like field declarations, accept
    visibility modifiers. The absence of a modifier in the declaration
    for <structfield>BufState</structfield> means the region has
    &ldquo;default&rdquo; or &ldquo;package&rdquo; visibility.  This is
    the minimum visibility necessary for this region because the fields
    we have populated it with have that same visibility.  If we tried to
    declare the region to be <code>private</code>, JSure would report a
    modeling error because all the fields are of &ldquo;default&rdquo; visibility.
    To see this change the <classname>@Region</classname> annotation to
    <classname>@Region("<emphasis>private</emphasis> BufState")</classname> and scan
    the project again. The expected modeling problems about field visibility will
    appear to the upper-right as shown below.
       <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo-named-region3.png"/>
        </imageobject>
      </mediaobject>
    </para>
    
    <para>It would make more sense, however, for the
    region and fields in <classname>BoundedFIFO</classname> to be
    declared <code>private</code>; in this
    case there is no reason for them to be visible to other classes. 
    This prevents, for example, a subclass from adding additional fields
    to the region&mdash;because the region is not visible to
    subclasses&mdash;and interfering with the design intent.
    
      <programlisting>@Region("private BufState")
@RegionLock("BufLock is this protects BufState")
@Promise("@RequiresLock(BufLock) for *(**)")
public class BoundedFIFO {
  @UniqueInRegion("BufState")
  <emphasis>private</emphasis> LoggingEvent[] buf;

  @InRegion("BufState")
  <emphasis>private</emphasis> int numElts = 0;
  @InRegion("BufState")
  <emphasis>private</emphasis> int first = 0;
  @InRegion("BufState")
  <emphasis>private</emphasis> int next = 0;
  @InRegion("BufState")
  <emphasis>private</emphasis> int size;
  &hellip;
}</programlisting>

Go ahead and make these changes and scan the project again. The
verification results should not change but the modeling problems will go away.
    </para>
  </sect3>

	<sect3>
		<title>Stating that BoundedFIFO @ThreadSafe</title>
		
		<para>We can now apply the <code>@ThreadSafe</code>
		annotations from
		<emphasis>Java Concurrency In Practice</emphasis>
		by Goetz, et. al. (Addison-Wesley 2006) to the <code>BoundedFIFO</code> class.
		
		<programlisting><emphasis>@ThreadSafe</emphasis>
@Region("private BufState")
@RegionLock("BufLock is this protects BufState")
@Promise("@RequiresLock(BufLock) for *(**)")
public class BoundedFIFO {
  &hellip;
}</programlisting>
		
		If we rescan the project with JSure we find that this does not assure. What is the problem?
		</para>
		
	  <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo-threadsafe1.png"/>
        </imageobject>
      </mediaobject>
		
		<para>While the <code>BufLock</code> lock model checked its protected state, placing an
		<code>@ThreadSafe</code> annotation on the class requires that all its state be
		thread safe&mdash;by being immutable, protected by a lock, and so on.  The results
		show that the array <code>buf</code> cannot be assured as thread safe because it is not
		considered <emphasis>containable</emphasis>. This means that instances of the class can be
		safely encapsulated via region aggregation into other objects because methods of this
		class do not leak references to themselves or any of the other objects that they
		reference, transitively. JSure cannot prove this for Java arrays (it is a surprisingly
		difficult aliasing problem), however, you can, however, to continue to move this
		<code>@ThreadSafe</code> model toward consistency by "vouching" for the buf field</para>
          
       <para>The use of the <code>@Vouch</code> annotation allows you to "override" or "quiet" a tool
       reported inconsistency. Using this feature produces a <inlinegraphic fileref="images/reddot_decr.gif"/>
       icon in its  upper-left. This is an indication of something in the consistency proof
       that is not being checked, or verified, by analysis. The <code>@Vouch</code> annotation is the reason the
       <inlinegraphic fileref="images/reddot_decr.gif"/> is used&mdash;it indicates that a programmer is
       willing to prick a finger and vouch for the unverified contingency with a small drop of blood&mdash;at
       least virtually. Use them with care and vouch for as little as possible.</para>
    
       <para>The first approach states the field is altogether thread-safe. The annotation is shown below.

          <programlisting><emphasis>@Vouch("ThreadSafe")</emphasis>
@UniqueInRegion("BufState")
private LoggingEvent[] buf;</programlisting>

       Make this change to the code and rescan. The results are shown below.</para>
            
       <mediaobject>
         <imageobject>
           <imagedata fileref="images/boundedfifo-threadsafe2.png"/>
         </imageobject>
       </mediaobject>
      
      <para>This works but we don't, in this case need to paint such a broad stroke. There are many cases
      where the <code>@Vouch("ThreadSafe")</code> annotation is reasonable, however in this case we can do better.
      We want to be sure that the lock model actually protects the state. To make sure that this is the case
      we simply vouch that the <code>buf</code> field is containable. This makes the aliasing assumption we
      want but causes the tool to verify that a lock protects the state (in this example <code>BufLock</code>).
            
                      <programlisting><emphasis>@Vouch("Containable")</emphasis>
@UniqueInRegion("BufState")
private LoggingEvent[] buf;</programlisting>

      Make this change to the code and rescan. The results are shown below.</para>
        
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/boundedfifo-threadsafe3.png"/>
        </imageobject>
      </mediaobject>
            
     <para>This is an improvement because we vouch only for the aliasing&mdash;not both aliasing and
     safe concurrency.  There are times where the <code>@Vouch</code> annotation
     (and the <code>@Assume</code> annotation) can help, with correct code that JSure is not precise enough
     to verify. Read the Javadoc for these annotations to learn more about how they works and see more
     examples.</para>
   
    <para>Another possible approach would be to change the <code>buf</code> array
    into a collection, such as <code>ArrayList</code>. In fact,
    we note, the entire <code>BoundedFIFO</code> could be replaced
    by a <code>java.util.concurrent.BlockingQueue</code> implementation, such as
    <code>ArrayBlockingQueue</code>. This would avoid client
    locking and simplify the code.</para>

	</sect3>

  <sect3 id="named-region">
    <title>Deleting Old Scans</title>

    <para>JSure saves each scan that you run. The <guilabel>JSure
    Scans</guilabel> view lists these scans and you can view their
    data by changing which scan is checked. Check a few of your
    earlier scans and note how the other JSure views change. Each time
    a new scan completes the view automatically selects this scan so
    that it's results are visible to the tool user.</para>

    <para>The <guilabel>JSure Scans</guilabel> view also lets you
    delete old scans which take up disk space on your machine. This is
    done by selecting them and choosing
    <menuchoice><guimenu>Delete</guimenu></menuchoice> from the view's
    context menu.</para>

    <para>We are done with the scans we performed on
    <application>JSureTutorial_BoundedFIFO</application> so select all the
    scans in the view (with the mouse or using
    <keysym>Ctrl</keysym>+<keysym>A</keysym>) and delete them with the
    view's context menu as shown below.

    <mediaobject>
      <imageobject>
	<imagedata fileref="images/deleting-boundedfifo-scans.png"/>
      </imageobject>
    </mediaobject>
    </para>

    <para>You are now finished with this tutorial. The next tutorial
    shows how to use the <code>@ThreadSafe</code> and <code>@Immutable</code> annotations
    to express design intent and verify it using JSure.</para>
  </sect3>
</sect2>
