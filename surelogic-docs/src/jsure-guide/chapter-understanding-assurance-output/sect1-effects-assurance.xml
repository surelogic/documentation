<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../lib/docbook-xml-4.5/docbookx.dtd">

<sect1 id="effects-assurance">
  <title>Effects Assurance</title>
  
  <para>This discussion of effects assurance results is based on
  assuring the class <classname>EffectsExample</classname>. This class
  does absolutely nothing useful except to demonstrate the various
  effects assurance results.  This class is found in the <filename>Effects Output</filename>
  project.</para>
  
  <figure id="EffectsExample.java">
    <title>The class <classname>EffectsExample</classname></title>
  
    <programlisting linenumbering="numbered" startinglinenumber="5">/**
 * This is a simple class that exists only to show off the 
 * assurance results the Effects Assurance can produce.
 */
public class EffectsExample {
  private int f1;
  
  private int f2;
  
  private int f3;

  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }

  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }

  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }

  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }

  /**
   * Indirectly bad!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad(new EffectsExample(1, 2, 3));
  }

  /**
   * Missing effects!
   */
  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad(final EffectsExample other) {
    return getSum() + other.doesAnything();
  }
</programlisting>
  </figure>
  
  <para>The results of effects assurance are displayed under the
  top-level heading <guilabel>Effects</guilabel> in the
  <guilabel>Verification Status</guilabel> view.  Under this heading is
  a subheading for each method and constructor that is annotated with
  <classname>@RegionEffects</classname>. Each entry is marked with
  either a green plus <guiicon><inlinegraphic
  fileref="images/green-plus.jpg"/></guiicon> or a red X
  <guiicon><inlinegraphic fileref="images/red-x.jpg"/></guiicon>
  indicating whether the effects annotation has been positively or
  negatively assured, respectively.</para>

  <para>In our example, the the methods <function>bad()</function> and
  <function>indirectlyBad()</function> fail to assure, while the methods
  <function>getSum()</function>, <function>update()</function>,
  <function>doesAnything()</function>, and the constructor
  <function>EffectsExample()</function> assure.</para>
  
  <mediaobject>
    <imageobject condition="isHTML">
      <imagedata fileref="images/effects-assurance-01.png"/>
    </imageobject>
    <imageobject condition="isFO">
      <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-01.png"/>
    </imageobject>
  </mediaobject>
  
  <para>There are four kinds of results that can appear as 
  evidence for and children of the promise results:</para>
  
  <itemizedlist>
    <listitem id="not-accounted-for">
      <formalpara>
        <title><replaceable>effect</replaceable> not accounted for by
        declared effect(s)</title>
      
        <para>The given effect of the method/constructor
        implementation is not accounted for by any of the declared effects
        of the method/constructor. That is, the method/constructor
        implementation affects more state than it declares it does.</para>
      </formalpara>
    </listitem>
    <listitem id="trivially-satisfy">
      <formalpara>
        <title>Empty effects trivially satisfy declared effects</title>
      
        <para>The method/constructor has no effects at all and
        thus trivially satisfies its declared effects.</para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title id="checked-by"><replaceable>effect<subscript>1</subscript></replaceable> checked by
        <replaceable>effect<subscript>2</subscript></replaceable></title>
      
        <para>The particular effect of the method/constructor
        implemenation,
        <replaceable>effect<subscript>1</subscript></replaceable>, is
        accounted for by the particular declared effect
        <replaceable>effect<subscript>2</subscript></replaceable>.
        Often, the implementation effect is more specific than the
        declared effect, i.e., it affects a region that is included in
        the region of the declared effect.</para>
      </formalpara>
    </listitem>
    <listitem>
      <formalpara>
        <title id="constructor-rule"><replaceable>effect</replaceable> checked by constructor rule: writes to a newly
        created object are invisible</title>
      
        <para>The particular effect of the constructor implemenation is
        accounted for by a special rule. Constructors do not need to
        report any effects they have on the object being constructed
        because these effects are invisible to the caller of the
        constructor (the object does not exist before the constructor
        was called).</para>
      </formalpara>
    </listitem>
  </itemizedlist>

  <para>The meanings of these results are further elaborated in the
  discussion below.</para>

  <sect2 id="simple-positive-assurances">
    <title>Simple Positive Assurances</title>
    
    <para>Let us examine the assurance results for
    <function>doesAnything()</function>, <function>getSum()</function>,
    and <function>EffectsExample()</function> in more detail. Their
    chains of evidence expand as follows</para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/effects-assurance-02.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-02.png"/>
      </imageobject>
    </mediaobject>
    
    <sect3 id="doesAnything">
      <title>Method <function>doesAnything()</function></title>
      
      <para>This method declares that it could read or write anything
      (<classname>@RegionEffects("writes
      java.lang.Object:All")</classname>), but in fact its
      implementation has no effects at all:</para>

      <programlisting linenumbering="numbered" startinglinenumber="16">  <emphasis>@RegionEffects("writes java.lang.Object:All")</emphasis>
  private int doesAnything() {
    return 0;
  }</programlisting>
      
      <para>Thus, the method assures and the result
      <computeroutput>Empty effects trivially satisfy declared
      effects</computeroutput> appears as evidence for the assurance of
      the declared effects.</para>
    </sect3>

    <sect3 id="getSum">
      <title>Method <function>getSum()</function></title>
      
      <para>Method getSum has the following implementation:</para>
      
      <programlisting linenumbering="numbered" startinglinenumber="28">  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int getSum() {
    return f1 + f2 + f3;
  }</programlisting>

      <para>This method declares that could read any of the instance
      fields of the reciever (<code>"reads instance"</code>, really a
      shorthand for <code>"reads this:Instance"</code>). The body of the
      method reads the three fields <structfield>f1</structfield>,
      <structfield>f2</structfield>, and <structfield>f3</structfield>.
      Thus, there are three effects that need to be accounted for in
      order for the declared effects to be assured. We see this in the
      three result drops that appear as evidence for the method&rsquo;s
      declared effects:</para>
      
      <itemizedlist>
        <listitem>
          <para><computeroutput>"reads &lt;this&gt;:f1" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
        </listitem>
        <listitem>
          <para><computeroutput>"reads &lt;this&gt;:f2" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
        </listitem>
        <listitem>
          <para><computeroutput>"reads &lt;this&gt;:f3" checked by "reads &lt;this&gt;:Instance" at EffectsExample.java line 30</computeroutput></para>
        </listitem>
      </itemizedlist>

      <para>In particular, there is one result for each implementation
      effect of the method, and the result is tagged to the line of code
      that corresponds to the expression that creates the effect.  In
      this case, all the effects eminate from line 30.</para>
    </sect3>
    
    <sect3 id="EffectsExample">
      <title>Constructor <function>EffectsExample</function></title>

      <para>The constructor declares that has no effects
      (<classname>@RegionEffects("none")</classname>) and has the
      following implementation:</para>
      
      <programlisting linenumbering="numbered" startinglinenumber="21">  <emphasis>@RegionEffects("none")</emphasis>
  public EffectsExample(final int x, final int y, final int z) {
    f1 = x;
    f2 = y;
    f3 = z;
  }</programlisting>
      
      <para>This case is similar to <function>getSum()</function> except
      that the evidence for the assurance is that the special
      constructor rule applies:</para>

      <itemizedlist>
        <listitem>
          <para><computeroutput>"reads &lt;this&gt;:f1" checked by
          constructor rule: writes to a newly created object are
          invisible at EffectsExample.java line
          23</computeroutput></para>
        </listitem>
        <listitem>
          <para><computeroutput>"reads &lt;this&gt;:f1" checked by
          constructor rule: writes to a newly created object are
          invisible at EffectsExample.java line
          24</computeroutput></para>
        </listitem>
        <listitem>
          <para><computeroutput>"reads &lt;this&gt;:f1" checked by
          constructor rule: writes to a newly created object are
          invisible at EffectsExample.java line
          25</computeroutput></para>
        </listitem>
      </itemizedlist>
    </sect3>
  </sect2>
  
  <sect2 id="complex-positive-assurance">
    <title>Complex Positive Assurance</title>
    
    <para>The assurance results for method <function>update()</function>
    are more complicated. This method calls another method,
    <function>getSum()</function>; thus some the effects of this method
    are due to the method that it calls:</para>
    
    <programlisting linenumbering="numbered" startinglinenumber="33">  <emphasis>@RegionEffects("writes Instance")</emphasis>
  public void update() {
    final int sum = getSum();
    f1 += sum;
    f2 += sum;
    f3 += sum;
  }</programlisting>
    
    <para>This dependency is reflected in the assurance results:</para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/effects-assurance-03.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-03.png"/>
      </imageobject>
    </mediaobject>
    
    <para>In particular, we see that the effect <code>reads
    &lt;this&gt;:Instance</code> is due to the declared effects of method
    <function>getSum()</function>.  Because of this, the results become
    a graph: the results go on to show that the declared effects of
    <function>getSum()</function> are assured. These are exactly the
    same results as described above. The point here is that we can see
    the complete line of assurance; in particular, the effect within
    <function>update()</function> is accounted for and the source of
    that effect has been assured as well. This is why the icon for the
    result (line 35) is a double-plus <guiicon><inlinegraphic
    fileref="images/plus-plus.jpg"/></guiicon>: the large plus indicates
    effect is assured in the context of the method
    <function>update()</function>, while the small plus indicates that
    the <emphasis>source</emphasis> of that effect has also been
    assured.</para>

    <para>The results for method <function>update</function> also show
    the supporting information <computeroutput>Parameter "this" bound to
    "this"</computeroutput>, detailing that the parameter
    <parameter>this</parameter> of the called method
    <function>getSum()</function> is bound to the receiver
    <parameter>this</parameter> of the calling method
    <function>update</function>.  The general form of this message is
    <computeroutput id="parameter">Parameter
    "<replaceable>formal</replaceable>" is bound to
    "<replaceable>actual</replaceable>"</computeroutput>.  This
    information can be useful in understanding how the effects of the
    method call are derived from the declared effects of the called
    method.</para>
  </sect2>
  
  <sect2 id="effects-failures">
    <title>Assurance Failures</title>
    
    <para>Now we examine the assurance results of the negatively assured
    methods <function>bad()</function> and
    <function>indirectlyBad()</function>.</para>
    
    <mediaobject>
      <imageobject condition="isHTML">
        <imagedata fileref="images/effects-assurance-04.png"/>
      </imageobject>
      <imageobject condition="isFO">
        <imagedata width="100%" scalefit="1" fileref="images/effects-assurance-04.png"/>
      </imageobject>
    </mediaobject>
    
    <sect3 id="method-bad">
      <title>Method <function>bad()</function></title>
      
      <para>Method <function>bad()</function> is incorrect because it
      invokes the method <function>doesAnything()</function> but only
      declares that it could read the state of the receiver
      (<code>"reads Instance"</code>).</para>

      <programlisting linenumbering="numbered" startinglinenumber="52">  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int bad(final EffectsExample other) {
    return getSum() + other.doesAnything();
  }</programlisting>

      <para>In particular, there are two results:</para>

      <orderedlist>
        <listitem>
          <para><computeroutput>"reads &lt;this&gt;:Instance" checked by
          "reads &lt;this&gt;:Instance" at EffectsExample.java line
          54</computeroutput> indicates that the effects of invoking
          <function>getSum()</function> on line 54 are accounted for by
          the declared effects.</para>
        </listitem>
        <listitem>
          <para><computeroutput>"writes java.lang.Object:All" not
          accounted for by declared effect(s) at EffectsExample.java
          line 54</computeroutput> indicates that the effects of
          invoking <function>doesAnything()</function> on line 54 are
          not accounted for.</para>
        </listitem>
      </orderedlist>
    </sect3>
    
    <sect3 id="method-indirectly-bad">
      <title>Method <function>indirectlyBad()</function></title>
      
      <para>This method is interesting because its declared effects do
      account for all the effects of its implementation, in the sense
      that the declared effects of called methods are considered to be
      part of the effects of this method. But the method still fails to
      assure because the declared effects of the called method&mdash;in
      this case <function>bad()</function>&mdash;cannot be
      assured.</para>

      <programlisting linenumbering="numbered" startinglinenumber="44">  <emphasis>@RegionEffects("reads Instance")</emphasis>
  public int indirectlyBad() {
    return bad(new EffectsExample(1, 2, 3));
  }</programlisting>

      <para>The method has a single result <computeroutput>"reads
      &lt;this&gt;:Instance" checked by "reads &lt;this&gt;:Instance" at
      EffectsExample.java line 46</computeroutput>. What is interesting,
      however, is that this result is marked with a plus subscripted
      with a red X <guiicon><inlinegraphic
      fileref="images/plus-x.jpg"/></guiicon>.  This means that the
      effects assure, but that the basis for the implementation effects,
      namely the effects declaration of the method
      <function>bad</function>, fails to assure.</para>
      
      <para>We also see a more interesting example of the parameter
      binding supporting evidence in the chain of evidence for
      <function>indirectlyBad</function>. The effect on line 46 has the
      supporting evidence
        <itemizedlist>
          <listitem>
            <para><computeroutput>Parameter "other" bound to "new EffectsExample(1, 2, 3)" at EffectsExample.java line 46</computeroutput></para>
          </listitem>
          <listitem>
            <para><computeroutput>Parameter "this" bound to "this" at EffectsExample.java line 46</computeroutput></para>
          </listitem>
        </itemizedlist>
      </para>
    </sect3>
  </sect2>
</sect1>
